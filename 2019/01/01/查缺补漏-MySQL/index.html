<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"z201.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="本章是整理知识内容，为强化知识长期更新。  Mysql基础架构图 简单介绍上图相关模块功能 连接器：管理连接，权限验证  查询缓存：命中缓存则直接返回结果  语法解析：词法分析，语法分析  查询优化：执行计划生成，索引选择  执行器：操作引擎，返回结果  存储引擎：存储数据，提供读写结构。   连接器 我们需要连接到mysql服务端才能进行各种操作。  12# 使用密码登录到时候我们会使用这种格">
<meta property="og:type" content="article">
<meta property="og:title" content="查缺补漏-MySQL">
<meta property="og:url" content="https://z201.github.io/2019/01/01/%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-MySQL/index.html">
<meta property="og:site_name" content="枫叶的小博客">
<meta property="og:description" content="本章是整理知识内容，为强化知识长期更新。  Mysql基础架构图 简单介绍上图相关模块功能 连接器：管理连接，权限验证  查询缓存：命中缓存则直接返回结果  语法解析：词法分析，语法分析  查询优化：执行计划生成，索引选择  执行器：操作引擎，返回结果  存储引擎：存储数据，提供读写结构。   连接器 我们需要连接到mysql服务端才能进行各种操作。  12# 使用密码登录到时候我们会使用这种格">
<meta property="og:image" content="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/mysql/mysql%E6%9E%B6%E6%9E%84.svg">
<meta property="og:image" content="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/mysql/SHOW_PROCESSLIST.png">
<meta property="og:image" content="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/mysql/SHOW_ENGINES.png">
<meta property="og:image" content="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/MysqlInnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/mysql/innodb-architecture.png">
<meta property="og:image" content="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png">
<meta property="article:published_time" content="2018-12-31T16:00:01.000Z">
<meta property="article:modified_time" content="2021-10-18T06:59:47.346Z">
<meta property="article:author" content="胖枫叶">
<meta property="article:tag" content="Mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/mysql/mysql%E6%9E%B6%E6%9E%84.svg">

<link rel="canonical" href="https://z201.github.io/2019/01/01/%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-MySQL/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>查缺补漏-MySQL | 枫叶的小博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="枫叶的小博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">枫叶的小博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">先完成、在完美。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-存档">

    <a href="/archives" rel="section"><i class="archive fa-fw"></i>存档</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-实践">

    <a href="/categories/%E5%AE%9E%E8%B7%B5" rel="section"><i class="graduation-cap fa-fw"></i>实践</a>

  </li>
        <li class="menu-item menu-item-查缺补漏">

    <a href="/categories/%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/" rel="section"><i class="graduation-cap fa-fw"></i>查缺补漏</a>

  </li>
        <li class="menu-item menu-item-面试">

    <a href="/categories/%E9%9D%A2%E8%AF%95/" rel="section"><i class="graduation-cap fa-fw"></i>面试</a>

  </li>
        <li class="menu-item menu-item-微服务">

    <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1" rel="section"><i class="graduation-cap fa-fw"></i>微服务</a>

  </li>
        <li class="menu-item menu-item-jvm">

    <a href="/tags/Jvm/" rel="section"><i class="graduation-cap fa-fw"></i>Jvm</a>

  </li>
        <li class="menu-item menu-item-java">

    <a href="/tags/Java/" rel="section"><i class="graduation-cap fa-fw"></i>Java</a>

  </li>
        <li class="menu-item menu-item-spring">

    <a href="/tags/Spring" rel="section"><i class="graduation-cap fa-fw"></i>Spring</a>

  </li>
        <li class="menu-item menu-item-netty">

    <a href="/tags/Netty" rel="section"><i class="graduation-cap fa-fw"></i>Netty</a>

  </li>
        <li class="menu-item menu-item-git">

    <a href="/tags/Git" rel="section"><i class="graduation-cap fa-fw"></i>Git</a>

  </li>
        <li class="menu-item menu-item-linux">

    <a href="/tags/Linux" rel="section"><i class="graduation-cap fa-fw"></i>Linux</a>

  </li>
        <li class="menu-item menu-item-docker">

    <a href="/tags/Docker" rel="section"><i class="graduation-cap fa-fw"></i>Docker</a>

  </li>
        <li class="menu-item menu-item-redis">

    <a href="/tags/Redis" rel="section"><i class="graduation-cap fa-fw"></i>Redis</a>

  </li>
        <li class="menu-item menu-item-mysql">

    <a href="/tags/Mysql/" rel="section"><i class="graduation-cap fa-fw"></i>Mysql</a>

  </li>
        <li class="menu-item menu-item-mybatis">

    <a href="/tags/Mybatis" rel="section"><i class="graduation-cap fa-fw"></i>Mybatis</a>

  </li>
        <li class="menu-item menu-item-vue">

    <a href="/tags/Vue" rel="section"><i class="graduation-cap fa-fw"></i>Vue</a>

  </li>
        <li class="menu-item menu-item-公益404">

    <a href="/404.html" rel="section"><i class="heartbeat fa-fw"></i>公益404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://z201.github.io/2019/01/01/%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar-min.jpg">
      <meta itemprop="name" content="胖枫叶">
      <meta itemprop="description" content="多听、多看、少说、多做。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶的小博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          查缺补漏-MySQL
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-01 00:00:01" itemprop="dateCreated datePublished" datetime="2019-01-01T00:00:01+08:00">2019-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-18 14:59:47" itemprop="dateModified" datetime="2021-10-18T14:59:47+08:00">2021-10-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/" itemprop="url" rel="index"><span itemprop="name">查缺补漏</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>本章是整理知识内容，为强化知识长期更新。</p>
</blockquote>
<h3 id="Mysql基础架构图"><a href="#Mysql基础架构图" class="headerlink" title="Mysql基础架构图"></a>Mysql基础架构图</h3><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/mysql/mysql%E6%9E%B6%E6%9E%84.svg" alt="mysql基础架构图"></p>
<h4 id="简单介绍上图相关模块功能"><a href="#简单介绍上图相关模块功能" class="headerlink" title="简单介绍上图相关模块功能"></a>简单介绍上图相关模块功能</h4><ul>
<li><p>连接器：管理连接，权限验证</p>
</li>
<li><p>查询缓存：命中缓存则直接返回结果</p>
</li>
<li><p>语法解析：词法分析，语法分析</p>
</li>
<li><p>查询优化：执行计划生成，索引选择</p>
</li>
<li><p>执行器：操作引擎，返回结果</p>
</li>
<li><p>存储引擎：存储数据，提供读写结构。</p>
</li>
</ul>
<h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><blockquote>
<p>我们需要连接到mysql服务端才能进行各种操作。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用密码登录到时候我们会使用这种格式。</span></span><br><span class="line">mysql -h<span class="variable">$ip</span> -P<span class="variable">$port</span> -u<span class="variable">$user</span> -p</span><br></pre></td></tr></table></figure>

<p>执行上述命令会提示输入密码。输入完密码后就进入了mysql。</p>
<ul>
<li><p>如果用户名或者密码输入错误，会提示一个<code>Access denied for user</code>到错误，然后客户端程序结束执行。</p>
</li>
<li><p>如果用户名和密码认证通过，连接器会去权限表中查询该用户拥有的所有权限。此后该连接里面的权限逻辑判断都会依赖认证成功时候读取到的权限。</p>
</li>
</ul>
<blockquote>
<p>因此当修改用户的权限之后，如果被修改用户的在登录状态是不会修改已经连接的权限。需要让被修改权限用户从新登录。</p>
</blockquote>
<ul>
<li>实际上连接的方式有多种，上面通过密码的方式只是其中的一种方式。当客户端与服务端mysql进程进程建立连接，服务器的进程就会创建一个单独的线程来专门处理与这个客户端的交互，当该客户断开与服务端连接时，服务端并不会马上销毁对应的交互线程，而是缓存起来。当另一个新的客户端连接进来的时候，在把这个缓存的线程分配给新的客户端。这样就避免的频繁创建和修改线程，节省系统的开销。但是连接线程多了也会影响服务端，所以也有默认的参数限制客户端的连接数量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这里是查询服务端存在的连接。</span><br><span class="line">SHOW PROCESSLIST;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我使用的阿里云的数据库，这里展示下结果集。这里需要注意，登录的账号需要有PROCESS的权限否则只能看到自己的连接信息（线程），我这里采用的root所以看到全部到。</p>
</blockquote>
<p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/mysql/SHOW_PROCESSLIST.png"></p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/processlist-table.html" target="_blank" rel="noopener">MySQL PROCESSLIST 官方文档</a></li>
</ul>
<blockquote>
<p>连接完成后如果没有执行后续操作则 Command会显示Sleep的状态，长时间Sleep会导致连接自动断开。默认的时间是8小时，也就是参数 <code>wait_timeout</code>。当客户端连接断开后，若客户端再次发出请求就会提示一个</p>
<p><code>Lost connection to MySQL server during query</code>，此时就只能重新建立连接了。</p>
</blockquote>
<h5 id="半双工"><a href="#半双工" class="headerlink" title="半双工"></a>半双工</h5><ul>
<li>MySQL客户端/服务端通信协议是<code>“半双工”</code>的：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。</li>
<li>服务器响应给用户的数据通常会很多，由多个数据包组成。但是当服务器响应客户端请求时，客户端必须完整的接收整个返回结果，而不能简单的只取前面几条结果，然后让服务器停止发送。因而在实际开发中，尽量保持查询简单且只返回必需的数据，减小通信间数据包的大小和数量是一个非常好的习惯，这也是查询中尽量避免使用<code>SELECT *</code>以及加上<code>LIMIT</code>限制的原因之一。</li>
</ul>
<h5 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h5><ul>
<li><p>在数据库里面，长连接是指数据库建立连接，如果客户端有持续的请求则使用同一个连接，短连接是指每次执行几次短的查询就断开连接，下次查询再次创建连接。由于创建的过程复杂，一般来说尽量减少创建连接的动作，尽可能使用长连接。特别是在开发的时候出现大伙突然连接不上测试库，此时就检查下连接是不是太多了。因为连接多了会导致内存消耗特别快。</p>
<ul>
<li>mysql的执行过程中临时使用的内存管理是在连接线程对象里面，服务端断开的时候才会释放，为了避免内存消耗过大，每次执行较大的操作之后，可以通过<code>mysql_reset_connection</code>来重新初始化连接资源。这个操作是不需要重新做权限，只是恢复到创建的初始状态。</li>
</ul>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-reset-connection.html" target="_blank" rel="noopener">MySQL mysql_reset_connection 官方文档</a></p>
</li>
</ul>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><blockquote>
<p> 一个不被建议使用的功能，在新版的8.0中已经被删除了。总结就是弊大于利。</p>
</blockquote>
<ul>
<li>建立完成后，假设执行一次<code>SELECT</code>语句，执行逻辑就会到第二部查询缓存。mysql拿到一个查询之后，会先到缓存中寻找释放有完全对应的，因为之前执行的查询语句和结果集会直接被缓存起来，以<code>Keys-value</code>的形式。keys是查询语句-value是查询结果集。如果能命中这个key则直接返回value。咋一看挺有用的，但实际上查询缓存的实效的太频繁。并且keys的命中条件太不聪明了，<code>如果两次查询语句在任何的字符上存在不通（空格、大小写）</code>都不会缓存命中。为什么会频繁失效，因为如果对查询语句中的表进行更新，就会导致缓存失效。比如<code>INSERT、UPDATE 、DELETE 、TRUNCATE TABLE 、ALTER TABLE </code>等等就会导致缓存失效。</li>
</ul>
<h4 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h4><blockquote>
<p>如果没有命中查询缓存，就要开始执行sql语句了。mysql需要做什么，因此需要对sql进行解析。MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。这个过程解析器主要通过语法规则来验证和解析。比如SQL中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据MySQL规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等等。</p>
</blockquote>
<ul>
<li>本质上发送过来的是一个文本信息，这里就需要对该文本信息进行编译，涉及到<code>词法解析</code>、<code>语法解析</code>、<code>语义解析</code>等阶段。需要注意的是，这里会对sql语句进行一些检查，比如设计的相关表、表字段。这里检查通过的才会进入查询优化模块。</li>
<li>根据SQL语言的功能可以划分成4个部分<ul>
<li>DDL，英文叫做 Data Definition Language，也就是数据定义语言，它用来定义我们的数据库对象，包括数据库、数据表和列。通过使用 DDL，我们可以创建，删除和修改数据库和表结构。</li>
<li>DML，英文叫做 Data Manipulation Language，数据操作语言，我们用它操作和数据库相关的记录，比如增加、删除、修改数据表中的记录。</li>
<li>DCL，英文叫做 Data Control Language，数据控制语言，我们用它来定义访问权限和安全级别。</li>
<li>DQL，英文叫做 Data Query Language，数据查询语言，我们用它查询想要的记录，它是 SQL 语言的重中之重。在实际的业务中，我们绝大多数情况下都是在和查询打交道，因此学会编写正确且高效的查询语句，是学习的重点。</li>
</ul>
</li>
</ul>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><blockquote>
<p>通过之前的语法解析，基本可以判定语法树是合法的，此时mysql就知道文本内容要做什么。</p>
</blockquote>
<ul>
<li>mysql会对查询语句进行优化，优化的结果就是生成一个执行计划，这个计划会表明使用了那些查询索引，表之间的连接是什么样子的。有时候出现多种执行方式，只是效率不通，优化器会决定使用哪一个执行方案，这个时候就涉及到<code>EXPLAIN</code>语句，该语句可以查看sql到执行计划，这将涉及到查询优化。</li>
<li>MySQL的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划：<ul>
<li>重新定义表的关联顺序（多张表关联查询时，并不一定按照SQL中指定的顺序进行，但有一些技巧可以指定关联顺序）</li>
<li>优化函数</li>
<li>提前终止查询（比如：使用Limit时，查找到满足数量的结果集后会立即终止查询）</li>
<li>优化排序（在老版本MySQL会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于<code>I/O</code>密集型应用，效率会高很多。</li>
</ul>
</li>
</ul>
<h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><blockquote>
<p>进入到执行sql到环节。</p>
</blockquote>
<ul>
<li>通过之前到查询优化，进入执行阶段，此时会先判断该连接用户是否有相关表的权限，如果没有会返回权限错误。如果有权限就会打开表，执行器会根据表定义的引擎去使用这个引擎提供的接口完成流程。</li>
</ul>
<h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><blockquote>
<p> 关于存储引擎，这里明确提醒。不是三种也不是四种。而是多种因为随时可能出现新的引擎。</p>
</blockquote>
<ul>
<li>我们常用的就是<code>InnoDB</code>和<code>MyISAM</code>，其它的不常见就不做过多介绍。mysql现在默认的引擎是<code>InnoDB</code>所以主要也是了解<code>InnoDB</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前服务支持的存储引擎</span></span><br><span class="line">SHOW ENGINES;</span><br></pre></td></tr></table></figure>

<p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/mysql/SHOW_ENGINES.png"></p>
<a id="more"></a>

<h4 id="innodb"><a href="#innodb" class="headerlink" title="innodb"></a>innodb</h4><ul>
<li>插入缓冲（insert buffer),</li>
<li>二次写(double write),</li>
<li>自适应哈希索引(ahi),</li>
<li>预读(read ahead)</li>
<li>支持事务操作，具有事务 ACID 隔离特性，默认的隔离级别是<code>可重复读(repetable-read)</code>、通过MVCC（并发版本控制）来实现的。能够解决<code>脏读</code>和<code>不可重复读</code>的问题。</li>
<li>InnoDB 支持外键操作。</li>
<li>InnoDB 默认的锁粒度<code>行级锁</code>，并发性能比较好，会发生死锁的情况。</li>
<li>和 MyISAM 一样的是，InnoDB 存储引擎也有 <code>.frm文件存储表结构</code> 定义，但是不同的是，InnoDB 的表数据与索引数据是存储在一起的，都位于 B+ 数的叶子节点上，而 MyISAM 的表数据和索引数据是分开的。</li>
<li>InnoDB 有安全的日志文件，这个日志文件用于恢复因数据库崩溃或其他情况导致的数据丢失问题，保证数据的一致性。</li>
<li>InnoDB 和 MyISAM 支持的索引类型相同，但具体实现因为文件结构的不同有很大差异。</li>
<li>增删改查性能方面，如果执行大量的增删改操作，推荐使用 InnoDB 存储引擎，它在删除操作时是对行删除，不会重建表。</li>
</ul>
<h5 id="myisam与innodb"><a href="#myisam与innodb" class="headerlink" title="myisam与innodb"></a>myisam与innodb</h5><ul>
<li>InnoDB支持事物，而MyISAM不支持事物</li>
<li>InnoDB支持行级锁，而MyISAM支持表级锁</li>
<li>InnoDB支持MVCC, 而MyISAM不支持</li>
<li>InnoDB支持外键，而MyISAM不支持</li>
<li>InnoDB不支持全文索引，而MyISAM支持。</li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><ul>
<li>数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li>
</ul>
<h4 id="超键"><a href="#超键" class="headerlink" title="超键"></a>超键</h4><ul>
<li>在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li>
</ul>
<h4 id="候选键"><a href="#候选键" class="headerlink" title="候选键"></a>候选键</h4><ul>
<li>是最小超键，即没有冗余元素的超键。</li>
</ul>
<h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><ul>
<li>在一个表中存在的另一个表的主键称此表的外键。</li>
</ul>
<h4 id="为什么要使用自增列作为主键？"><a href="#为什么要使用自增列作为主键？" class="headerlink" title="为什么要使用自增列作为主键？"></a>为什么要使用自增列作为主键？</h4><blockquote>
<p>自增ID有序，会按顺序往最后插入，而UUID无序，随机生成，随机插入，会造成频繁页分裂，内存碎片化，大量随机IO</p>
</blockquote>
<ul>
<li><p>如果没有显示的指定主键，则InnoDB会选择一个不包含NULL值的唯一索引作为主键索引。如果不满足条件，InnoDB会选择内置6字节长度的ROWID作为隐含的聚集索引。</p>
</li>
<li><p>InnoDB数据记录本身存放主索引（B+Tree）的叶子结点上面，同一个叶子结点内的各条数据是按照主键顺序存放。因此每次插入数据的时候，mysql会根据其主键插入适当的位置，如果页达到装载因子条件，则开辟一个新的页。</p>
</li>
<li><p>使用非自增，每次插入的值都是几乎无序的，导致叶节点不够紧凑，频繁移动分叶造成大量碎片。增加维护工作。</p>
</li>
<li><p>InnoDB引擎的自增值，其实是<strong>保存在了内存</strong>里，并且到了MySQL 8.0版本后，才有了“自增值持久化”的能力。</p>
</li>
</ul>
<h4 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h4><blockquote>
<p>在了解索引之前，大概理解下mysql存储数据的大小划分<code>表空间 -&gt; 段 -&gt; 区 -&gt; 数据页</code> 。</p>
</blockquote>
<ul>
<li><p>索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构</p>
</li>
<li><p>索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。</p>
</li>
<li><p>索引优缺点</p>
<ol>
<li>索引加快数据库的检索速度。</li>
<li>索引降低了插入、删除、修改等维护任务的速度。</li>
<li>唯一索引可以确保每一行数据的唯一性。</li>
<li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。</li>
<li>索引需要占物理和数据空间。</li>
</ol>
</li>
</ul>
<h5 id="表空间、段、区、数据页"><a href="#表空间、段、区、数据页" class="headerlink" title="表空间、段、区、数据页"></a>表空间、段、区、数据页</h5><blockquote>
<p>记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。因此在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page）。</p>
</blockquote>
<ul>
<li>一个页中可以存储多个行记录（Row），同时在数据库中，还存在着区（Extent）、段（Segment）和表空间（Tablespace）。行、页、区、段、表空间的关系如下图所示：</li>
</ul>
<p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/MysqlInnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"></p>
<h5 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h5><ul>
<li><p>天生排序</p>
</li>
<li><p>快速查找</p>
</li>
</ul>
<h5 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h5><ul>
<li>占用空间</li>
<li>降低更新表的速度。</li>
</ul>
<h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ul>
<li><p>小表使用全表扫描更快，中大表才使用索引。超级大表索引基本无效。</p>
</li>
<li><p>索引实现，分成 2 种：聚集索引和辅助索引（也叫二级索引或者非聚集索引）</p>
</li>
<li><p>功能区分，分为 6 种：普通索引，唯一索引，主键索引，复合索引，外键索引，全文索引。</p>
<p>1、普通索引：最基本的索引，没有任何约束。<br>2、唯一索引：与普通索引类似，但具有唯一性约束。<br>3、主键索引：<strong>特殊的唯一索引，不允许有空值</strong>。<br>4、复合索引：将多个列组合在一起创建索引，可以覆盖多个列。<br>5、外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。<br>6、全文索引：MySQL 自带的全文索引只能用于 InnoDB、MyISAM ，并且只能对英文进行全文检索，一般使用全文索引引擎（ES，Solr）。</p>
</li>
<li><p><code>注意：主键就是唯一索引，但是唯一索引不一定是主键，唯一索引可以为空，但是空值只能有一个，主键不能为空。</code></p>
</li>
</ul>
<h4 id="常见索引类型"><a href="#常见索引类型" class="headerlink" title="常见索引类型"></a>常见索引类型</h4><blockquote>
<p>索引是存储在一张表中特定列上的<code>数据结构</code>，索引是在列上创建的。并且，索引是一种数据结构。</p>
</blockquote>
<h5 id="全局索引-FULLTEXT"><a href="#全局索引-FULLTEXT" class="headerlink" title="全局索引(FULLTEXT)"></a>全局索引(FULLTEXT)</h5><ul>
<li>全局索引，目前只有 MyISAM 引擎支持全局索引，它的出现是为了解决针对文本的模糊查询效率较低的问题。</li>
</ul>
<h5 id="哈希索引-HASH"><a href="#哈希索引-HASH" class="headerlink" title="哈希索引(HASH)"></a>哈希索引(HASH)</h5><ul>
<li>哈希索引是 MySQL 中用到的唯一 key-value 键值对的数据结构，很适合作为索引。HASH 索引具有一次定位的好处，不需要像树那样逐个节点查找，但是这种查找适合应用于查找单个键的情况，对于范围查找，HASH 索引的性能就会很低。</li>
</ul>
<h5 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h5><ul>
<li>B 就是 Balance 的意思，BTree 是一种平衡树，它有很多变种，最常见的就是 B+ Tree，它被 MySQL 广泛使用。</li>
</ul>
<h5 id="R-Tree索引"><a href="#R-Tree索引" class="headerlink" title="R-Tree索引"></a>R-Tree索引</h5><ul>
<li>R-Tree 在 MySQL 很少使用，仅支持 geometry 数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种，相对于 B-Tree 来说，R-Tree 的优势在于范围查找。</li>
</ul>
<h4 id="B-Tree与Hash索引的区别"><a href="#B-Tree与Hash索引的区别" class="headerlink" title="B+Tree与Hash索引的区别"></a>B+Tree与Hash索引的区别</h4><ol>
<li>B+Tree是一个平衡多叉树，从根节点到每个叶子节点点高度差值不超过1，同层级的节点互相有指针互相链接，是有序的。</li>
<li>Hash索引是采用一定的Hash算法，把健值换成哈希值，检索的时候不需要类似b+树从根节点逐渐查找，值需要一次哈希运算即可，是无序的。</li>
<li>Hash索引适合等值查询，哈希索引具有绝对优势（前提是：没有⼤量重复键值，如果⼤量重复键值时，哈希索引的效率很低，因为存在所谓的 哈希碰撞问题。不使用范围查询、也不支持索引完成排序。不支持联合索引最左匹配原则。通过列的基数很大也不建议使用Hash索引。</li>
</ol>
<h4 id="InnoDB存储引擎的B-树索引"><a href="#InnoDB存储引擎的B-树索引" class="headerlink" title="InnoDB存储引擎的B+树索引"></a>InnoDB存储引擎的B+树索引</h4><ul>
<li>每个索引都对应一棵B+树，B+树分为好多层，最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+树的叶子节点，所有目录项记录都存储在内节点。</li>
<li>InnoDB存储引擎会自动为主键（如果没有它会自动帮我们添加）建立聚簇索引，聚簇索引的叶子节点包含完整的用户记录。</li>
<li>我们可以为自己感兴趣的列建立二级索引，二级索引的叶子节点包含的用户记录由索引列 + 主键组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。</li>
<li>B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。</li>
<li>通过索引查找记录是从B+树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory（页目录），所以在这些页面中的查找非常快。</li>
<li>二者SELECT COUNT(*)哪个更快，为什么<ul>
<li>myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</li>
</ul>
</li>
</ul>
<h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><ul>
<li>两张表联合查询的时候表的编码集不一样会导致索引失效。</li>
<li>列类型是字符串，一定要在条件中将数据用<code>引号引用</code>，否则失效（隐式转换）</li>
<li>or语句前后未使用索引字段 ，字段A做了索引 WHERE A = 1 OR B = 2 这时候也不回走索引。</li>
<li>like未使用最左前缀，where A like “%China”。</li>
<li>在索引上使用函数 、!= 、&lt;&gt; 、not in 。</li>
<li>where a = b + 1 查询条件做运算</li>
<li>is null 、is not null</li>
</ul>
<h4 id="覆盖索引和回表"><a href="#覆盖索引和回表" class="headerlink" title="覆盖索引和回表"></a>覆盖索引和回表</h4><ul>
<li>覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。而要确定一个查询是否是覆盖索引，我们只需要explain sql语句看Extra的结果是否是“Using index”即可。</li>
</ul>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><blockquote>
<p>在根据索引查询过程中就根据查询条件过滤掉一些记录，减少最后的回表操作</p>
</blockquote>
<h4 id="使用索引查询一定能提高查询的性能吗？"><a href="#使用索引查询一定能提高查询的性能吗？" class="headerlink" title="使用索引查询一定能提高查询的性能吗？"></a>使用索引查询一定能提高查询的性能吗？</h4><blockquote>
<p>通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.</p>
</blockquote>
<ul>
<li>索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li>
<li>基于一个范围的检索,一般查询返回结果集小于表中记录数的30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><blockquote>
<p>事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</p>
</blockquote>
<h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><blockquote>
<p>一说到 MySQL 事务，你肯定能想起来四大特性：<code>原子性</code>、<code>一致性</code>、<code>隔离性</code>、<code>持久性</code>。</p>
<p>ACID模式是一组数据库设计原则强调的是，对于业务数据和关键任务应用重要的可靠性方面。MySQL包含诸如的组件<code>InnoDB</code>存储引擎与ACID模型紧密结合，因此数据不会损坏，并且不会因软件崩溃和硬件故障等特殊情况而导致结果失真。当您依赖符合ACID的功能时，您无需重新发明一致性检查和崩溃恢复机制。如果您有其他软件安全措施，超可靠硬件或可以容忍少量数据丢失或不一致的应用程序，您可以调整MySQL设置以交换一些ACID可靠性以获得更高的性能或吞吐量。</p>
</blockquote>
<h4 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h4><ul>
<li>原子性指的就是 MySQL 中的包含事务的操作要么<code>全部成功</code>、要么全部<code>失败回滚</code>，因此事务的操作如果成功就必须要全部应用到数据库，如果操作失败则不能对数据库有任何影响。</li>
</ul>
<h4 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性(Consistency)"></a>一致性(Consistency)</h4><ul>
<li>一致性指的是一个事务在执行前后其状态一致。比如 A 和 B 加起来的钱一共是 1000 元，那么不管 A 和 B 之间如何转账，转多少次，事务结束后两个用户的钱加起来还得是 1000，这就是事务的一致性。</li>
</ul>
<h4 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性(Durability)"></a>持久性(Durability)</h4><ul>
<li>持久性指的是一旦事务提交，那么发生的改变就是永久性的，即使数据库遇到特殊情况比如故障的时候也不会产生干扰。</li>
</ul>
<h4 id="隔离性-Isolation"><a href="#隔离性-Isolation" class="headerlink" title="隔离性(Isolation)"></a>隔离性(Isolation)</h4><ul>
<li><p>当多个事务同时进行时，就有可能出现<code>脏读(dirty read)</code>、<code>不可重复读(non-repeatable read)</code>、<code>幻读(phantom read)</code> 的情况，为了解决这些并发问题，提出了隔离性的概念。</p>
</li>
<li><p>重点说下隔离性它们分别是<code>读未提交(read uncommitted)</code>、<code>读已提交(read committed)</code>、<code>可重复读(repetable read)</code> 和 <code>串行化(serializable)</code>。下面分别来解释一下。</p>
</li>
<li><p><code>读未提交</code>：读未提交指的是一个事务在提交之前，它所做的修改就能够被其他事务所看到。</p>
</li>
<li><p><code>读已提交</code>：读已提交指的是一个事务在提交之后，它所做的变更才能够让其他事务看到。</p>
</li>
<li><p><code>可重复读</code>：可重复读指的是一个事务在执行的过程中，看到的数据是和启动时看到的数据是一致的。未提交的变更对其他事务不可见。</p>
</li>
<li><p><code>串行化</code>：顾名思义是对于同一行记录，<code>写</code>会加<code>写锁</code>，<code>读</code>会加<code>读锁</code>。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p>
</li>
</ul>
<h4 id="隔离性四个特性"><a href="#隔离性四个特性" class="headerlink" title="隔离性四个特性"></a>隔离性四个特性</h4><blockquote>
<p>最重要的就是一致性。而<strong>一致性</strong>由原子性，隔离性，持久性来保证。</p>
</blockquote>
<ul>
<li>原子性由 Undo log 保证。Undo Log 会保存每次变更之前的记录，从而在发生错误时进行回滚。</li>
<li>隔离性由 MVCC 和 Lock 保证。</li>
<li>持久性由 Redo Log 保证。每次真正修改数据之前，都会将记录写到 Redo Log 中，只有 Redo Log 写入成功，才会真正的写入到 B+ 树中，如果提交之前断电，就可以通过 Redo Log 恢复记录。</li>
</ul>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>值</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>读未提交（read-uncommitted）</td>
<td>1</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>读已提交（read-committed）</td>
<td>2</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读（repeatable-read）</td>
<td>3</td>
<td>否</td>
<td>否</td>
<td>是（x）</td>
</tr>
<tr>
<td>串行化（serializable）</td>
<td>4</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<blockquote>
<p>读已提交和可重复读实现原理就是MVCC Read View不同的生成时机。可重复读只在事务开始时生成一个Read View；读已提交每次执行前都会生成Read View。</p>
</blockquote>
<h5 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h5><blockquote>
<p>一个事物未提交的时候，它做的数据变更就能被其它事物看到。</p>
</blockquote>
<ul>
<li>原理：直接读取数据，不能解决任何并发问题</li>
</ul>
<h5 id="读提交"><a href="#读提交" class="headerlink" title="读提交"></a>读提交</h5><blockquote>
<p>一个事物提交后，它做的数据变更才能被其它事物看到。</p>
</blockquote>
<ul>
<li>原理：利用MVCC实现，每一句语句执行前都会生成Read View（一致性视图）</li>
</ul>
<h5 id="可重复读-（默认隔离级别）"><a href="#可重复读-（默认隔离级别）" class="headerlink" title="可重复读 （默认隔离级别）"></a>可重复读 （<strong>默认隔离级别</strong>）</h5><blockquote>
<p>一个事物执行的过程中看到的数据，总是跟这个事物在启动时候看的数据一致。只有事务开始时会创建Read View，之后事务里的其他查询都用这个Read View。解决了脏读、不可重复读，快照读（普通查询，读取历史数据）</p>
</blockquote>
<ul>
<li>原理：使用MVCC解决了幻读，当前读（读取最新提交数据）通过间隙锁解决幻读（lock in share mode、for update、update、detete、insert），间隙锁在可重复读下才生效。</li>
</ul>
<h5 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h5><blockquote>
<p>对同一行数据 <code>写</code>会加<code>写锁</code>,<code>读</code>会加<code>读锁</code>。当出现读写冲突的时候，必须按数据执行事务。</p>
</blockquote>
<ul>
<li>原理：使用锁，读加共享锁，写加排他锁，串行执行</li>
</ul>
<h4 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h4><h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><blockquote>
<p>一个事务正在对一条记录进行修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态。这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">时间</th>
<th align="left">事务A</th>
<th align="left">事务B</th>
</tr>
</thead>
<tbody><tr>
<td align="left">T1</td>
<td align="left">开启事务</td>
<td align="left">开启事务</td>
</tr>
<tr>
<td align="left">T2</td>
<td align="left">查询账户余额为1000</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T3</td>
<td align="left">充值500，余额修改为1500</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T4</td>
<td align="left"></td>
<td align="left">查询余额为<strong>1500</strong></td>
</tr>
<tr>
<td align="left">T5</td>
<td align="left">撤销事务，余额改回<strong>1000</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">T6</td>
<td align="left"></td>
<td align="left">汇入500，余额修改为<strong>2000</strong></td>
</tr>
<tr>
<td align="left">T7</td>
<td align="left"></td>
<td align="left">提交事务</td>
</tr>
</tbody></table>
<h5 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h5><blockquote>
<p>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了变更、或者某些记录已经被删除了。</p>
</blockquote>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>开启事务</td>
<td>开启事务</td>
</tr>
<tr>
<td>T2</td>
<td>select * from user where user_id=100 假设为小明的用户信息</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>将user_id=100的用户信息对应的年龄修改为<strong>18</strong></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>T5</td>
<td>再次查询发现用户的<strong>年龄变更</strong>了</td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td>…</td>
<td></td>
</tr>
<tr>
<td>T7</td>
<td>提交事务</td>
<td></td>
</tr>
</tbody></table>
<h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><blockquote>
<p>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其它事务插入了满足其查询条件的新数据。</p>
</blockquote>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>开启事务</td>
<td>开启事务</td>
</tr>
<tr>
<td>T2</td>
<td>select * from user where age=18 假设得到两条记录</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>向user表插入一条age=18的新记录</td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>T5</td>
<td><strong>再次查询得到三条记录</strong></td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td>..</td>
<td></td>
</tr>
<tr>
<td>T7</td>
<td>提交事务</td>
<td></td>
</tr>
</tbody></table>
<h5 id="幻读和不可重复读的区别"><a href="#幻读和不可重复读的区别" class="headerlink" title="幻读和不可重复读的区别"></a>幻读和不可重复读的区别</h5><ul>
<li>不可重复读的重点是修改：在同一事务中，相同的条件，第一次和第二次读到的数据不一致（中间有其它事务提交了修改）。</li>
<li>幻读的重点是新增或者删除：在同一事务中，相同的条件，第一次和第二次读到的记录数不一样（中间有其它事务提交了新增或者删除）。</li>
</ul>
<h3 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h3><blockquote>
<p>这很重要不管是面试工作，还是排查异常，出现问题的时候需要发现、定位、解决能力。也是开发人员必须掌握的一项能力。</p>
</blockquote>
<h4 id="理解下锁几种维度"><a href="#理解下锁几种维度" class="headerlink" title="理解下锁几种维度"></a>理解下锁几种维度</h4><h5 id="类型维度"><a href="#类型维度" class="headerlink" title="类型维度"></a>类型维度</h5><ul>
<li><p>共享锁（读锁 / S 锁）</p>
</li>
<li><p>排它锁（写锁 / X 锁）类型细分：</p>
<ul>
<li><p>意向共享锁</p>
</li>
<li><p>意向排他（互斥）锁</p>
</li>
</ul>
</li>
<li><p>悲观锁（使用锁，即 for update）</p>
</li>
<li><p>乐观锁（使用版本号字段，类似 CAS 机制，即用户自己控制。缺点：并发很高的时候，多了很多无用的重试）</p>
</li>
</ul>
<h5 id="锁的粒度（粒度维度）"><a href="#锁的粒度（粒度维度）" class="headerlink" title="锁的粒度（粒度维度）"></a>锁的粒度（粒度维度）</h5><ul>
<li>表锁</li>
<li>页锁（Mysql BerkeleyDB 引擎）</li>
<li>行锁（InnoDB）</li>
<li>全剧锁 （锁的是整个 <code>database</code>）</li>
</ul>
<h5 id="锁的算法（算法维度）"><a href="#锁的算法（算法维度）" class="headerlink" title="锁的算法（算法维度）"></a>锁的算法（算法维度）</h5><ul>
<li>Record Lock（单行记录）</li>
<li>Gap Lock（间隙锁，锁定一个范围，但不包含锁定记录）</li>
<li>Next-Key Lock（Record Lock + Gap Lock，锁定一个范围，并且锁定记录本身， MySql 防止幻读，就是使用此锁实现）</li>
</ul>
<h5 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h5><blockquote>
<p><strong>对单个记录加锁</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 对id=3的记录加S型Record Lock S锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`usr_info`</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">## 对id=3的记录加S型Record Lock x锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`usr_info`</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<h5 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h5><blockquote>
<p><strong>锁住记录前面的间隙，不允许插入记录</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##不允许别的事务在id=3的记录前面的间隙插入新记录，即id值在(1, 3)这个区间内的记录是不允许立即插入的。直到加间隙锁的事务提交后，id值在(1, 3)这个区间中的记录才可以被提交。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`usr_info`</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt; <span class="number">3</span> <span class="keyword">AND</span> <span class="keyword">id</span> &gt; <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<h5 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h5><blockquote>
<p><strong>同时锁住数据和数据前面的间隙，即数据和数据前面的间隙都不允许插入记录</strong></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 对id=3的聚集索引记录加S型Record Lock</span></span><br><span class="line"><span class="comment">-- 对id&gt;1的所有聚集索引记录加S型Next-key Lock（包括Supremum伪记录）</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`usr_info`</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> &lt;= <span class="number">3</span> <span class="keyword">AND</span> <span class="keyword">id</span> &gt; <span class="number">1</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>未加索引的字段</li>
</ul>
<blockquote>
<p>存储引擎只能给表中所有的记录都加上锁。</p>
</blockquote>
<h5 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h5><blockquote>
<p>数据库通过锁机制来解决并发场景-共享锁（读锁）和排他锁（写锁）。读锁是不阻塞的，多个客户端可以在同一时刻读取同一个资源。写锁是排他的，并且会阻塞其他的读锁和写锁。简单提下乐观锁和悲观锁。</p>
</blockquote>
<ul>
<li><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p>
<ul>
<li><strong>表锁</strong>，锁定整张表，开销最小，但是会加剧锁竞争。</li>
<li><strong>行锁</strong>，锁定行级别，开销最大，但是可以最大程度的支持并发。</li>
<li>共享锁（多个事物共享）共享锁也叫读锁或 S 锁。</li>
<li>排它锁（单个事物占有）排它锁也独占锁、写锁或 X 锁</li>
</ul>
</li>
<li><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p>
<ul>
<li>不过通过数据库的版本机制实现，通过版本号字段或者时间戳字段来实现。</li>
</ul>
</li>
</ul>
<h4 id="InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？"><a href="#InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？" class="headerlink" title="InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？"></a>InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？</h4><blockquote>
<p>InnoDB是基于索引来完成行锁</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例:  --</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tab_with_index <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">-- for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列-- </span></span><br><span class="line"><span class="comment">-- 如果 id 不是索引键那么InnoDB将完成表锁,并发将无从谈起--</span></span><br></pre></td></tr></table></figure>

<h3 id="InnDb架构"><a href="#InnDb架构" class="headerlink" title="InnDb架构"></a>InnDb架构</h3><ul>
<li>这是官方文档中的架构图</li>
</ul>
<p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/mysql/innodb-architecture.png" alt="innodb-architecture"></p>
<h4 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h4><blockquote>
<p>在使用InnoDB的时候，索引都是以页的形式存在在<code>表空间</code>中的，本质上是存储在硬盘上的。设计<code>InnoDB</code>的大叔为了缓存磁盘中的页，在<code>MySQL</code>服务器启动的时候就向操作系统申请了一片连续的内存，他们给这片内存起了个名，叫做<code>Buffer Pool</code>（中文名是<code>缓冲池</code>）</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size &#x3D; 268435456</span><br><span class="line">-- 268435456的单位是字节，也就是我指定Buffer Pool的大小为256M。需要注意的是，Buffer Pool也不能太小。--</span><br></pre></td></tr></table></figure>

<h4 id="Mysql-log"><a href="#Mysql-log" class="headerlink" title="Mysql log"></a>Mysql log</h4><blockquote>
<p>日志是mysql中非常重要的组成部分，记录着数据库运行期间的各种状态信息。Mysql的日志主要包括<code>错误日志</code>、<code>查询日志</code>、<code>慢查询日志</code>、<code>事物日志</code>、二进制日志大类。</p>
</blockquote>
<ol>
<li><strong>错误日志</strong>：记录出错信息，也记录一些警告信息或者正确的信息。</li>
<li><strong>查询日志</strong>：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。</li>
<li><strong>慢查询日志</strong>：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。</li>
<li><strong>二进制日志</strong>：记录对数据库执行更改的所有操作。</li>
<li><strong>中继日志</strong>：中继日志也是二进制日志，用来给slave 库恢复</li>
<li><strong>事务日志</strong>：重做日志redo和回滚日志undo<ul>
<li>事务日志是通过redo和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的，当开始一个事务的时候，会记录该事务的lsn(log sequence number)号; 当事务执行时，会往InnoDB存储引擎的日志的日志缓存里面插入事务日志；当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”。</li>
</ul>
</li>
</ol>
<h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p><code>binlog</code>用于记录数据库执行的写入性操作（不包括查询）的信息、以二进制的信息保保存在磁盘中，<code>binlog</code>是Mysql的逻辑日志，又<code>server</code>层进行记录。使用任何的存储引擎都会进行记录。<code>binlog</code>是通过追加的方式写入，当文件达到一定大小值以后，会生成全新文件来保存日志。</p>
<ul>
<li><p>逻辑日志：记录sql语句的日志。</p>
</li>
<li><p>物理日志：<code>mysql innodb</code>数据是保存在数据页中，物理记录的就是数据页变更。</p>
</li>
<li><p>主从复制：Master端开启<code>binlog</code>，然后将<code>binlog</code>发送到<code>Slave</code>端，<code>Slave</code>端通过重放<code>binlog</code>达到数据一致。</p>
</li>
<li><p>数据恢复：通过<code>mysqlbinlog</code>工具来恢复数据库。</p>
</li>
</ul>
<h5 id="刷盘机制"><a href="#刷盘机制" class="headerlink" title="刷盘机制"></a>刷盘机制</h5><blockquote>
<p><code>Innodb下只有在事物提交的情况下才会记录binlog</code>，此时记录还在内存中。mysql通过<code>sync_binlog</code>参数控制<code>binlog</code>刷盘时机。取值范围0-n</p>
</blockquote>
<ul>
<li>0：不去强制要求，由系统自行判断何时写入磁盘；</li>
<li>1：每次 <code>commit</code> 的时候都要将 <code>binlog</code> 写入磁盘；</li>
<li>N：每N个事务，才会将 <code>binlog</code> 写入磁盘。</li>
</ul>
<h5 id="binlog日志格式"><a href="#binlog日志格式" class="headerlink" title="binlog日志格式"></a>binlog日志格式</h5><blockquote>
<p>在 <code>MySQL 5.7.7</code> 之前，默认的格式是 <code>STATEMENT</code> ， <code>MySQL 5.7.7</code> 之后，默认值是 <code>ROW</code>。日志格式通过 <code>binlog-format</code> 指定。</p>
</blockquote>
<ul>
<li><code>STATMENT</code>：基于<code>SQL</code> 语句的复制( <code>statement-based replication, SBR</code> )，每一条会修改数据的sql语句会记录到<code>binlog</code> 中  。</li>
<li><ul>
<li>优点：不需要记录每一行的变化，减少了 binlog 日志量，节约了 IO  , 从而提高了性能；</li>
<li>缺点：在某些情况下会导致主从数据不一致，比如执行sysdate() 、  slepp()  等 。</li>
</ul>
</li>
<li><code>ROW</code>：基于行的复制(<code>row-based replication, RBR</code> )，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了 。</li>
<li><ul>
<li>优点：不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题 ；</li>
<li>缺点：会产生大量的日志，尤其是<code>alter table</code> 的时候会让日志暴涨</li>
</ul>
</li>
<li><code>MIXED</code>：基于<code>STATMENT</code> 和 <code>ROW</code> 两种模式的混合复制(<code>mixed-based replication, MBR</code> )，一般的复制使用<code>STATEMENT</code> 模式保存 <code>binlog</code> ，对于 <code>STATEMENT</code> 模式无法复制的操作使用 <code>ROW</code> 模式保存 <code>binlog</code></li>
</ul>
<h5 id="2PC两阶段提交"><a href="#2PC两阶段提交" class="headerlink" title="2PC两阶段提交"></a>2PC两阶段提交</h5><blockquote>
<p>mysql中在server层级别有个binlog日志，归档日志，用于备份，主从同步复制，如果采用一主多从架构，主备切换，那就必须用到binlog进行主从同步。</p>
</blockquote>
<ul>
<li><p>事务提交就必须保证redolog与binlog的一致性，一般情况没有开启binlog日志，事务提交不会两阶段提交，若需要主从同步就必须开启binlog使用两阶段提交保证数据一致性。</p>
</li>
<li><p><strong>Prepare 阶段</strong>：InnoDB 将回滚段undolog设置为 prepare 状态；将 redolog 写文件并刷盘；先写redolog，事务进入prepare状态）</p>
</li>
<li><p><strong>Commit 阶段</strong>：Binlog 写入文件；binlog 刷盘；InnoDB commit；</p>
</li>
</ul>
<h4 id="redo-Log"><a href="#redo-Log" class="headerlink" title="redo Log"></a>redo Log</h4><blockquote>
<p>事务的四大特性里面有一个是 <strong>持久性</strong> ，具体来说就是<strong>只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态</strong> 。</p>
</blockquote>
<h5 id="保持一致性"><a href="#保持一致性" class="headerlink" title="保持一致性"></a>保持一致性</h5><blockquote>
<p>最简单的做法是在每次事务提交的时候，将该事务涉及修改的数据页全部刷新到磁盘中。但是这么做会有严重的性能问题，主要体现在两个方面：</p>
</blockquote>
<ol>
<li>因为 <code>Innodb</code> 是以 <code>页</code> 为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这个时候将完整的数据页刷到磁盘的话，太浪费资源了！</li>
<li>一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机IO写入性能太差！</li>
</ol>
<ul>
<li>因此 <code>mysql</code> 设计了 <code>redo log</code> ， <strong>具体来说就是只记录事务对数据页做了哪些修改</strong>，这样就能完美地解决性能问题了(相对而言文件更小并且是顺序IO)。</li>
</ul>
<blockquote>
<p><code>redo log</code> 包含两个部分，一个是内存中的日志缓冲 <code>redo log buffer</code> , 另一个是磁盘上的日志文件<code>redo logfile</code> </p>
</blockquote>
<ol>
<li>mysql 每执行一条<code>DML</code>语句，先将记录写入<code>redo log buffer</code>,后续某个时间点再一次性将多个操作写到 <code>redo log file</code>。这种先写日志，再写磁盘的技术就是<code>Mysql</code>里经常说到的<code>WAL (write-ahead Logging)</code>技术。</li>
<li>在计算机中，用户的空间<code>user space</code>下的缓冲区一般情况下是不能直接写入磁盘，中间需要经过系统内核空间<code> kerne space</code>缓冲区<code>Os Buffer</code>，因此<code>redo log buffer</code>写入<code>redo logfile</code>实际上是写入<code>Os Buffer</code>，然后再通过系统调用<code>fsunc()</code>将数据刷入<code>redo log file</code></li>
</ol>
<blockquote>
<p>mysql 支持三种将<code>redo log buffer</code>写入<code>redo log file</code>的机制，可以通过<code>innodb_flush_log_at_trx_commit</code>配置</p>
</blockquote>
<table>
<thead>
<tr>
<th>innodb_flush_log_at_trx_commit</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>事物提交不将<code>redo log buffer</code>只日志写入<code>os buffer</code>，而是每秒写入<code>os buffer</code>并调用<code>fsync()</code>写入<code>redo log file</code>中，也就是说设置0时，大概每秒刷新一次进入磁盘，如果系统出现故障，会丢失1秒的数据。</td>
</tr>
<tr>
<td>1</td>
<td>每次提交事物都将<code>redo log buufer</code> 写入 <code>os buffer</code>并调用<code>fsync()</code>。这种情况系统故障也不会丢失数据，<code>io</code>性能太差。</td>
</tr>
<tr>
<td>2</td>
<td>每次提交事物都将<code>redo log buufer</code> 写入 <code>os buffer</code>，每秒调用<code>fsync()</code>将<code>os buffer</code>中日志写入<code>redo log file</code></td>
</tr>
</tbody></table>
<h4 id="undo-Log"><a href="#undo-Log" class="headerlink" title="undo Log"></a>undo Log</h4><blockquote>
<p>数据库事务四大特性中有一个是 <strong>原子性</strong> ，具体来说就是 <strong>原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况</strong>。</p>
</blockquote>
<ul>
<li><strong>原子性</strong> 底层就是通过 <code>undo log</code> 实现的。<code>undo log</code>主要记录了数据的逻辑变化，比如一条 <code>INSERT</code> 语句，对应一条<code>DELETE</code> 的 <code>undo log</code> ，对于每个 <code>UPDATE</code> 语句，对应一条相反的 <code>UPDATE</code> 的 <code>undo log</code> ，这样在发生错误时，就能回滚到事务之前的数据状态。</li>
<li><code>undo log</code> 也是 <code>MVCC</code>(多版本并发控制)实现的关键。</li>
</ul>
<h4 id="binlog的几种日志录入格式以及区别"><a href="#binlog的几种日志录入格式以及区别" class="headerlink" title="binlog的几种日志录入格式以及区别"></a>binlog的几种日志录入格式以及区别</h4><h4 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h4><blockquote>
<p>每一条会修改数据的sql都会记录在binlog中。</p>
</blockquote>
<ul>
<li><p><strong>优点</strong>：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。(相比row能节约多少性能 与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入row格式所产生的日志量还小于Statement产生的日志量，但是考虑到如果带条 件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所 产生的日志量会增加多少，以及带来的IO性能问题。)</p>
</li>
<li><p><strong>缺点</strong>：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的 一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。另外mysql 的复制,像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题).</p>
</li>
</ul>
<p><strong>使用以下函数的语句也无法被复制</strong>：</p>
<ul>
<li>LOAD_FILE()</li>
<li>UUID()</li>
<li>USER()</li>
<li>FOUND_ROWS()</li>
<li>SYSDATE() (除非启动时启用了 –sysdate-is-now 选项)</li>
</ul>
<p>同时在INSERT …SELECT 会产生比 RBR 更多的行级锁</p>
<h4 id="Row"><a href="#Row" class="headerlink" title="Row"></a>Row</h4><blockquote>
<p>不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p>
</blockquote>
<ul>
<li><strong>优点</strong>： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下 每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题</li>
<li><strong>缺点</strong>:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比 如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。</li>
<li><strong>Mixedlevel</strong>: 是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则 采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择 一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><blockquote>
<p>MySQL InnoDB存储引擎，实现的是基于多版本的并发控制协议——MVCC (Multi-Version Concurrency Control) </p>
<p>与MVCC相对的，是基于锁的并发控制，Lock-Based Concurrency Control </p>
</blockquote>
<h4 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h4><blockquote>
<p>InnoDB存储引擎，每一行记录都有两个隐藏列<strong>trx_id</strong>、<strong>roll_pointer</strong>，如果表中没有主键和非NULL唯一键时，则还会有第三个隐藏的主键列<strong>row_id</strong>。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">列名</th>
<th align="left">是否必须</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">row_id</td>
<td align="left">否</td>
<td align="left">单调递增的行ID，不是必需的，占用6个字节。</td>
</tr>
<tr>
<td align="left">trx_id</td>
<td align="left">是</td>
<td align="left">记录操作该数据事务的事务ID</td>
</tr>
<tr>
<td align="left">roll_pointer</td>
<td align="left">是</td>
<td align="left">这个隐藏列就相当于一个指针，指向回滚段的undo日志</td>
</tr>
</tbody></table>
<ul>
<li>MVCC最⼤的好处：读不加锁，读写不冲突。在读多写少的OLTP应⽤中，读写不冲突是⾮常重要的，极⼤的增加了系统的并发性 </li>
</ul>
<p>能，现阶段⼏乎所有的RDBMS，都⽀持了MVCC。 </p>
<ul>
<li><p>LBCC：：Lock-Based Concurrency Control，基于锁的并发控制 </p>
</li>
<li><p>MVCC：：Multi-Version Concurrency Control  基于多版本的并发控制协议。纯粹基于锁的并发机制并发量低，MVCC是在基于锁的并发控制上的改进，主要是在读操作上提⾼ 了并发量。 </p>
</li>
</ul>
<ul>
<li>在MVCC并发控制中，读操作可以分成两类<ul>
<li>快照读 (snapshot read))：读取的是记录的可⻅版本 (有可能是历史版本)，不⽤加锁（共享读锁s锁也不加，所以不会阻塞其他事务的写） 。</li>
<li>当前读 (current read)：读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。</li>
</ul>
</li>
</ul>
<h4 id="快照读与当前读区别"><a href="#快照读与当前读区别" class="headerlink" title="快照读与当前读区别"></a>快照读与当前读区别</h4><ul>
<li><p>快照读读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player_users <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure>

<p>当前读就是读取最新数据，而不是历史版本的数据。加锁的 SELECT，或者对数据进行增删改都会进行当前读，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里加的是读锁。 update/insert/delete语句</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player_users <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player_users <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="InnoDB的MVCC的机制"><a href="#InnoDB的MVCC的机制" class="headerlink" title="InnoDB的MVCC的机制"></a>InnoDB的MVCC的机制</h4><blockquote>
<p>​        MVCC 的英文全称是 Multiversion Concurrency Control，中文翻译过来就是多版本并发控制技术。从名字中也能看出来，MVCC 是通过数据行的多个版本管理来实现数据库的并发控制，简单来说它的思想就是保存数据的历史版本。这样我们就可以通过比较版本号决定数据是否显示出来（具体的规则后面会介绍到），读取数据的时候不需要加锁也可以保证事务的隔离效果。</p>
<p>​        事务版本号每开启一个事务，我们都会从数据库中获得一个事务 ID（也就是事务版本号），这个事务 ID 是自增长的，通过 ID 大小，我们就可以判断事务的时间顺序。</p>
<p>​        行记录的隐藏列InnoDB 的叶子段存储了数据页，数据页中保存了行记录，而在行记录中有一些重要的隐藏字段。</p>
</blockquote>
<ul>
<li>通过 MVCC 我们可以解决以下几个问题：</li>
</ul>
<ol>
<li>读写之间阻塞的问题，通过 MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。</li>
<li>降低了死锁的概率。这是因为 MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</li>
<li>解决一致性读的问题。一致性读也被称为快照读，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</li>
</ol>
<h4 id="MVVC如何查询记录"><a href="#MVVC如何查询记录" class="headerlink" title="MVVC如何查询记录"></a>MVVC如何查询记录</h4><blockquote>
<p>MVCC 的核心就是 Undo Log+ Read View，“MV”就是通过 Undo Log 来保存数据的历史版本，实现多版本的管理，“CC”是通过 Read View 来实现管理，通过 Read View 原则来决定数据是否显示。同时针对不同的隔离级别，Read View 的生成策略不同，也就实现了不同的隔离级别。</p>
</blockquote>
<ol>
<li>获取事务自己的版本号，即事务ID</li>
<li>获取Read View</li>
<li>查询得到的数据，然后Read View中的事务版本号进行比较。</li>
<li>如果不符合Read View的可见性规则， 即就需要Undo log中历史快照;</li>
<li>最后返回符合规则的数据</li>
</ol>
<h3 id="SQL语句的执行顺序"><a href="#SQL语句的执行顺序" class="headerlink" title="SQL语句的执行顺序"></a>SQL语句的执行顺序</h3><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png"></p>
<blockquote>
<p>我们在编写一个查询语句的时候</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">    &lt; select_list &gt;</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    &lt; left_table &gt; &lt; join_type &gt;</span><br><span class="line"><span class="keyword">JOIN</span> &lt; right_table &gt; <span class="keyword">ON</span> &lt; join_condition &gt;</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    &lt; where_condition &gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    &lt; group_by_list &gt;</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">    &lt; having_condition &gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    &lt; order_by_condition &gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt; limit_number &gt;</span><br></pre></td></tr></table></figure>

<h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><ul>
<li>首先，对 SELECT 语句执行查询时，对<code>FROM</code> 关键字两边的表执行连接，会形成<code>笛卡尔积</code>，这时候会产生一个<code>虚表VT1(virtual table)</code></li>
</ul>
<blockquote>
<p>首先先来解释一下什么是<code>笛卡尔积</code></p>
<p>现在我们有两个集合 A = {0,1} , B = {2,3,4}</p>
<p>那么，集合 A * B 得到的结果就是</p>
<p>A * B = {(0,2)、(1,2)、(0,3)、(1,3)、(0,4)、(1,4)};</p>
<p>B * A = {(2,0)、{2,1}、{3,0}、{3,1}、{4,0}、(4,1)};</p>
<p>上面 A * B 和 B * A 的结果就可以称为两个集合相乘的 <code>笛卡尔积</code></p>
<p>我们可以得出结论，A 集合和 B 集合相乘，包含了集合 A 中的元素和集合 B 中元素之和，也就是 A 元素的个数 * B 元素的个数</p>
</blockquote>
<h4 id="ON"><a href="#ON" class="headerlink" title="ON"></a>ON</h4><ul>
<li>然后对 FROM 连接的结果进行 ON 筛选，创建 VT2，把符合记录的条件存在 VT2 中。</li>
</ul>
<h4 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h4><p>第三步，如果是 <code>OUTER JOIN(left join、right join)</code> ，那么这一步就将添加外部行，如果是 left join 就把 ON 过滤条件的左表添加进来，如果是 right join ，就把右表添加进来，从而生成新的虚拟表 VT3。</p>
<h4 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h4><ul>
<li><p>第四步，是执行 WHERE 过滤器，对上一步生产的虚拟表引用 WHERE 筛选，生成虚拟表 VT4。</p>
</li>
<li><p>WHERE 和 ON 的区别</p>
<ul>
<li>如果有外部列，ON 针对过滤的是关联表，主表(保留表)会返回所有的列;</li>
<li>如果没有添加外部列，两者的效果是一样的;</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li>对主表的过滤应该使用 WHERE;</li>
<li>对于关联表，先条件查询后连接则用 ON，先连接后条件查询则用 WHERE;</li>
</ul>
</li>
</ul>
<h4 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h4><ul>
<li>根据 group by 字句中的列，会对 VT4 中的记录进行分组操作，产生虚拟机表 VT5。果应用了group by，那么后面的所有步骤都只能得到的 VT5 的列或者是聚合函数（count、sum、avg等）。</li>
</ul>
<h4 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h4><ul>
<li>紧跟着 GROUP BY 字句后面的是 HAVING，使用 HAVING 过滤，会把符合条件的放在 VT6</li>
</ul>
<h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h4><ul>
<li>第七步才会执行 SELECT 语句，将 VT6 中的结果按照 SELECT 进行刷选，生成 VT7</li>
</ul>
<h4 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h4><ul>
<li>在第八步中，会对 TV7 生成的记录进行去重操作，生成 VT8。事实上如果应用了 group by 子句那么 distinct 是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。</li>
</ul>
<h4 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h4><ul>
<li>应用 order by 子句。按照 order_by_condition 排序 VT8，此时返回的一个游标，而不是虚拟表。sql 是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。</li>
</ul>
<h5 id="ORDER-BY注意事项"><a href="#ORDER-BY注意事项" class="headerlink" title="ORDER BY注意事项"></a>ORDER BY注意事项</h5><ul>
<li><p>排序的列名：ORDER BY 后面可以有一个或多个列名，如果是多个列名进行排序，会按照后面第一个列先进行排序，当第一列的值相同的时候，再按照第二列进行排序，以此类推。</p>
</li>
<li><p>排序的顺序：ORDER BY 后面可以注明排序规则，ASC 代表递增排序，DESC 代表递减排序。如果没有注明排序规则，默认情况下是按照 ASC 递增排序。我们很容易理解 ORDER BY 对数值类型字段的排序规则，但如果排序字段类型为文本数据，就需要参考数据库的设置方式了，这样才能判断 A 是在 B 之前，还是在 B 之后。比如使用 MySQL 在创建字段的时候设置为 BINARY 属性，就代表区分大小写。</p>
</li>
<li><p>非选择列排序：ORDER BY 可以使用非选择列进行排序，所以即使在 SELECT 后面没有这个列名，你同样可以放到 ORDER BY 后面进行排序。</p>
</li>
<li><p>ORDER BY 的位置：ORDER BY 通常位于 SELECT 语句的最后一条子句，否则会报错。</p>
</li>
</ul>
<h3 id="查询优化-1"><a href="#查询优化-1" class="headerlink" title="查询优化"></a>查询优化</h3><ul>
<li><p>避免使用 select * 而是查询需要的字段，这样可以提升速度，以及减少网络传输的带宽压力。</p>
</li>
<li><p>尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，但 Join 语句并不会创建临时表，因此性能会更高。</p>
</li>
<li><p>尽量使用覆盖查询。通过创建联合主键的方式减少回表操作。</p>
</li>
<li><p>不要在列上进行运算操作</p>
</li>
<li><p>适当增加冗余字段，防止多度连表查询，通常不建议join超过三张表。</p>
</li>
<li><p>最小数据长度，一般说来数据库的表越小，那么它的查询速度就越快，因此为了提高表的效率</p>
</li>
<li><p>使用最简单数据类型，能使用 int 类型就不要使用 varchar 类型，因为 int 类型比 varchar 类型的查询效率更高。</p>
</li>
<li><p>尽量少定义 text 类型，text 类型的查询效率很低，如果必须要使用 text 定义字段，可以把此字段分离成子表，需要查询此字段时使用联合查询，这样可以提高主表的查询效率。</p>
</li>
<li><p>适当分表、分库策略，分表和分库方案也是我们经常说的垂直分隔（分表）和水平分隔（分库）。</p>
<p>分表是指当一张表中的字段更多时，可以尝试将一张大表拆分为多张子表，把使用比较高频的主信息放入主表中，其他的放入子表，这样我们大部分查询只需要查询字段更少的主表就可以完成了，从而有效的提高了查询的效率。</p>
<p>分库是指将一个数据库分为多个数据库。比如我们把一个数据库拆分为了多个数据库，一个主数据库用于写入和修改数据，其他的用于同步主数据并提供给客户端查询，这样就把一个库的读和写的压力，分摊给了多个库，从而提高了数据库整体的运行效率。</p>
</li>
</ul>
<h4 id="SQL优化explain"><a href="#SQL优化explain" class="headerlink" title="SQL优化explain"></a>SQL优化explain</h4><ul>
<li>explain出来的各种item的意义；</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select_type</span><br></pre></td></tr></table></figure>

<ul>
<li>表示查询中每个select子句的类型，有几种值：simple（表示简单的select，没有union和子查询），primary（有子查询，最外面的select查询就是primary），union（union中的第二个或随后的select查询，不依赖外部查询结果），dependent union（union中的第二个或随后的select查询，依赖外部查询结果）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type</span><br></pre></td></tr></table></figure>

<ul>
<li>表示MySQL在表中找到所需行的方式，又称“访问类型”，有几种值：system（表仅有一行（=系统表），这是const连接类型的一个特例），const（常量查询）, ref(非唯一索引访问，只有普通索引)，eq_ref（使用唯一索引或组件查询），all（全表查询），index（根据索引查询全表），range（范围查询）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">possible_keys</span><br></pre></td></tr></table></figure>

<ul>
<li>指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key</span><br></pre></td></tr></table></figure>

<ul>
<li>显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_len</span><br></pre></td></tr></table></figure>

<ul>
<li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref</span><br></pre></td></tr></table></figure>

<ul>
<li>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Extra</span><br></pre></td></tr></table></figure>

<ul>
<li><p>包含不适合在其他列中显示但十分重要的额外信息</p>
</li>
<li><p>profile的意义以及使用场景；</p>
</li>
</ul>
<blockquote>
<p>查询到 SQL 会执行多少时间, 并看出 CPU/Memory 使用量, 执行过程中 Systemlock, Table lock 花多少时间等等。</p>
</blockquote>
<h4 id="innodb的读写参数优化"><a href="#innodb的读写参数优化" class="headerlink" title="innodb的读写参数优化"></a>innodb的读写参数优化</h4><ul>
<li>读取参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global buffer pool以及 local buffer；</span><br></pre></td></tr></table></figure>

<ul>
<li>写入参数；</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit</span><br><span class="line"></span><br><span class="line">innodb_buffer_pool_size</span><br></pre></td></tr></table></figure>

<ul>
<li>与IO相关的参数；</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">innodb_write_io_threads = 8</span><br><span class="line"></span><br><span class="line">innodb_read_io_threads = 8</span><br><span class="line"></span><br><span class="line">innodb_thread_concurrency = 0</span><br></pre></td></tr></table></figure>

<h4 id="SQL-优化的经验"><a href="#SQL-优化的经验" class="headerlink" title="SQL 优化的经验"></a>SQL 优化的经验</h4><ul>
<li>查询语句无论是使用哪种判断条件 <strong>等于、小于、大于</strong>， <code>WHERE</code> 左侧的条件查询字段不要使用函数或者表达式</li>
<li>使用 <code>EXPLAIN</code> 命令优化你的 SELECT 查询，对于复杂、效率低的 sql 语句，我们通常是使用 explain sql 来分析这条 sql 语句，这样方便我们分析，进行优化。</li>
<li>当你的 SELECT 查询语句只需要使用一条记录时，要使用 <code>LIMIT 1</code></li>
<li>不要直接使用 <code>SELECT *</code>，而应该使用具体需要查询的表字段，因为使用 EXPLAIN 进行分析时，SELECT * 使用的是全表扫描，也就是 <code>type = all</code>。</li>
<li>为每一张表设置一个 ID 属性</li>
<li>避免在 <code>WHERE</code> 字句中对字段进行 <code>NULL</code> 判断</li>
<li>避免在 <code>WHERE</code> 中使用 <code>!=</code> 或 <code>&lt;&gt;</code> 操作符</li>
<li>使用 <code>BETWEEN AND</code> 替代 <code>IN</code></li>
<li>为搜索字段创建索引,大字段类型不要建立索引。</li>
<li>选择正确的存储引擎，InnoDB 、MyISAM 、MEMORY 等</li>
<li>使用 <code>LIKE %abc%</code> 不会走索引，而使用 <code>LIKE abc%</code> 会走索引</li>
<li>对于枚举类型的字段(即有固定罗列值的字段)，建议使用<code>ENUM</code>而不是<code>VARCHAR</code>，如性别、星期、类型、类别等</li>
<li>拆分大的 DELETE 或 INSERT 语句</li>
<li>选择合适的字段类型，选择标准是 <strong>尽可能小、尽可能定长、尽可能使用整数</strong>。</li>
<li>字段设计尽可能使用 <code>NOT NULL</code></li>
<li>进行水平切割或者垂直分割</li>
</ul>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><ul>
<li>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</li>
<li>只暴露部分字段给访问者，所以就建一个虚表，就是视图。</li>
<li>查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异。</li>
</ul>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><p>存储过程是一些预编译的SQL语句。</p>
<ul>
<li>更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。</li>
<li>存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全。</li>
</ul>
<h3 id="Mysql-Master-slave-的原理"><a href="#Mysql-Master-slave-的原理" class="headerlink" title="Mysql Master slave 的原理"></a>Mysql Master slave 的原理</h3><ul>
<li><p><strong>主</strong>：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</p>
</li>
<li><p><strong>从</strong>：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；</p>
</li>
<li><p><strong>从</strong>：sql执行线程——执行relay log中的语句；</p>
</li>
</ul>
<h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><h4 id="备份计划，mysqldump以及xtranbackup的实现原理"><a href="#备份计划，mysqldump以及xtranbackup的实现原理" class="headerlink" title="备份计划，mysqldump以及xtranbackup的实现原理"></a>备份计划，mysqldump以及xtranbackup的实现原理</h4><ul>
<li><p>备份计划</p>
<ul>
<li>这里每个公司都不一样</li>
</ul>
</li>
<li><p>备份恢复时间,这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</p>
<ul>
<li><p>20G的2分钟（mysqldump）</p>
</li>
<li><p>80G的30分钟(mysqldump)</p>
</li>
<li><p>111G的30分钟（mysqldump)</p>
</li>
<li><p>288G的3小时（xtra)</p>
</li>
<li><p>3T的4小时（xtra)</p>
</li>
<li><p>逻辑导入时间一般是备份时间的5倍以上</p>
</li>
</ul>
</li>
<li><p>xtrabackup实现原理</p>
<ul>
<li>在InnoDB内部会维护一个redo日志文件，我们也可以叫做事务日志文件。事务日志会存储每一个InnoDB表数据的记录修改。当InnoDB启动时，InnoDB会检查数据文件和事务日志，并执行两个步骤：它应用（前滚）已经提交的事务日志到数据文件，并将修改过但没有提交的数据进行回滚操作。</li>
</ul>
</li>
</ul>
<h4 id="mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert…-value-的话，怎么办？如果备份需要带上master的复制点信息怎么办？"><a href="#mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert…-value-的话，怎么办？如果备份需要带上master的复制点信息怎么办？" class="headerlink" title="mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert….value()的话，怎么办？如果备份需要带上master的复制点信息怎么办？"></a>mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert….value()的话，怎么办？如果备份需要带上master的复制点信息怎么办？</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--skip-extended-insert</span></span><br><span class="line"></span><br><span class="line">[root@helei-zhuanshu ~]<span class="comment"># mysqldump -uroot -p helei --skip-extended-insert</span></span><br><span class="line"></span><br><span class="line">Enter password:</span><br><span class="line"></span><br><span class="line">KEY `idx_c1` (`c1`),</span><br><span class="line"></span><br><span class="line">KEY `idx_c2` (`c2`)</span><br><span class="line"></span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=51 DEFAULT CHARSET=latin1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = @saved_cs_client */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Dumping data for table `helei`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> <span class="string">`helei`</span> WRITE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `helei` DISABLE KEYS */</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`helei`</span> <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">32</span>,<span class="number">37</span>,<span class="number">38</span>,<span class="string">'2016-10-18 06:19:24'</span>,<span class="string">'susususususususususususu'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`helei`</span> <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">37</span>,<span class="number">46</span>,<span class="number">21</span>,<span class="string">'2016-10-18 06:19:24'</span>,<span class="string">'susususususu'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`helei`</span> <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="number">21</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="string">'2016-10-18 06:19:24'</span>,<span class="string">'susu'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h3><h4 id="大表连表查询"><a href="#大表连表查询" class="headerlink" title="大表连表查询"></a>大表连表查询</h4><p>一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。</p>
<ul>
<li>1、如果A表TID是自增长,并且是连续的,B表的ID为索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a,b <span class="keyword">where</span> a.tid = b.id <span class="keyword">and</span> a.tid&gt;<span class="number">500000</span> <span class="keyword">limit</span> <span class="number">200</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> b , (<span class="keyword">select</span> tid <span class="keyword">from</span> a <span class="keyword">limit</span> <span class="number">50000</span>,<span class="number">200</span>) a <span class="keyword">where</span> b.id = a .tid;</span><br></pre></td></tr></table></figure>

<h4 id="数据库的三范式是什么"><a href="#数据库的三范式是什么" class="headerlink" title="数据库的三范式是什么"></a>数据库的三范式是什么</h4><ul>
<li>第一范式：列不可再分</li>
<li>第二范式：行可以唯一区分，主键约束</li>
<li>第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束</li>
<li>且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上。</li>
<li>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</li>
<li>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</li>
<li>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y</li>
</ul>
<h4 id="Mysql-大小写问题"><a href="#Mysql-大小写问题" class="headerlink" title="Mysql 大小写问题"></a>Mysql 大小写问题</h4><ul>
<li>表名、表别名、字段名、字段别名都小写。SQL保留字段、函数名、绑定变量名都大写。</li>
</ul>
<h4 id="DDL设计数据表的原则"><a href="#DDL设计数据表的原则" class="headerlink" title="DDL设计数据表的原则"></a>DDL设计数据表的原则</h4><ol>
<li>数据表越少越好</li>
<li>数据表中的字段越少越好</li>
<li>数据表中联合主键的字段越少越好</li>
<li>使用主键和外键越多越好</li>
</ol>
<h4 id="varchar与char的区别以及varchar-50-中的50代表的涵义"><a href="#varchar与char的区别以及varchar-50-中的50代表的涵义" class="headerlink" title="varchar与char的区别以及varchar(50)中的50代表的涵义"></a>varchar与char的区别以及varchar(50)中的50代表的涵义</h4><ul>
<li>varchar与char的区别<ul>
<li>CHAR和VARCHAR类型在存储和检索方面有所不同，CHAR是一种固定长度的类型，VARCHAR则是一种可变长度的类型。</li>
<li>CHAR列长度固定为创建表时声明的长度，长度值范围是1到255当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。</li>
</ul>
</li>
<li>varchar(50)中50的涵义<ul>
<li>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)</li>
</ul>
</li>
<li>int（20）中20的涵义<ul>
<li>是指显示字符的长度但要加参数的，最大为255，比如它是记录行数的id,插入10笔资料，它就显示00000000001 <del>~</del>00000000010，当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，它不会在前面加0</li>
<li>20表示最大显示宽度为20，但仍占4字节存储，存储范围不变。</li>
</ul>
</li>
<li>mysql为什么这么设计<ul>
<li>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样。</li>
</ul>
</li>
</ul>
<h4 id="表中有大字段X-例如：text类型-，且字段X不会经常更新，以读为为主。如何拆分"><a href="#表中有大字段X-例如：text类型-，且字段X不会经常更新，以读为为主。如何拆分" class="headerlink" title="表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主。如何拆分"></a>表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主。如何拆分</h4><blockquote>
<p>拆带来的问题：连接消耗 + 存储拆分空间；不拆可能带来的问题：查询性能；</p>
</blockquote>
<ul>
<li>1、如果能容忍拆分带来的空间问题,拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序IO,减少连接消耗,最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗</li>
<li>2、如果能容忍不拆分带来的查询性能损失的话:上面的方案在某个极致条件下肯定会出现问题,那么不拆就是最好的选择。</li>
</ul>
<h4 id="什么是临时表，何时删除临时表"><a href="#什么是临时表，何时删除临时表" class="headerlink" title="什么是临时表，何时删除临时表"></a>什么是临时表，何时删除临时表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在 MySQL 中，有三种类型的表</span><br><span class="line">一种是&#96;永久表&#96;，永久表就是创建以后用来长期保存数据的表</span><br><span class="line">一种是&#96;临时表&#96;，临时表也有两类，一种是和永久表一样，只保存临时数据，但是能够长久存在的；还有一种是临时创建的，SQL 语句执行完成就会删除。</span><br><span class="line">一种是&#96;虚表&#96;，虚表其实就是&#96;视图&#96;，数据可能会来自多张表的执行结果。</span><br></pre></td></tr></table></figure>

<ul>
<li>MySQL 会在下面这几种情况产生临时表<ul>
<li>使用 UNION 查询：UNION 有两种，一种是<code>UNION</code> ，一种是 <code>UNION ALL</code> ，它们都用于联合查询；区别是 使用 UNION 会去掉两个表中的重复数据，相当于对结果集做了一下<code>去重(distinct)</code>。使用 UNION ALL，则不会排重，返回所有的行。使用 UNION 查询会产生临时表。</li>
<li>使用 <code>TEMPTABLE 算法</code>或者是 UNION 查询中的视图。TEMPTABLE 算法是一种创建临时表的算法，它是将结果放置到临时表中，意味这要 MySQL 要先创建好一个临时表，然后将结果放到临时表中去，然后再使用这个临时表进行相应的查询。</li>
<li>ORDER BY 和 GROUP BY 的子句不一样时也会产生临时表。</li>
<li>DISTINCT 查询并且加上 ORDER BY 时；</li>
<li>SQL 用到 SQL_SMALL_RESULT 选项时；如果查询结果比较小的时候，可以加上 SQL_SMALL_RESULT 来优化，产生临时表</li>
<li>FROM 中的子查询；</li>
<li>EXPLAIN 查看执行计划结果的 Extra 列中，如果使用 <code>Using Temporary</code> 就表示会用到临时表。</li>
</ul>
</li>
</ul>
<h4 id="Exists与in"><a href="#Exists与in" class="headerlink" title="Exists与in"></a>Exists与in</h4><ul>
<li>将设A、B两表，走索引的情况下。根据A、B表的大小比较，如果A表大于B表那么IN的查询效率比EXISTS高。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A WHERE cc IN (SELECT cc FROM B)</span><br><span class="line"></span><br><span class="line">SELECT * FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc&#x3D;A.cc)</span><br></pre></td></tr></table></figure>

<h4 id="测试环境打开profiling"><a href="#测试环境打开profiling" class="headerlink" title="测试环境打开profiling"></a>测试环境打开profiling</h4><ul>
<li>首先我们需要看下 profiling 是否开启，开启它可以让 MySQL 收集在 SQL 执行时所使用的资源情况，命令如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@profiling;</span><br><span class="line"># profiling&#x3D;0 代表关闭，我们需要把 profiling 打开，即设置为 1：</span><br><span class="line">mysql&gt; set profiling&#x3D;1;</span><br><span class="line"># 然后我们执行一个 SQL 查询（你可以执行任何一个 SQL 查询）：</span><br><span class="line">mysql&gt; select * from wucai.heros;</span><br></pre></td></tr></table></figure>

<h4 id="去除重复行"><a href="#去除重复行" class="headerlink" title="去除重复行"></a>去除重复行</h4><ol>
<li>DISTINCT 需要放到所有列名的前面</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这么写会报错</span><br><span class="line">SELECT name, DISTINCT age FROM us</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>DISTINCT 其实是对后面所有列名的组合进行去重。</li>
</ol>
<h4 id="drop、delete与truncate"><a href="#drop、delete与truncate" class="headerlink" title="drop、delete与truncate"></a>drop、delete与truncate</h4><blockquote>
<p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别</p>
</blockquote>
<ul>
<li><p>delete和truncate只删除表的数据不删除表的结构</p>
</li>
<li><p>速度,一般来说: drop&gt; truncate &gt;delete</p>
</li>
<li><p>delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;</p>
</li>
<li><p>如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger。</p>
</li>
<li><p>不再需要一张表的时候，用drop</p>
</li>
<li><p>想删除部分数据行时候，用delete，并且带上where子句</p>
</li>
<li><p>保留表而删除所有数据的时候用truncate</p>
</li>
</ul>
<h4 id="in-not-in-exists-not-exists-它们有什么区别，效率如何？"><a href="#in-not-in-exists-not-exists-它们有什么区别，效率如何？" class="headerlink" title="in, not in , exists , not exists 它们有什么区别，效率如何？"></a>in, not in , exists , not exists 它们有什么区别，效率如何？</h4><ul>
<li><a href="https://segmentfault.com/a/1190000023825926" target="_blank" rel="noopener">参考文献</a></li>
</ul>
<h4 id="你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"><a href="#你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？" class="headerlink" title="你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"></a>你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？</h4><ul>
<li>主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等。</li>
</ul>
<h4 id="你们数据库是否支持emoji表情，如果不支持，如何操作？"><a href="#你们数据库是否支持emoji表情，如果不支持，如何操作？" class="headerlink" title="你们数据库是否支持emoji表情，如果不支持，如何操作？"></a>你们数据库是否支持emoji表情，如果不支持，如何操作？</h4><ul>
<li>如果是utf8字符集的话，需要升级至utf8_mb4方可支持。</li>
</ul>
<h4 id="Too-many-connections"><a href="#Too-many-connections" class="headerlink" title="Too many connections"></a>Too many connections</h4><blockquote>
<p>连接数超出 Mysql 的最大连接限制</p>
</blockquote>
<ul>
<li><p>解决方法：</p>
</li>
<li><ul>
<li>1、在 my.cnf 配置文件里面增加连接数，然后重启 MySQL 服务。max_connections = 10000</li>
<li>2、临时修改最大连接数，重启后不生效。需要在 my.cnf 里面修改配置文件，下次重启生效。</li>
</ul>
</li>
</ul>
<h4 id="MySQL数据库cpu飙升到100-的话怎么处理？"><a href="#MySQL数据库cpu飙升到100-的话怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到100%的话怎么处理？"></a>MySQL数据库cpu飙升到100%的话怎么处理？</h4><ul>
<li>列出所有进程 show processlist,观察所有进程 ,多秒没有状态变化的(干掉)</li>
<li>查看超时日志或者错误日志 (一般会是查询以及大批量的插入会导致cpu与i/o上涨,当然不排除网络状态突然断了,导致一个请求服务器只接受到一半，比如where子句或分页子句没有发送,,当然的一次被坑经历)。</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://mp.weixin.qq.com/s/lnLSOPQkjTkr957ds_4ZPA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/lnLSOPQkjTkr957ds_4ZPA</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>胖枫叶
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://z201.github.io/2019/01/01/%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-MySQL/" title="查缺补漏-MySQL">https://z201.github.io/2019/01/01/查缺补漏-MySQL/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Mysql/" rel="tag"># Mysql</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/01/01/%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-JavaCore/" rel="prev" title="查缺补漏-JavaCore">
      <i class="fa fa-chevron-left"></i> 查缺补漏-JavaCore
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/01/01/%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-Spring/" rel="next" title="查缺补漏-Spring">
      查缺补漏-Spring <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql基础架构图"><span class="nav-number">1.</span> <span class="nav-text">Mysql基础架构图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单介绍上图相关模块功能"><span class="nav-number">1.1.</span> <span class="nav-text">简单介绍上图相关模块功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#连接器"><span class="nav-number">1.2.</span> <span class="nav-text">连接器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#半双工"><span class="nav-number">1.2.1.</span> <span class="nav-text">半双工</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#长连接与短连接"><span class="nav-number">1.2.2.</span> <span class="nav-text">长连接与短连接</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询缓存"><span class="nav-number">1.3.</span> <span class="nav-text">查询缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#语法解析"><span class="nav-number">1.4.</span> <span class="nav-text">语法解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查询优化"><span class="nav-number">1.5.</span> <span class="nav-text">查询优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#执行器"><span class="nav-number">1.6.</span> <span class="nav-text">执行器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#存储引擎"><span class="nav-number">1.7.</span> <span class="nav-text">存储引擎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#innodb"><span class="nav-number">1.8.</span> <span class="nav-text">innodb</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#myisam与innodb"><span class="nav-number">1.8.1.</span> <span class="nav-text">myisam与innodb</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引"><span class="nav-number">2.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主键"><span class="nav-number">2.1.</span> <span class="nav-text">主键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#超键"><span class="nav-number">2.2.</span> <span class="nav-text">超键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#候选键"><span class="nav-number">2.3.</span> <span class="nav-text">候选键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外键"><span class="nav-number">2.4.</span> <span class="nav-text">外键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要使用自增列作为主键？"><span class="nav-number">2.5.</span> <span class="nav-text">为什么要使用自增列作为主键？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引是什么"><span class="nav-number">2.6.</span> <span class="nav-text">索引是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#表空间、段、区、数据页"><span class="nav-number">2.6.1.</span> <span class="nav-text">表空间、段、区、数据页</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#索引的优点"><span class="nav-number">2.6.2.</span> <span class="nav-text">索引的优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#索引的缺点"><span class="nav-number">2.6.3.</span> <span class="nav-text">索引的缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#注意点"><span class="nav-number">2.6.4.</span> <span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见索引类型"><span class="nav-number">2.7.</span> <span class="nav-text">常见索引类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#全局索引-FULLTEXT"><span class="nav-number">2.7.1.</span> <span class="nav-text">全局索引(FULLTEXT)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#哈希索引-HASH"><span class="nav-number">2.7.2.</span> <span class="nav-text">哈希索引(HASH)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#B-Tree索引"><span class="nav-number">2.7.3.</span> <span class="nav-text">B-Tree索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#R-Tree索引"><span class="nav-number">2.7.4.</span> <span class="nav-text">R-Tree索引</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-Tree与Hash索引的区别"><span class="nav-number">2.8.</span> <span class="nav-text">B+Tree与Hash索引的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB存储引擎的B-树索引"><span class="nav-number">2.9.</span> <span class="nav-text">InnoDB存储引擎的B+树索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引失效"><span class="nav-number">2.10.</span> <span class="nav-text">索引失效</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#覆盖索引和回表"><span class="nav-number">2.11.</span> <span class="nav-text">覆盖索引和回表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引下推"><span class="nav-number">2.12.</span> <span class="nav-text">索引下推</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用索引查询一定能提高查询的性能吗？"><span class="nav-number">2.13.</span> <span class="nav-text">使用索引查询一定能提高查询的性能吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务"><span class="nav-number">3.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ACID"><span class="nav-number">3.1.</span> <span class="nav-text">ACID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原子性-Atomicity"><span class="nav-number">3.2.</span> <span class="nav-text">原子性(Atomicity)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一致性-Consistency"><span class="nav-number">3.3.</span> <span class="nav-text">一致性(Consistency)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#持久性-Durability"><span class="nav-number">3.4.</span> <span class="nav-text">持久性(Durability)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隔离性-Isolation"><span class="nav-number">3.5.</span> <span class="nav-text">隔离性(Isolation)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隔离性四个特性"><span class="nav-number">3.6.</span> <span class="nav-text">隔离性四个特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#读未提交"><span class="nav-number">3.6.1.</span> <span class="nav-text">读未提交</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#读提交"><span class="nav-number">3.6.2.</span> <span class="nav-text">读提交</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#可重复读-（默认隔离级别）"><span class="nav-number">3.6.3.</span> <span class="nav-text">可重复读 （默认隔离级别）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#串行化"><span class="nav-number">3.6.4.</span> <span class="nav-text">串行化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发事务的问题"><span class="nav-number">3.7.</span> <span class="nav-text">并发事务的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#脏读"><span class="nav-number">3.7.1.</span> <span class="nav-text">脏读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#不可重复读"><span class="nav-number">3.7.2.</span> <span class="nav-text">不可重复读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#幻读"><span class="nav-number">3.7.3.</span> <span class="nav-text">幻读</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#幻读和不可重复读的区别"><span class="nav-number">3.7.4.</span> <span class="nav-text">幻读和不可重复读的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LOCK"><span class="nav-number">4.</span> <span class="nav-text">LOCK</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#理解下锁几种维度"><span class="nav-number">4.1.</span> <span class="nav-text">理解下锁几种维度</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#类型维度"><span class="nav-number">4.1.1.</span> <span class="nav-text">类型维度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#锁的粒度（粒度维度）"><span class="nav-number">4.1.2.</span> <span class="nav-text">锁的粒度（粒度维度）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#锁的算法（算法维度）"><span class="nav-number">4.1.3.</span> <span class="nav-text">锁的算法（算法维度）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Record-Lock"><span class="nav-number">4.1.4.</span> <span class="nav-text">Record Lock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Gap-Lock"><span class="nav-number">4.1.5.</span> <span class="nav-text">Gap Lock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Next-Key-Lock"><span class="nav-number">4.1.6.</span> <span class="nav-text">Next-Key Lock</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#乐观锁与悲观锁"><span class="nav-number">4.1.7.</span> <span class="nav-text">乐观锁与悲观锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？"><span class="nav-number">4.2.</span> <span class="nav-text">InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnDb架构"><span class="nav-number">5.</span> <span class="nav-text">InnDb架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Buffer-Pool"><span class="nav-number">5.1.</span> <span class="nav-text">Buffer Pool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mysql-log"><span class="nav-number">5.2.</span> <span class="nav-text">Mysql log</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#binlog"><span class="nav-number">5.3.</span> <span class="nav-text">binlog</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#刷盘机制"><span class="nav-number">5.3.1.</span> <span class="nav-text">刷盘机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#binlog日志格式"><span class="nav-number">5.3.2.</span> <span class="nav-text">binlog日志格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2PC两阶段提交"><span class="nav-number">5.3.3.</span> <span class="nav-text">2PC两阶段提交</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redo-Log"><span class="nav-number">5.4.</span> <span class="nav-text">redo Log</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#保持一致性"><span class="nav-number">5.4.1.</span> <span class="nav-text">保持一致性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#undo-Log"><span class="nav-number">5.5.</span> <span class="nav-text">undo Log</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#binlog的几种日志录入格式以及区别"><span class="nav-number">5.6.</span> <span class="nav-text">binlog的几种日志录入格式以及区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Statement"><span class="nav-number">5.7.</span> <span class="nav-text">Statement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Row"><span class="nav-number">5.8.</span> <span class="nav-text">Row</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVCC"><span class="nav-number">6.</span> <span class="nav-text">MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#隐藏字段"><span class="nav-number">6.1.</span> <span class="nav-text">隐藏字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快照读与当前读区别"><span class="nav-number">6.2.</span> <span class="nav-text">快照读与当前读区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB的MVCC的机制"><span class="nav-number">6.3.</span> <span class="nav-text">InnoDB的MVCC的机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVVC如何查询记录"><span class="nav-number">6.4.</span> <span class="nav-text">MVVC如何查询记录</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL语句的执行顺序"><span class="nav-number">7.</span> <span class="nav-text">SQL语句的执行顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FROM"><span class="nav-number">7.1.</span> <span class="nav-text">FROM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ON"><span class="nav-number">7.2.</span> <span class="nav-text">ON</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JOIN"><span class="nav-number">7.3.</span> <span class="nav-text">JOIN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WHERE"><span class="nav-number">7.4.</span> <span class="nav-text">WHERE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GROUP-BY"><span class="nav-number">7.5.</span> <span class="nav-text">GROUP BY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HAVING"><span class="nav-number">7.6.</span> <span class="nav-text">HAVING</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SELECT"><span class="nav-number">7.7.</span> <span class="nav-text">SELECT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DISTINCT"><span class="nav-number">7.8.</span> <span class="nav-text">DISTINCT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ORDER-BY"><span class="nav-number">7.9.</span> <span class="nav-text">ORDER BY</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ORDER-BY注意事项"><span class="nav-number">7.9.1.</span> <span class="nav-text">ORDER BY注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查询优化-1"><span class="nav-number">8.</span> <span class="nav-text">查询优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL优化explain"><span class="nav-number">8.1.</span> <span class="nav-text">SQL优化explain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#innodb的读写参数优化"><span class="nav-number">8.2.</span> <span class="nav-text">innodb的读写参数优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL-优化的经验"><span class="nav-number">8.3.</span> <span class="nav-text">SQL 优化的经验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#视图"><span class="nav-number">9.</span> <span class="nav-text">视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储过程"><span class="nav-number">10.</span> <span class="nav-text">存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql-Master-slave-的原理"><span class="nav-number">11.</span> <span class="nav-text">Mysql Master slave 的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#备份"><span class="nav-number">12.</span> <span class="nav-text">备份</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#备份计划，mysqldump以及xtranbackup的实现原理"><span class="nav-number">12.1.</span> <span class="nav-text">备份计划，mysqldump以及xtranbackup的实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert…-value-的话，怎么办？如果备份需要带上master的复制点信息怎么办？"><span class="nav-number">12.2.</span> <span class="nav-text">mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert….value()的话，怎么办？如果备份需要带上master的复制点信息怎么办？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开放性问题"><span class="nav-number">13.</span> <span class="nav-text">开放性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#大表连表查询"><span class="nav-number">13.1.</span> <span class="nav-text">大表连表查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库的三范式是什么"><span class="nav-number">13.2.</span> <span class="nav-text">数据库的三范式是什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mysql-大小写问题"><span class="nav-number">13.3.</span> <span class="nav-text">Mysql 大小写问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DDL设计数据表的原则"><span class="nav-number">13.4.</span> <span class="nav-text">DDL设计数据表的原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#varchar与char的区别以及varchar-50-中的50代表的涵义"><span class="nav-number">13.5.</span> <span class="nav-text">varchar与char的区别以及varchar(50)中的50代表的涵义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#表中有大字段X-例如：text类型-，且字段X不会经常更新，以读为为主。如何拆分"><span class="nav-number">13.6.</span> <span class="nav-text">表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主。如何拆分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是临时表，何时删除临时表"><span class="nav-number">13.7.</span> <span class="nav-text">什么是临时表，何时删除临时表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exists与in"><span class="nav-number">13.8.</span> <span class="nav-text">Exists与in</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#测试环境打开profiling"><span class="nav-number">13.9.</span> <span class="nav-text">测试环境打开profiling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#去除重复行"><span class="nav-number">13.10.</span> <span class="nav-text">去除重复行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#drop、delete与truncate"><span class="nav-number">13.11.</span> <span class="nav-text">drop、delete与truncate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#in-not-in-exists-not-exists-它们有什么区别，效率如何？"><span class="nav-number">13.12.</span> <span class="nav-text">in, not in , exists , not exists 它们有什么区别，效率如何？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"><span class="nav-number">13.13.</span> <span class="nav-text">你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#你们数据库是否支持emoji表情，如果不支持，如何操作？"><span class="nav-number">13.14.</span> <span class="nav-text">你们数据库是否支持emoji表情，如果不支持，如何操作？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Too-many-connections"><span class="nav-number">13.15.</span> <span class="nav-text">Too many connections</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL数据库cpu飙升到100-的话怎么处理？"><span class="nav-number">13.16.</span> <span class="nav-text">MySQL数据库cpu飙升到100%的话怎么处理？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文献"><span class="nav-number"></span> <span class="nav-text">参考文献</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="胖枫叶"
      src="/images/avatar-min.jpg">
  <p class="site-author-name" itemprop="name">胖枫叶</p>
  <div class="site-description" itemprop="description">多听、多看、少说、多做。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">90</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">92</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/z201" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;z201" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:int_java_se@@163.com" title="E-Mail → mailto:int_java_se@@163.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.journaldev.com/" title="https:&#x2F;&#x2F;www.journaldev.com&#x2F;" rel="noopener" target="_blank">journaldev</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.geeksforgeeks.org/" title="https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;" rel="noopener" target="_blank">geeksforgeeks</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://redisdoc.com/index.html" title="http:&#x2F;&#x2F;redisdoc.com&#x2F;index.html" rel="noopener" target="_blank">redisdoc</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.sczyh30.com/" title="http:&#x2F;&#x2F;www.sczyh30.com&#x2F;" rel="noopener" target="_blank">浮生若梦</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://objcoding.com/" title="https:&#x2F;&#x2F;objcoding.com&#x2F;" rel="noopener" target="_blank">后端进阶</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://spring.hhui.top/spring-blog/" title="https:&#x2F;&#x2F;spring.hhui.top&#x2F;spring-blog&#x2F;" rel="noopener" target="_blank">一灰灰Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.javazhiyin.com/" title="https:&#x2F;&#x2F;www.javazhiyin.com&#x2F;" rel="noopener" target="_blank">Java知音</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://indienova.com/" title="https:&#x2F;&#x2F;indienova.com&#x2F;" rel="noopener" target="_blank">独立精神</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.ityouknow.com/" title="http:&#x2F;&#x2F;www.ityouknow.com&#x2F;" rel="noopener" target="_blank">纯洁的微笑</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://sspai.com/" title="https:&#x2F;&#x2F;sspai.com&#x2F;" rel="noopener" target="_blank">少数派</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://ifeve.com/" title="http:&#x2F;&#x2F;ifeve.com&#x2F;" rel="noopener" target="_blank">并发编程网</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://hacpai.com/" title="https:&#x2F;&#x2F;hacpai.com&#x2F;" rel="noopener" target="_blank">黑客派</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.lintcode.com/" title="https:&#x2F;&#x2F;www.lintcode.com&#x2F;" rel="noopener" target="_blank">lintCode</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://stackoverflow.com/" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;" rel="noopener" target="_blank">stackoverflow</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.baeldung.com/" title="https:&#x2F;&#x2F;www.baeldung.com&#x2F;" rel="noopener" target="_blank">beeldung</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.fontawesome.com.cn/" title="http:&#x2F;&#x2F;www.fontawesome.com.cn&#x2F;" rel="noopener" target="_blank">Font Awesome中文网</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">胖枫叶</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
