<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"z201.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="基础理论篇学习笔记  什么是进程 进程是程序运行和资源分配的基本单位，一个程序至少一个进程，一个进程至少一个线程。  多个进程的*内部数据和状态是完全独立的*，而多个线程是共享一个内存空间和一组系统资源，有可能互相影响。    什么是线程 线程是程序内部的控制流，只能使用分配给线程 的资源和环境。 线程本身的数据通常只有寄存器数据，以及一个程序执行时使用的堆栈，所以线程的切换比进程切换负担要小。">
<meta property="og:type" content="article">
<meta property="og:title" content="初探Java多线程">
<meta property="og:url" content="https://z201.github.io/2019/02/27/%E5%88%9D%E6%8E%A2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="枫叶的小博客">
<meta property="og:description" content="基础理论篇学习笔记  什么是进程 进程是程序运行和资源分配的基本单位，一个程序至少一个进程，一个进程至少一个线程。  多个进程的*内部数据和状态是完全独立的*，而多个线程是共享一个内存空间和一组系统资源，有可能互相影响。    什么是线程 线程是程序内部的控制流，只能使用分配给线程 的资源和环境。 线程本身的数据通常只有寄存器数据，以及一个程序执行时使用的堆栈，所以线程的切换比进程切换负担要小。">
<meta property="og:image" content="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81.svg">
<meta property="og:image" content="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/volatile%E5%86%85%E5%AD%98.png">
<meta property="og:image" content="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E4%B8%80%E5%BC%A0%E5%9B%BE%E8%A7%A3%E9%87%8Alock.png">
<meta property="article:published_time" content="2019-02-27T04:34:08.000Z">
<meta property="article:modified_time" content="2020-08-01T09:54:03.629Z">
<meta property="article:author" content="小峰同学">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Java多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81.svg">

<link rel="canonical" href="https://z201.github.io/2019/02/27/%E5%88%9D%E6%8E%A2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>初探Java多线程 | 枫叶的小博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="枫叶的小博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">枫叶的小博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">先完成、在完美。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-存档">

    <a href="/archives" rel="section"><i class="archive fa-fw"></i>存档</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-书架">

    <a href="/books" rel="section"><i class="book fa-fw"></i>书架</a>

  </li>
        <li class="menu-item menu-item-电影">

    <a href="/movie" rel="section"><i class="file-video-o fa-fw"></i>电影</a>

  </li>
        <li class="menu-item menu-item-面试">

    <a href="/categories/%E9%9D%A2%E8%AF%95/" rel="section"><i class="graduation-cap fa-fw"></i>面试</a>

  </li>
        <li class="menu-item menu-item-学习java">

    <a href="/tags/Java/" rel="section"><i class="graduation-cap fa-fw"></i>学习java</a>

  </li>
        <li class="menu-item menu-item-学习mysql">

    <a href="/tags/Mysql/" rel="section"><i class="graduation-cap fa-fw"></i>学习mysql</a>

  </li>
        <li class="menu-item menu-item-学习git">

    <a href="/tags/Git" rel="section"><i class="graduation-cap fa-fw"></i>学习git</a>

  </li>
        <li class="menu-item menu-item-学习spring">

    <a href="/tags/Spring" rel="section"><i class="graduation-cap fa-fw"></i>学习spring</a>

  </li>
        <li class="menu-item menu-item-学习linux">

    <a href="/tags/Linux" rel="section"><i class="graduation-cap fa-fw"></i>学习linux</a>

  </li>
        <li class="menu-item menu-item-学习docker">

    <a href="/tags/Docker" rel="section"><i class="graduation-cap fa-fw"></i>学习docker</a>

  </li>
        <li class="menu-item menu-item-学习redis">

    <a href="/tags/Redis" rel="section"><i class="graduation-cap fa-fw"></i>学习redis</a>

  </li>
        <li class="menu-item menu-item-学习mybatis">

    <a href="/tags/Mybatis" rel="section"><i class="graduation-cap fa-fw"></i>学习mybatis</a>

  </li>
        <li class="menu-item menu-item-公益404">

    <a href="/404.html" rel="section"><i class="heartbeat fa-fw"></i>公益404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://z201.github.io/2019/02/27/%E5%88%9D%E6%8E%A2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar-min.jpg">
      <meta itemprop="name" content="小峰同学">
      <meta itemprop="description" content="多听、多看、少说、多做。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶的小博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          初探Java多线程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-02-27 12:34:08" itemprop="dateCreated datePublished" datetime="2019-02-27T12:34:08+08:00">2019-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-01 17:54:03" itemprop="dateModified" datetime="2020-08-01T17:54:03+08:00">2020-08-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">基础理论</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>基础理论篇学习笔记</p>
</blockquote>
<h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><ul>
<li><p>进程是程序运行和资源分配的基本单位，一个程序至少一个进程，一个进程至少一个线程。</p>
</li>
<li><p>多个进程的*<code>内部数据和状态是完全独立的</code>*，<code>而多个线程是共享一个内存空间和一组系统资源，有可能互相影响</code>。</p>
</li>
</ul>
<hr>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><ul>
<li>线程是程序内部的控制流，<code>只能使用分配给线程 的资源和环境</code>。</li>
<li><code>线程本身的数据通常只有寄存器数据，以及一个程序执行时使用的堆栈</code>，所以线程的切换比进程切换负担要小。</li>
<li>线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小能独立运行的基本单位。</li>
</ul>
<hr>
<h2 id="多线程编程的目的"><a href="#多线程编程的目的" class="headerlink" title="多线程编程的目的"></a>多线程编程的目的</h2><ul>
<li>多线程编程的目的，就是 最大限度地利用CPU资源，当某一线程的处理不需要占用CPC而和I/O等资源打交道时，让需要占用CPU资源的其他线程有机会获得CPU资源，从根本上，这就是多线程编程的最终目的。</li>
<li>线程(Thread)也是程序的最小单元，它依托进程而存在。</li>
<li>多个线程可以共享一块内存空间和一组系统资源因此线程之前的切换更加节省资源、更加轻量化，也因此被称为轻量级的进程。</li>
</ul>
<h2 id="多线程概念介绍"><a href="#多线程概念介绍" class="headerlink" title="多线程概念介绍"></a>多线程概念介绍</h2><ul>
<li>一个进程可以包含多个线程。</li>
<li>一个程序实现多个代码同时交替运行就需要产生多个线程。</li>
<li>CPU随机的抽出时间，让我们的程序一会做这件事情，一会做另外一件事情。</li>
<li>同期其他大多数编程语言不同，Java内置支持多线程编程(multithreaded progranmming)。多线程程序包包含两个或两条以上并发运作的部分，吧程序中每个这种的部分都叫做一个线程（thread)，每个线程都独立的执行路经，因此多线程是多任务处理的一种特殊形式。</li>
<li>多任务处理被所有的现代操作系统所支持。然后，多任务处理有两种截然不同的类型，基于进程和基于线程。<ul>
<li>基于进程<ul>
<li>基于进程的多任务处理是更熟悉的形式，进程（process）本质上是一个执行的程序。因此基于进程的多线程任务处理的特点是允许你的计算机同时运行两个或更多的程序。</li>
</ul>
</li>
<li>基于线程<ul>
<li>基于线程（thread-based)的多任务处理环境中，线程是最小的执行单位。这意味着一个程序可以执行两个或则多个任务的功能。</li>
</ul>
</li>
<li>多线程程序比多进程程序需要更少的管理资源。<ul>
<li>进程是重量级的任务，需要分配给他们的独立空间地址。进程之间通信是昂贵和受限的。进程之间的转换也是很需要花费的。另一方面，线程是轻量级的选手，它们共享相同的地址空间并且共享同一进程，线程之间通信是轻量级的，线程的转换也是轻量级的。</li>
</ul>
</li>
<li>线程的实现<ul>
<li>1.两种方法均需要执行线程start方法作为线程分配必须的系统资源、调度线程运行并执行线程的run方法。</li>
<li>2.在具体应用中，采用哪种方法来构造线程体要试情况而定。通常，当一个线程继承了另一个类，应该应该使用第二种方法，即使实现runnable接口。</li>
<li>3.线程的消亡不能通过调用一个Trread.stop方法，而是让线程自然消亡。</li>
</ul>
</li>
</ul>
</li>
<li><a id="more"></a>

</li>
</ul>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><blockquote>
<p>一个线程的消亡过程。</p>
</blockquote>
<ul>
<li><h4 id="新建（New）"><a href="#新建（New）" class="headerlink" title="新建（New）"></a>新建（New）</h4><ul>
<li>创建后尚未启动。</li>
</ul>
</li>
<li><h4 id="可运行（Runnable）"><a href="#可运行（Runnable）" class="headerlink" title="可运行（Runnable）"></a>可运行（Runnable）</h4><ul>
<li>可能正在运行，也可能正在等待 CPU 时间片。</li>
<li>包含了操作系统线程状态中的 运行（Running ） 和 就绪（Ready）。</li>
</ul>
</li>
<li><h4 id="无限期等待（Waiting）"><a href="#无限期等待（Waiting）" class="headerlink" title="无限期等待（Waiting）"></a>无限期等待（Waiting）</h4><ul>
<li><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>没有设置 Timeout 参数的 Object.wait() 方法</td>
<td>Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 Thread.join() 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park() 方法</td>
<td>-</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><h4 id="限期等待（Timed-Waiting）"><a href="#限期等待（Timed-Waiting）" class="headerlink" title="限期等待（Timed Waiting）"></a>限期等待（Timed Waiting）</h4><ul>
<li><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p>
</li>
<li><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用 “<strong>使一个线程睡眠</strong>” 进行描述。</p>
</li>
<li><p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用 “<strong>挂起一个线程</strong>” 进行描述。</p>
</li>
<li><p><strong>睡眠和挂起</strong>是用来描述<strong>行为</strong>，而<strong>阻塞</strong>和等待用来描述<strong>状态</strong>。</p>
</li>
<li><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>Thread.sleep() 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Object.wait() 方法</td>
<td>时间结束 / Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Thread.join() 方法</td>
<td>时间结束 / 被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos() 方法</td>
<td>-</td>
</tr>
<tr>
<td>LockSupport.parkUntil() 方法</td>
<td>-</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><h4 id="阻塞（Blocking）"><a href="#阻塞（Blocking）" class="headerlink" title="阻塞（Blocking）"></a>阻塞（Blocking）</h4><ul>
<li>这个状态下，是在多个线程有同步操作的场景，比如正在等待另一个线程的 synchronized 块的执行释放，或者可重入的 synchronized 块里别人调用 wait() 方法，也就是线程在等待进入临界区。</li>
<li>阻塞可以分为：等待阻塞，同步阻塞，其他阻塞</li>
</ul>
</li>
<li><h4 id="死亡（Terminated）"><a href="#死亡（Terminated）" class="headerlink" title="死亡（Terminated）"></a>死亡（Terminated）</h4><ul>
<li>线程因为 run 方法正常退出而自然死亡。</li>
<li>因为一个没有捕获的异常终止了 run 方法而意外死亡。</li>
</ul>
</li>
</ul>
<p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81.svg" alt="线程的状态"></p>
<h2 id="线程的基本方法"><a href="#线程的基本方法" class="headerlink" title="线程的基本方法"></a>线程的基本方法</h2><ul>
<li><p>wait线程等待</p>
<ul>
<li>调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用 wait()方法后，会释放对象的锁。因此，wait 方法一般用在同步方法或同步代码块中。</li>
</ul>
</li>
<li><p>sleep线程睡眠</p>
<ul>
<li>sleep 导致当前线程休眠，与 wait 方法不同的是 sleep 不会释放当前占有的锁,sleep(long)会导致线程进入 TIMED-WATING 状态，而 wait()方法会导致当前线程进入 WATING 状态。</li>
</ul>
</li>
<li><p>yield线程让步</p>
<ul>
<li>yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争 CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。</li>
</ul>
</li>
<li><p>interrupt线程中断</p>
<ul>
<li><p>中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态(如阻塞，终止等)。</p>
<ul>
<li><p>调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。</p>
</li>
<li><p>若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用 interrupt()方法，会抛出InterruptedException,从而使线程提前结束 TIMED-WATING 状态。</p>
<p>许多声明抛出 InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。</p>
</li>
<li><p>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程 thread 的时候，可以调用 thread.interrupt()方法，在线程的 run 方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>join等待其它线程终止</p>
<ul>
<li>join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。</li>
<li>很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要在子线程结束后再结束，这时候就要用到 join() 方法。</li>
</ul>
</li>
<li><p>notify线程唤醒</p>
<ul>
<li>Object 类中的 notify() 方法，唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。</li>
</ul>
</li>
<li><p>其它方法</p>
<ul>
<li>isAlive()： 判断一个线程是否存活。</li>
<li>activeCount()： 程序中活跃的线程数。</li>
<li>enumerate()： 枚举程序中的线程。</li>
<li>currentThread()： 得到当前线程。</li>
<li>isDaemon()： 一个线程是否为守护线程。</li>
<li>setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) </li>
<li>setName()： 为线程设置一个名称。</li>
<li>setPriority()： 设置一个线程的优先级。</li>
<li>getPriority():：获得一个线程的优先级。</li>
</ul>
</li>
</ul>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><ul>
<li><p>设置优先级是为了在多线程环境中便于系统对线程调度，优先级高的线程将优先执行。</p>
<ul>
<li>一个线程的优先级遵从以下原则。<ul>
<li>线程创建时，子继承父的优先级。</li>
<li>线程创建后，可用过调用setPriority()方法改变优先级。</li>
<li>线程的优先级是1-10之间的正整数。<ul>
<li>1   -  MIN_PRIORITY</li>
<li>10 -  MAX_PRIORITY</li>
<li>5   -  NORM_PRIORITY</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>线程的优先级策略</p>
<ul>
<li>线程调度器选择优先级最高的线程运行.但是,如果发生以下情况,就会终止线程的运行.<ul>
<li>线程体中调用了yieid()方法,让出了对CPU的占用权。</li>
<li>线程体中调用sleep()方法，使线程进入了睡眠状态。</li>
<li>线程由I/O操作而受阻塞。</li>
<li>另一个更高优先级的线程出现。</li>
<li>在支持时间片段系统中，该线程的时间片用完。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><ul>
<li><p>是指某一时间点 CPU 寄存器和程序计数器的内容。</p>
<ul>
<li>寄存器<ul>
<li>是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。</li>
</ul>
</li>
<li>程序计数器<ul>
<li>是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。</li>
</ul>
</li>
<li>上下文切换的活动</li>
</ul>
<ol>
<li>挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。</li>
<li>在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。</li>
<li>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序中。</li>
</ol>
<ul>
<li><strong>引起线程上下文切换的原因</strong></li>
</ul>
<ol>
<li>当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务。</li>
<li>当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务。</li>
<li>多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务。</li>
<li>用户代码挂起当前任务，让出 CPU 时间。</li>
<li>硬件中断。</li>
</ol>
</li>
</ul>
<h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><ul>
<li>在多线程环境中，可能会出现两个甚至多个线程试图同时访问一个有限的资源。必须对这种潜在的资源冲突进行预防。<ul>
<li>解决方案：在线程使用一个资源时为其加锁即可。访问资源的第一个线程为其上锁以后，其他线程比便不能在使用那个资源。除非被解锁。</li>
</ul>
</li>
<li>在线程环境中，关于成员变量与局部变量；如果一个变量是成员变量，那么多个线程对同一个对象的成员变量进行操作时候，他们对该成员变量是彼此影响到（也就是说一个线程对成员变量的改变会影响另一个到另一线程）。</li>
<li>不能依靠线程优先级来决定线程的执行。</li>
<li>同步到实现方式<ul>
<li>synchronized 关键字；当synchronized关键字修饰一个方法的时候，该方法叫做同步方法。</li>
<li>Java中方锁。<ul>
<li>java中每个对象都有一个锁(lock)或者叫监视器(monitor)，当访问一个对象synchronized方法时，表示将该对象上锁，此时其他任何线程在去访问该synchronized方法了，直到之前那个线程执行方法完毕后（或者抛出异常），那么该对象的锁释放掉。其他线程才有可能再去访问synchronized方法。</li>
<li>如果一个对象中有多个synchronized方法，某一时刻某个线程进入了该对象中的synchronized方法，那么在该方法没有执行完成之前或者抛出异常之前，其他线程是无法访问该对象的任何synchronized方法。</li>
<li>被synchronized保护的变量应该是private修饰的。</li>
<li>如果某个synchronized方法被static修饰的，那么当线程访问该方法时候，它锁定并不是对象（实例），而是synchronized方法所以在对象所对应的Class对象，因为Java中无论一个类有多少个对象，这些对象都会对应唯一一个Class对象，因此当线程分别访问一个类的两个对象的两个static synchronized方法时，他们的执行顺序是顺序的，也就是说一个线程先执行方法，执行完毕后另一个线程才开始执行。</li>
<li>synchronized方法是一个粗粒度的控制，某一个时刻只能有一个方法执行synchronized方法；sysnchronized块则是一种细粒度的控制方；只会将代码块同步。位于方法内、synchronized块之外的代码是可以被多个线程同时访问的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><blockquote>
<p><strong>volatile</strong> 关键字的主要作⽤就是保证变量的可⻅性然后还有⼀个作⽤是防⽌指令重排序。</p>
</blockquote>
<p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/volatile%E5%86%85%E5%AD%98.png"></p>
<ul>
<li><p>并发编程的三个重要特性</p>
<ul>
<li><p>原⼦性 : ⼀个的操作或者多次操作，要么所有的操作全部都得到执⾏并且不会收到任何因素的</p>
<p>⼲扰⽽中断，要么所有的操作都执⾏，要么都不执⾏。 synchronized 可以保证代码⽚段的原</p>
<p>⼦性。</p>
</li>
<li><p>可⻅性 ：当⼀个变量对共享变量进⾏了修改，那么另外的线程都是⽴即可以看到修改后的最新</p>
<p>值。 volatile 关键字可以保证共享变量的可⻅性。</p>
</li>
<li><p>有序性 ：代码在执⾏的过程中的先后顺序，Java 在编译器以及运⾏期间的优化，代码的执⾏顺</p>
<p>序未必就是编写代码时候的顺序。 volatile 关键字可以禁⽌指令进⾏重排序优化。</p>
</li>
</ul>
</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>读写锁</p>
<ul>
<li>如果需要实现一个读写锁，每次只能一个线程去写数据，但是有多个线程来读数据，就synchronize同步锁来对set方法加锁，get方法不加锁， 使用volatile来修饰变量，保证内存可见性，不然多个线程可能会在变量修改后还读到一个旧值。</li>
</ul>
</li>
<li><p>状态位</p>
<ul>
<li><p>用于做状态位标志，如果多个线程去需要根据一个状态位来执行一些操作，使用volatile修饰可以保证内存可见性。</p>
<p>用于单例模式用于保证内存可见性，以及防止指令重排序。</p>
</li>
</ul>
</li>
</ul>
<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><blockquote>
<p>synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰</p>
<p>的⽅法或者代码块在任意时刻只能有⼀个线程执⾏。</p>
<p>synchronized 关键字加到 static 静态⽅法和 synchronized(class)代码块上都是是给 Class</p>
<p>类上锁。synchronized 关键字加到实例⽅法上是给对象实例上锁。尽量不要使⽤</p>
<p>synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！</p>
</blockquote>
<h3 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h3><h4 id="1-同步一个代码块"><a href="#1-同步一个代码块" class="headerlink" title="1. 同步一个代码块"></a><strong>1. 同步一个代码块</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p>
<p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e2.func1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">9</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h4 id="2-同步一个方法"><a href="#2-同步一个方法" class="headerlink" title="2. 同步一个方法"></a><strong>2. 同步一个方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它和同步代码块一样，作用于同一个对象。</p>
<h4 id="3-同步一个类"><a href="#3-同步一个类" class="headerlink" title="3. 同步一个类"></a><strong>3. 同步一个类</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h4 id="4-同步一个静态方法"><a href="#4-同步一个静态方法" class="headerlink" title="4. 同步一个静态方法"></a><strong>4. 同步一个静态方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用于整个类。</p>
<h2 id="Java实现多线程的方式"><a href="#Java实现多线程的方式" class="headerlink" title="Java实现多线程的方式"></a>Java实现多线程的方式</h2><p>有三种使用线程的方法：</p>
<ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；</li>
<li>继承 Thread 类。</li>
</ul>
<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p>
<h3 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h3><p>需要实现 run() 方法。</p>
<p>通过 Thread 调用 start() 方法来启动线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyRunnable implements Runnable &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyRunnable instance &#x3D; new MyRunnable();</span><br><span class="line">    Thread thread &#x3D; new Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-Callable-接口"><a href="#实现-Callable-接口" class="headerlink" title="实现 Callable 接口"></a>实现 Callable 接口</h3><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyCallable implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">    public Integer call() &#123;</span><br><span class="line">        return 123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">    MyCallable mc &#x3D; new MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft &#x3D; new FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread &#x3D; new Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h3><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    MyThread mt &#x3D; new MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现接口-VS-继承-Thread"><a href="#实现接口-VS-继承-Thread" class="headerlink" title="实现接口 VS 继承 Thread"></a>实现接口 VS 继承 Thread</h3><p>实现接口会更好一些，因为：</p>
<ul>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li>
</ul>
<h3 id="三种方式的区别"><a href="#三种方式的区别" class="headerlink" title="三种方式的区别"></a>三种方式的区别</h3><ul>
<li>实现 Runnable 接口可以避免 Java 单继承特性而带来的局限；增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；适合多个相同程序代码的线程区处理同一资源的情况。</li>
<li>继承 Thread 类和实现 Runnable 方法启动线程都是使用 start() 方法，然后 JVM 虚拟机将此线程放到就绪队列中，如果有处理机可用，则执行 run() 方法。</li>
<li>实现 Callable 接口要实现 call() 方法，并且线程执行完毕后会有返回值。其他的两种都是重写 run() 方法，没有返回值。</li>
</ul>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><blockquote>
<p>Lock对象也可以实现同步，在使用上更加方便。</p>
</blockquote>
<p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E4%B8%80%E5%BC%A0%E5%9B%BE%E8%A7%A3%E9%87%8Alock.png"></p>
<blockquote>
<p>再Java多线程中，可以使用synchronized关键字来实现线程之间同步互斥，但是再jdk1.5以后增加了ReentrantLock类。并且功能更加强大、灵活。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 调用ReentrantLock的lock方法获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"ThreadName "</span> + Thread.currentThread().getName() + <span class="string">" number "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用ReentrantLock的lock方法释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReentrantLockDemo reentrantLockDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLockThread</span><span class="params">(ReentrantLockDemo reentrantLockDemo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reentrantLockDemo = reentrantLockDemo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reentrantLockDemo.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockDemo reentrantLockDemo = <span class="keyword">new</span> ReentrantLockDemo();</span><br><span class="line">        ReentrantLockThread reentrantLockThread1 = <span class="keyword">new</span> ReentrantLockThread(reentrantLockDemo);</span><br><span class="line">        ReentrantLockThread reentrantLockThread2 = <span class="keyword">new</span> ReentrantLockThread(reentrantLockDemo);</span><br><span class="line">        ReentrantLockThread reentrantLockThread3 = <span class="keyword">new</span> ReentrantLockThread(reentrantLockDemo);</span><br><span class="line">        ReentrantLockThread reentrantLockThread4 = <span class="keyword">new</span> ReentrantLockThread(reentrantLockDemo);</span><br><span class="line">        reentrantLockThread1.start();</span><br><span class="line">        reentrantLockThread2.start();</span><br><span class="line">        reentrantLockThread3.start();</span><br><span class="line">        reentrantLockThread4.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ThreadName Thread-<span class="number">0</span> number <span class="number">0</span></span><br><span class="line">ThreadName Thread-<span class="number">0</span> number <span class="number">1</span></span><br><span class="line">ThreadName Thread-<span class="number">0</span> number <span class="number">2</span></span><br><span class="line">ThreadName Thread-<span class="number">2</span> number <span class="number">0</span></span><br><span class="line">ThreadName Thread-<span class="number">2</span> number <span class="number">1</span></span><br><span class="line">ThreadName Thread-<span class="number">2</span> number <span class="number">2</span></span><br><span class="line">ThreadName Thread-<span class="number">3</span> number <span class="number">0</span></span><br><span class="line">ThreadName Thread-<span class="number">3</span> number <span class="number">1</span></span><br><span class="line">ThreadName Thread-<span class="number">3</span> number <span class="number">2</span></span><br><span class="line">ThreadName Thread-<span class="number">1</span> number <span class="number">0</span></span><br><span class="line">ThreadName Thread-<span class="number">1</span> number <span class="number">1</span></span><br><span class="line">ThreadName Thread-<span class="number">1</span> number <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当前的线程执行完成之后才能执行其他线程，但是其他线程执行的顺序是随机的。</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>小峰同学
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="https://z201.github.io/2019/02/27/%E5%88%9D%E6%8E%A2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="初探Java多线程">https://z201.github.io/2019/02/27/初探Java多线程/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag"># Java多线程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/02/26/%E5%AE%9E%E8%B7%B5-mybatis+h2%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" rel="prev" title="实践-mybatis+h2单元测试">
      <i class="fa fa-chevron-left"></i> 实践-mybatis+h2单元测试
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/02/27/%E5%AE%9E%E8%B7%B5-mybatis+h2+logback%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" rel="next" title="实践-mybatis+h2+logback单元测试">
      实践-mybatis+h2+logback单元测试 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是进程"><span class="nav-number">1.</span> <span class="nav-text">什么是进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是线程"><span class="nav-number">2.</span> <span class="nav-text">什么是线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程编程的目的"><span class="nav-number">3.</span> <span class="nav-text">多线程编程的目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程概念介绍"><span class="nav-number">4.</span> <span class="nav-text">多线程概念介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的生命周期"><span class="nav-number">5.</span> <span class="nav-text">线程的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#新建（New）"><span class="nav-number">5.0.1.</span> <span class="nav-text">新建（New）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可运行（Runnable）"><span class="nav-number">5.0.2.</span> <span class="nav-text">可运行（Runnable）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无限期等待（Waiting）"><span class="nav-number">5.0.3.</span> <span class="nav-text">无限期等待（Waiting）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#限期等待（Timed-Waiting）"><span class="nav-number">5.0.4.</span> <span class="nav-text">限期等待（Timed Waiting）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞（Blocking）"><span class="nav-number">5.0.5.</span> <span class="nav-text">阻塞（Blocking）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死亡（Terminated）"><span class="nav-number">5.0.6.</span> <span class="nav-text">死亡（Terminated）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的基本方法"><span class="nav-number">6.</span> <span class="nav-text">线程的基本方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程优先级"><span class="nav-number">7.</span> <span class="nav-text">线程优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#上下文切换"><span class="nav-number">8.</span> <span class="nav-text">上下文切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的同步"><span class="nav-number">9.</span> <span class="nav-text">线程的同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile关键字"><span class="nav-number">10.</span> <span class="nav-text">volatile关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用场景"><span class="nav-number">10.1.</span> <span class="nav-text">使用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized关键字"><span class="nav-number">11.</span> <span class="nav-text">synchronized关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常用场景"><span class="nav-number">11.1.</span> <span class="nav-text">常用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-同步一个代码块"><span class="nav-number">11.1.1.</span> <span class="nav-text">1. 同步一个代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-同步一个方法"><span class="nav-number">11.1.2.</span> <span class="nav-text">2. 同步一个方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-同步一个类"><span class="nav-number">11.1.3.</span> <span class="nav-text">3. 同步一个类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-同步一个静态方法"><span class="nav-number">11.1.4.</span> <span class="nav-text">4. 同步一个静态方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java实现多线程的方式"><span class="nav-number">12.</span> <span class="nav-text">Java实现多线程的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-Runnable-接口"><span class="nav-number">12.1.</span> <span class="nav-text">实现 Runnable 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现-Callable-接口"><span class="nav-number">12.2.</span> <span class="nav-text">实现 Callable 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承-Thread-类"><span class="nav-number">12.3.</span> <span class="nav-text">继承 Thread 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现接口-VS-继承-Thread"><span class="nav-number">12.4.</span> <span class="nav-text">实现接口 VS 继承 Thread</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三种方式的区别"><span class="nav-number">12.5.</span> <span class="nav-text">三种方式的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lock"><span class="nav-number">13.</span> <span class="nav-text">Lock</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小峰同学"
      src="/images/avatar-min.jpg">
  <p class="site-author-name" itemprop="name">小峰同学</p>
  <div class="site-description" itemprop="description">多听、多看、少说、多做。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">108</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">96</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/z201" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;z201" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:int_java_se@@163.com" title="E-Mail → mailto:int_java_se@@163.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.journaldev.com/" title="https:&#x2F;&#x2F;www.journaldev.com&#x2F;" rel="noopener" target="_blank">journaldev</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.geeksforgeeks.org/" title="https:&#x2F;&#x2F;www.geeksforgeeks.org&#x2F;" rel="noopener" target="_blank">geeksforgeeks</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://redisdoc.com/index.html" title="http:&#x2F;&#x2F;redisdoc.com&#x2F;index.html" rel="noopener" target="_blank">redisdoc</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.spring4all.com/" title="http:&#x2F;&#x2F;www.spring4all.com&#x2F;" rel="noopener" target="_blank">spring4all 最专业的Spring民间组织</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.sczyh30.com/" title="http:&#x2F;&#x2F;www.sczyh30.com&#x2F;" rel="noopener" target="_blank">浮生若梦</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://tengj.top/" title="http:&#x2F;&#x2F;tengj.top&#x2F;" rel="noopener" target="_blank">嘟嘟独立博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://spring.hhui.top/spring-blog/" title="https:&#x2F;&#x2F;spring.hhui.top&#x2F;spring-blog&#x2F;" rel="noopener" target="_blank">一灰灰Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.javazhiyin.com/" title="https:&#x2F;&#x2F;www.javazhiyin.com&#x2F;" rel="noopener" target="_blank">Java知音</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://indienova.com/" title="https:&#x2F;&#x2F;indienova.com&#x2F;" rel="noopener" target="_blank">独立精神</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.ityouknow.com/" title="http:&#x2F;&#x2F;www.ityouknow.com&#x2F;" rel="noopener" target="_blank">纯洁的微笑</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://sspai.com/" title="https:&#x2F;&#x2F;sspai.com&#x2F;" rel="noopener" target="_blank">少数派</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://ifeve.com/" title="http:&#x2F;&#x2F;ifeve.com&#x2F;" rel="noopener" target="_blank">并发编程网</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://hacpai.com/" title="https:&#x2F;&#x2F;hacpai.com&#x2F;" rel="noopener" target="_blank">黑客派</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.lintcode.com/" title="https:&#x2F;&#x2F;www.lintcode.com&#x2F;" rel="noopener" target="_blank">lintCode</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://stackoverflow.com/" title="https:&#x2F;&#x2F;stackoverflow.com&#x2F;" rel="noopener" target="_blank">stackoverflow</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.appinn.com/" title="https:&#x2F;&#x2F;www.appinn.com" rel="noopener" target="_blank">小众软件</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.fontawesome.com.cn/" title="http:&#x2F;&#x2F;www.fontawesome.com.cn&#x2F;" rel="noopener" target="_blank">Font Awesome中文网</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小峰同学</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
