<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫叶的小博客</title>
  
  <subtitle>先完成、在完美。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://z201.github.io/"/>
  <updated>2020-07-31T18:41:25.081Z</updated>
  <id>https://z201.github.io/</id>
  
  <author>
    <name>小峰同学</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试题-线程池</title>
    <link href="https://z201.github.io/2020/07/31/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://z201.github.io/2020/07/31/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-07-30T18:12:50.000Z</published>
    <updated>2020-07-31T18:41:25.081Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章属于持续学习、长期更修。</p></blockquote><ul><li><p><a href="https://z201.cn/2019/02/27/%E5%88%9D%E6%8E%A2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">初探Java多线程</a></p></li><li><p><a href="https://z201.cn/2020/07/30/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">面试题-多线程</a></p></li></ul><blockquote><p>为避免线程频繁创建和销毁带来的性能问题，而池化的一种方案。</p></blockquote><ul><li><p>利用线程池管理并复用线程、控制最大并发数等。</p></li><li><p>实现任务线程队列缓存策略和拒绝机制。</p></li><li><p>实现某些与时间相关的功能，如定时执行、周期执行等。</p></li><li><p>隔离线程环境。比如，交易服务和搜索服务在同一台服务器上，分别开启两个线程池，交易线程的资源消耗明显要大；因此，通过配置独立的线程池将较慢的交易服务与搜索服务隔离开，避免各服务线程相互影响。</p></li></ul><blockquote><p>这里直接参考阿里巴巴的手册。线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的读者更加明确线程池的运行规则，规避资源耗尽的风险。</p></blockquote><h3 id="Executors-返回的线程池对象的弊端"><a href="#Executors-返回的线程池对象的弊端" class="headerlink" title="Executors 返回的线程池对象的弊端"></a>Executors 返回的线程池对象的弊端</h3><ul><li>FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</li><li>CachedThreadPool 和 ScheduledThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</li><li>查看 Executors 的源码会发现，Executors.newFixedThreadPool()、Executors.newSingleThreadExecutor() 和 Executors.newCachedThreadPool() 等方法的底层都是通过 ThreadPoolExecutor 实现的。</li></ul><h3 id="ThreadPoolExecutor的核心参数"><a href="#ThreadPoolExecutor的核心参数" class="headerlink" title="ThreadPoolExecutor的核心参数"></a>ThreadPoolExecutor的核心参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        <span class="comment">// maximumPoolSize 必须大于 0，且必须大于 corePoolSize</span></span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第 1 个参数：corePoolSize 表示线程池的常驻核心线程数。如果设置为 0，则表示在没有任何任务时，销毁线程池；如果大于 0，即使没有任务时也会保证线程池的线程数量等于此值。但需要注意，此值如果设置的比较小，则会频繁的创建和销毁线程（创建和销毁的原因会在本课时的下半部分讲到）；如果设置的比较大，则会浪费系统资源，所以开发者需要根据自己的实际业务来调整此值。</p></li><li><p>第 2 个参数：maximumPoolSize 表示线程池在任务最多时，最大可以创建的线程数。官方规定此值必须大于 0，也必须大于等于 corePoolSize，此值只有在任务比较多，且不能存放在任务队列时，才会用到。</p></li><li><p>第 3 个参数：keepAliveTime 表示线程的存活时间，当线程池空闲时并且超过了此时间，多余的线程就会销毁，直到线程池中的线程数量销毁的等于 corePoolSize 为止，如果 maximumPoolSize 等于 corePoolSize，那么线程池在空闲的时候也不会销毁任何线程。</p></li><li><p>第 4 个参数：unit 表示存活时间的单位，它是配合 keepAliveTime 参数共同使用的。</p></li><li><p>第 5 个参数：workQueue 表示线程池执行的任务队列，当线程池的所有线程都在处理任务时，如果来了新任务就会缓存到此任务队列中排队等待执行。</p></li><li><p>第 6 个参数：threadFactory 表示线程的创建工厂，此参数一般用的比较少，我们通常在创建线程池时不指定此参数，它会使用默认的线程创建工厂的方法来创建线程。</p></li><li><p>第 7 个参数：RejectedExecutionHandler 表示指定线程池的拒绝策略，当线程池的任务已经在缓存队列 workQueue 中存储满了之后，并且不能创建新的线程来执行此任务时，就会用到此拒绝策略，它属于一种限流保护的机制。</p></li></ul><a id="more"></a><h3 id="线程池任务执行的主要流程"><a href="#线程池任务执行的主要流程" class="headerlink" title="线程池任务执行的主要流程"></a>线程池任务执行的主要流程</h3><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B.png"></p><h3 id="execute-VS-submit"><a href="#execute-VS-submit" class="headerlink" title="execute() VS submit()"></a>execute() VS submit()</h3><blockquote><p>execute() 和 submit() 都是用来执行线程池任务的，它们最主要的区别是，submit() 方法可以接收线程池执行的返回值，而 execute() 不能接收返回值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">10</span>, <span class="number">10L</span>,</span><br><span class="line">        TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">20</span>));</span><br><span class="line"><span class="comment">// execute 使用</span></span><br><span class="line">executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, execute."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// submit 使用</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, submit."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(future.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">//Hello, submit.</span></span><br><span class="line"><span class="comment">//Hello, execute.</span></span><br><span class="line"><span class="comment">//Success</span></span><br></pre></td></tr></table></figure><h3 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h3><blockquote><p>当线程池中的任务队列已经被存满，再有任务添加时会先判断当前线程池中的线程数是否大于等于线程池的最大值，如果是，则会触发线程池的拒绝策略。</p></blockquote><ul><li><p>Java 自带的拒绝策略有 4 种：</p></li><li><p>AbortPolicy，终止策略，线程池会抛出异常并终止执行，它是默认的拒绝策略。</p></li><li><p>CallerRunsPolicy，把任务交给当前线程来执行。</p></li><li><p>DiscardPolicy，忽略此任务（最新的任务）。</p></li><li><p>DiscardOldestPolicy，忽略最早的任务（最先加入队列的任务）。</p></li><li><p>演示AbortPolicy</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">        TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()); <span class="comment">// 添加 AbortPolicy 拒绝策略</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-2</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task com.lagou.interview.ThreadPoolExample$$Lambda$1&#x2F;1096979270@448139f0 rejected from java.util.concurrent.ThreadPoolExecutor@7cca494b[Running, pool size &#x3D; 3, active threads &#x3D; 3, queued tasks &#x3D; 2, completed tasks &#x3D; 0]</span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)</span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)</span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)</span><br><span class="line"> at com.lagou.interview.ThreadPoolExample.rejected(ThreadPoolExample.java:35)</span><br><span class="line"> at com.lagou.interview.ThreadPoolExample.main(ThreadPoolExample.java:26)</span><br></pre></td></tr></table></figure><ul><li>第 6 个任务来的时候，线程池则执行了 AbortPolicy  拒绝策略，抛出了异常。因为队列最多存储 2 个任务，最大可以创建 3 个线程来执行任务（2+3=5），所以当第 6 个任务来的时候，此线程池就“忙”不过来了。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本章属于持续学习、长期更修。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://z201.cn/2019/02/27/%E5%88%9D%E6%8E%A2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;初探Java多线程&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://z201.cn/2020/07/30/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试题-多线程&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;为避免线程频繁创建和销毁带来的性能问题，而池化的一种方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;利用线程池管理并复用线程、控制最大并发数等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现任务线程队列缓存策略和拒绝机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现某些与时间相关的功能，如定时执行、周期执行等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;隔离线程环境。比如，交易服务和搜索服务在同一台服务器上，分别开启两个线程池，交易线程的资源消耗明显要大；因此，通过配置独立的线程池将较慢的交易服务与搜索服务隔离开，避免各服务线程相互影响。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这里直接参考阿里巴巴的手册。线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的读者更加明确线程池的运行规则，规避资源耗尽的风险。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Executors-返回的线程池对象的弊端&quot;&gt;&lt;a href=&quot;#Executors-返回的线程池对象的弊端&quot; class=&quot;headerlink&quot; title=&quot;Executors 返回的线程池对象的弊端&quot;&gt;&lt;/a&gt;Executors 返回的线程池对象的弊端&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。&lt;/li&gt;
&lt;li&gt;CachedThreadPool 和 ScheduledThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。&lt;/li&gt;
&lt;li&gt;查看 Executors 的源码会发现，Executors.newFixedThreadPool()、Executors.newSingleThreadExecutor() 和 Executors.newCachedThreadPool() 等方法的底层都是通过 ThreadPoolExecutor 实现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;ThreadPoolExecutor的核心参数&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor的核心参数&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor的核心参数&quot;&gt;&lt;/a&gt;ThreadPoolExecutor的核心参数&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; corePoolSize,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maximumPoolSize,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; keepAliveTime,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          TimeUnit unit,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          ThreadFactory threadFactory,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          RejectedExecutionHandler handler)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (corePoolSize &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// maximumPoolSize 必须大于 0，且必须大于 corePoolSize&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        maximumPoolSize &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        maximumPoolSize &amp;lt; corePoolSize ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        keepAliveTime &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (workQueue == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || threadFactory == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || handler == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.acc = System.getSecurityManager() == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            AccessController.getContext();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.corePoolSize = corePoolSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maximumPoolSize = maximumPoolSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.workQueue = workQueue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.keepAliveTime = unit.toNanos(keepAliveTime);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.threadFactory = threadFactory;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.handler = handler;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第 1 个参数：corePoolSize 表示线程池的常驻核心线程数。如果设置为 0，则表示在没有任何任务时，销毁线程池；如果大于 0，即使没有任务时也会保证线程池的线程数量等于此值。但需要注意，此值如果设置的比较小，则会频繁的创建和销毁线程（创建和销毁的原因会在本课时的下半部分讲到）；如果设置的比较大，则会浪费系统资源，所以开发者需要根据自己的实际业务来调整此值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第 2 个参数：maximumPoolSize 表示线程池在任务最多时，最大可以创建的线程数。官方规定此值必须大于 0，也必须大于等于 corePoolSize，此值只有在任务比较多，且不能存放在任务队列时，才会用到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第 3 个参数：keepAliveTime 表示线程的存活时间，当线程池空闲时并且超过了此时间，多余的线程就会销毁，直到线程池中的线程数量销毁的等于 corePoolSize 为止，如果 maximumPoolSize 等于 corePoolSize，那么线程池在空闲的时候也不会销毁任何线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第 4 个参数：unit 表示存活时间的单位，它是配合 keepAliveTime 参数共同使用的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第 5 个参数：workQueue 表示线程池执行的任务队列，当线程池的所有线程都在处理任务时，如果来了新任务就会缓存到此任务队列中排队等待执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第 6 个参数：threadFactory 表示线程的创建工厂，此参数一般用的比较少，我们通常在创建线程池时不指定此参数，它会使用默认的线程创建工厂的方法来创建线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第 7 个参数：RejectedExecutionHandler 表示指定线程池的拒绝策略，当线程池的任务已经在缓存队列 workQueue 中存储满了之后，并且不能创建新的线程来执行此任务时，就会用到此拒绝策略，它属于一种限流保护的机制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://z201.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="Java多线程" scheme="https://z201.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>面试题-多线程</title>
    <link href="https://z201.github.io/2020/07/30/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://z201.github.io/2020/07/30/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-07-29T16:41:13.000Z</published>
    <updated>2020-07-31T17:10:57.382Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章属于持续学习、长期更修。</p></blockquote><ul><li><a href="https://z201.cn/2019/02/27/%E5%88%9D%E6%8E%A2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">初探Java多线程</a></li></ul><h3 id="线程的状态有哪些？又如何工作的？"><a href="#线程的状态有哪些？又如何工作的？" class="headerlink" title="线程的状态有哪些？又如何工作的？"></a>线程的状态有哪些？又如何工作的？</h3><ul><li><p>线程的状态在枚举的方式被定义在 Thread 的源码中，它总共包含以下 6 个状态：</p><ul><li>NEW，新建状态，线程被创建出来，但尚未启动时的线程状态；</li><li>RUNNABLE，就绪状态，表示可以运行的线程状态，它可能正在运行，或者是在排队等待操作系统给它分配 CPU 资源；</li><li>BLOCKED，阻塞等待锁的线程状态，表示处于阻塞状态的线程正在等待监视器锁，比如等待执行 synchronized 代码块或者使用 synchronized 标记的方法；</li><li>WAITING，等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作，比如，一个线程调用了 Object.wait() 方法，那它就在等待另一个线程调用 Object.notify() 或 Object.notifyAll() 方法；</li><li>TIMED_WAITING，计时等待状态，和等待状态（WAITING）类似，它只是多了超时时间，比如调用了有超时时间设置的方法 Object.wait(long timeout) 和 Thread.join(long timeout) 等这些方法时，它才会进入此状态；</li><li>TERMINATED，终止状态，表示线程已经执行完成。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新建状态，线程被创建出来，但尚未启动时的线程状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 就绪状态，表示可以运行的线程状态，但它在排队等待来自操作系统的 CPU 资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞等待锁的线程状态，表示正在处于阻塞状态的线程</span></span><br><span class="line"><span class="comment">     * 正在等待监视器锁，比如等待执行 synchronized 代码块或者</span></span><br><span class="line"><span class="comment">     * 使用 synchronized 标记的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作。</span></span><br><span class="line"><span class="comment">     * 例如，一个线程调用了 Object.wait() 它在等待另一个线程调用</span></span><br><span class="line"><span class="comment">     * Object.notify() 或 Object.notifyAll()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计时等待状态，和等待状态 (WAITING) 类似，只是多了超时时间，比如</span></span><br><span class="line"><span class="comment">     * 调用了有超时时间设置的方法 Object.wait(long timeout) 和 </span></span><br><span class="line"><span class="comment">     * Thread.join(long timeout) 就会进入此状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 终止状态，表示线程已经执行完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BLOCKED（阻塞等待）和-WAITING（等待）有什么区别？"><a href="#BLOCKED（阻塞等待）和-WAITING（等待）有什么区别？" class="headerlink" title="BLOCKED（阻塞等待）和 WAITING（等待）有什么区别？"></a>BLOCKED（阻塞等待）和 WAITING（等待）有什么区别？</h3><ul><li>虽然 BLOCKED 和 WAITING 都有等待的含义，但二者有着本质的区别，首先它们状态形成的调用方法不同，其次 BLOCKED 可以理解为当前线程还处于活跃状态，只是在阻塞等待其他线程使用完某个锁资源；而 WAITING 则是因为自身调用了 Object.wait() 或着是 Thread.join() 又或者是 LockSupport.park() 而进入等待状态，只能等待其他线程执行某个特定的动作才能被继续唤醒，比如当线程因为调用了 Object.wait() 而进入 WAITING 状态之后，则需要等待另一个线程执行 Object.notify() 或 Object.notifyAll() 才能被唤醒。</li></ul><a id="more"></a><h3 id="start-方法和-run-方法有什么区别？"><a href="#start-方法和-run-方法有什么区别？" class="headerlink" title="start() 方法和 run() 方法有什么区别？"></a>start() 方法和 run() 方法有什么区别？</h3><blockquote><p> Thread 源码来看，start() 方法属于 Thread 自身的方法，并且使用了 synchronized 来保证线程安全，源码如下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 状态验证，不等于 NEW 的状态会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    <span class="comment">// 通知线程组，此线程即将启动</span></span><br><span class="line"></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">// 不处理任何异常，如果 start0 抛出异常，则它将被传递到调用堆栈上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>run() 方法为 Runnable 的抽象方法，必须由调用类重写此方法，重写的 run() 方法其实就是此线程要执行的业务方法，源码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 忽略其他方法......</span></span><br><span class="line">  <span class="keyword">private</span> Runnable target;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">          target.run();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从执行的效果来说，start() 方法可以开启多线程，让线程从 NEW 状态转换成 RUNNABLE 状态，而 run() 方法只是一个普通的方法。</p><p>其次，它们可调用的次数不同，start() 方法不能被多次调用，否则会抛出 java.lang.IllegalStateException；而 run() 方法可以进行多次调用，因为它只是一个普通的方法而已。</p></blockquote><h3 id="线程的优先级有什么用？该如何设置？"><a href="#线程的优先级有什么用？该如何设置？" class="headerlink" title="线程的优先级有什么用？该如何设置？"></a>线程的优先级有什么用？该如何设置？</h3><blockquote><p>在 Thread 源码中和线程优先级相关的属性有 3 个：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程可以拥有的最小优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程可以拥有的最大优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span></span><br></pre></td></tr></table></figure><blockquote><p>线程的优先级可以理解为线程抢占 CPU 时间片的概率，优先级越高的线程优先执行的概率就越大，但并不能保证优先级高的线程一定先执行。</p><p>在程序中我们可以通过 Thread.setPriority() 来设置优先级，setPriority() 源码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="comment">// 先验证优先级的合理性</span></span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 优先级如果超过线程组的最高优先级，则把优先级设置为线程组的最高优先级</span></span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sleep-和wait-的区别"><a href="#sleep-和wait-的区别" class="headerlink" title="sleep() 和wait()的区别"></a>sleep() 和wait()的区别</h3><ul><li><p>sleep是Thread的成员方法，睡眠时保持对象锁，仍然占有该锁。</p><ul><li>sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。 </li></ul></li><li><p>wait是Object的成员方法睡眠时，释放对象锁。</p><ul><li>wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问；wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。</li></ul></li><li><p>两者最主要的区别在于：<strong>sleep</strong> ⽅法没有释放锁，⽽ <strong>wait</strong> ⽅法释放了锁 。</p></li><li><p>wait 通常被⽤于线程间交互/通信，sleep 通常被⽤于暂停执⾏。</p></li><li><p>wait() ⽅法被调⽤后，线程不会⾃动苏醒，需要别的线程调⽤同⼀个对象上的 notify() 或者notifyAll() ⽅法。sleep() ⽅法执⾏完成后，线程会⾃动苏醒。或者可以使⽤ wait(longtimeout)超时后线程会⾃动苏醒。</p></li><li><p>wait只能在synchronize代码块中，<strong>sleep</strong>不需要。</p></li></ul><h3 id="为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤run-⽅法？"><a href="#为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤run-⽅法？" class="headerlink" title="为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？"></a>为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？</h3><ul><li>new ⼀个 Thread，线程进⼊了新建状态;调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状态，当分配到时间⽚后就可以开始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏run() ⽅法的内容，这是真正的多线程⼯作。 ⽽直接执⾏ run() ⽅法，会把 run ⽅法当成⼀个 main线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。</li><li>总结： 调⽤ <strong>start</strong> ⽅法⽅可启动线程并使线程进⼊就绪状态，⽽ <strong>run</strong> ⽅法只是 <strong>thread</strong> 的⼀个普通⽅法调⽤，还是在主线程⾥执⾏。</li></ul><h3 id="notify与notifyAll的区别"><a href="#notify与notifyAll的区别" class="headerlink" title="notify与notifyAll的区别"></a>notify与notifyAll的区别</h3><blockquote><p>尽量使用notifyAll。</p></blockquote><ul><li>调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。</li><li>notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</li></ul><h3 id="说说-synchronized-关键字和-volatile-关键字的区别"><a href="#说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="说说 synchronized 关键字和 volatile 关键字的区别"></a>说说 synchronized 关键字和 volatile 关键字的区别</h3><ul><li><p><strong>volatile</strong>关键字是线程同步的轻量级实现，所以<strong>volatile</strong>性能肯定⽐<strong>synchronized</strong>关键字要好。但是<strong>volatile</strong>关键字只能⽤于变量⽽<strong>synchronized</strong>关键字可以修饰⽅法以及代码块。synchronized关键字在JavaSE1.6之后进⾏了主要包括为了减少获得锁和释放锁带来的性能消耗⽽引⼊的偏向锁和轻量级锁以及其它各种优化之后执⾏效率有了显著提升，实际开发中使⽤<strong>synchronized</strong> 关键字的场景还是更多⼀些。</p></li><li><p>多线程访问<strong>volatile</strong>关键字不会发⽣阻塞，⽽<strong>synchronized</strong>关键字可能会发⽣阻塞。</p></li><li><p><strong>volatile</strong>关键字能保证数据的可⻅性，但不能保证数据的原⼦性。<strong>synchronized</strong>关键字两者都能保证。</p></li><li><p><strong>volatile</strong>关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ <strong>synchronized</strong>关键字解决的是多个线程之间访问资源的同步性。</p></li></ul><h3 id="在多线程中，什么是上下文切换-context-switching-？"><a href="#在多线程中，什么是上下文切换-context-switching-？" class="headerlink" title="在多线程中，什么是上下文切换(context-switching)？"></a><strong>在多线程中，什么是上下文切换(context-switching)？</strong></h3><ul><li>上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</li><li>多线程编程中⼀般线程的个数都⼤于 CPU 核⼼的个数，⽽⼀个 CPU 核⼼在任意时刻只能被⼀个线程使⽤，为了让这些线程都能得到有效执⾏，CPU 采取的策略是为每个线程分配时间⽚并轮转的形式。当⼀个线程的时间⽚⽤完的时候就会重新处于就绪状态让给其他线程使⽤，这个过程就属于⼀次上下⽂切换。</li><li>概括来说就是：当前任务在执⾏完 CPU 时间⽚切换到另⼀个任务之前会先保存⾃⼰的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是⼀次上下⽂切换。上下⽂切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒⼏⼗上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下⽂切换对系统来说意味着消耗⼤量的 CPU 时间，事实上，可能是操作系统中时间消耗最⼤的操作。</li><li>Linux 相⽐与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有⼀项就是，其上下⽂切换和模式切换的时间消耗⾮常少。</li></ul><h3 id="为什么线程通信的方法wait-notify-和notifyAll-被定义在Object类里？"><a href="#为什么线程通信的方法wait-notify-和notifyAll-被定义在Object类里？" class="headerlink" title="为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？"></a><strong>为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里</strong>？</h3><ul><li>Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法。</li></ul><h3 id="为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？"></a><strong>为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？</strong></h3><ul><li>当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</li></ul><h3 id="为什么Thread类的sleep-和yield-方法是静态的？"><a href="#为什么Thread类的sleep-和yield-方法是静态的？" class="headerlink" title="为什么Thread类的sleep()和yield()方法是静态的？"></a><strong>为什么Thread类的sleep()和yield()方法是静态的？</strong></h3><ul><li>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</li></ul><h3 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal?"></a><strong>什么是ThreadLocal?</strong></h3><blockquote><p>主要解决每个线程绑定自己的值，存储每个线程的私有变量。</p></blockquote><ul><li>ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。</li><li>每个线程都会拥有他们自己的Thread变量，它们可以使用get()set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。在ThreadLocal例子这篇文章中你可以看到一个关于ThreadLocal的小程序。</li></ul><h3 id="什么是Java线程转储-Thread-Dump-，如何得到它？"><a href="#什么是Java线程转储-Thread-Dump-，如何得到它？" class="headerlink" title="什么是Java线程转储(Thread Dump)，如何得到它？"></a><strong>什么是Java线程转储(Thread Dump)，如何得到它？</strong></h3><ul><li>线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。有很多方法可以获取线程转储——使用Profiler，Kill -3命令，jstack工具等等。我更喜欢jstack工具，因为它容易使用并且是JDK自带的。由于它是一个基于终端的工具，所以我们可以编写一些脚本去定时的产生线程转储以待分析。</li></ul><h3 id="什么是死锁-Deadlock-？如何分析和避免死锁？"><a href="#什么是死锁-Deadlock-？如何分析和避免死锁？" class="headerlink" title="什么是死锁(Deadlock)？如何分析和避免死锁？"></a><strong>什么是死锁(Deadlock)？如何分析和避免死锁？</strong></h3><ul><li><p>死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。</p></li><li><p>分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。</p></li><li><p>避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。</p></li></ul><h4 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁?"></a>如何避免线程死锁?</h4><ul><li><p>破坏互斥条件 ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资</p><p>源需要互斥访问）。</p></li><li><p>破坏请求与保持条件 ：⼀次性申请所有的资源。</p></li><li><p>破坏不剥夺条件 ：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放</p><p>它占有的资源。</p></li><li><p>破坏循环等待条件 ：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破</p><p>坏循环等待条件。</p></li></ul><h3 id="谈谈-synchronized和ReentrantLock-的区别"><a href="#谈谈-synchronized和ReentrantLock-的区别" class="headerlink" title="谈谈 synchronized和ReentrantLock 的区别"></a>谈谈 synchronized和ReentrantLock 的区别</h3><ul><li><p>两者都是可重⼊锁</p><ul><li>两者都是可重⼊锁。“可重⼊锁”概念是：⾃⼰可以再次获取⾃⼰的内部锁。⽐如⼀个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重⼊的话，就会造成死锁。同⼀个线程每次获取锁，锁的计数器都⾃增1，所以要等到锁的计数器下降为0时才能释放锁。</li></ul></li><li><p><strong>synchronized</strong> 依赖于 <strong>JVM</strong> ⽽ <strong>ReentrantLock</strong> 依赖于 <strong>API</strong></p><ul><li>synchronized 是依赖于 JVM 实现的，前⾯我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进⾏了很多优化，但是这些优化都是在虚拟机层⾯实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层⾯实现的（也就是 API 层⾯，需要 lock() 和 unlock() ⽅法配合try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</li></ul></li><li><p>相⽐synchronized，ReentrantLock增加了⼀些⾼级功能</p><blockquote><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p></blockquote><ul><li><p>等待可中断</p><ul><li><strong>ReentrantLock</strong>提供了⼀种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li></ul></li><li><p>实现公平锁</p><ul><li><strong>ReentrantLock</strong>可以指定是公平锁还是⾮公平锁。⽽<strong>synchronized</strong>只能是⾮公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是⾮公平的，可以通过 ReentrantLock类的 ReentrantLock(boolean fair) 构造⽅法来制定是否是公平的。</li></ul></li><li><p>可实现选择性通知</p><ul><li>ReentrantLock类实现等待/通知机制，需要借助于Condition接⼝与newCondition() ⽅法。Condition是JDK1.5之后才有的，它具有很好的灵活性，⽐如可以实现多路通知功能也就是在⼀个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的<strong>Condition</strong>中，从⽽可以有选择性的进⾏线程通知，在调度线程上更加灵活。 在使⽤<strong>notify()/notifyAll()**⽅法进⾏通知时，被通知的线程是由 **JVM</strong> 选择的，⽤<strong>ReentrantLock</strong>类结合<strong>Condition</strong>实例可以实现<strong>“</strong>选择性通知<strong>”</strong> ，这个功能⾮常重要，⽽且是Condition接⼝默认提供的。⽽synchronized关键字就相当于整个Lock对象中只有⼀个Condition实例，所有的线程都注册在它⼀个身上。如果执⾏notifyAll()⽅法的话就会通知所有处于等待状态的线程这样会造成很⼤的效率问题，⽽Condition实例的signalAll()⽅法 只会唤醒注册在该Condition实例中的所有等待线程。</li></ul></li></ul></li></ul><h3 id="你将如何使用thread-dump？你将如何分析Thread-dump？"><a href="#你将如何使用thread-dump？你将如何分析Thread-dump？" class="headerlink" title="你将如何使用thread dump？你将如何分析Thread dump？"></a>你将如何使用thread dump？你将如何分析Thread dump？</h3><ul><li>线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。有很多方法可以获取线程转储——使用Profiler，Kill -3命令，jstack工具等等。我更喜欢jstack工具，因为它容易使用并且是JDK自带的。由于它是一个基于终端的工具，所以我们可以编写一些脚本去定时的产生线程转储以待分析。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本章属于持续学习、长期更修。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://z201.cn/2019/02/27/%E5%88%9D%E6%8E%A2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;初探Java多线程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;线程的状态有哪些？又如何工作的？&quot;&gt;&lt;a href=&quot;#线程的状态有哪些？又如何工作的？&quot; class=&quot;headerlink&quot; title=&quot;线程的状态有哪些？又如何工作的？&quot;&gt;&lt;/a&gt;线程的状态有哪些？又如何工作的？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;线程的状态在枚举的方式被定义在 Thread 的源码中，它总共包含以下 6 个状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NEW，新建状态，线程被创建出来，但尚未启动时的线程状态；&lt;/li&gt;
&lt;li&gt;RUNNABLE，就绪状态，表示可以运行的线程状态，它可能正在运行，或者是在排队等待操作系统给它分配 CPU 资源；&lt;/li&gt;
&lt;li&gt;BLOCKED，阻塞等待锁的线程状态，表示处于阻塞状态的线程正在等待监视器锁，比如等待执行 synchronized 代码块或者使用 synchronized 标记的方法；&lt;/li&gt;
&lt;li&gt;WAITING，等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作，比如，一个线程调用了 Object.wait() 方法，那它就在等待另一个线程调用 Object.notify() 或 Object.notifyAll() 方法；&lt;/li&gt;
&lt;li&gt;TIMED_WAITING，计时等待状态，和等待状态（WAITING）类似，它只是多了超时时间，比如调用了有超时时间设置的方法 Object.wait(long timeout) 和 Thread.join(long timeout) 等这些方法时，它才会进入此状态；&lt;/li&gt;
&lt;li&gt;TERMINATED，终止状态，表示线程已经执行完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; State &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 新建状态，线程被创建出来，但尚未启动时的线程状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NEW,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 就绪状态，表示可以运行的线程状态，但它在排队等待来自操作系统的 CPU 资源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RUNNABLE,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 阻塞等待锁的线程状态，表示正在处于阻塞状态的线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 正在等待监视器锁，比如等待执行 synchronized 代码块或者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 使用 synchronized 标记的方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BLOCKED,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 例如，一个线程调用了 Object.wait() 它在等待另一个线程调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * Object.notify() 或 Object.notifyAll()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WAITING,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 计时等待状态，和等待状态 (WAITING) 类似，只是多了超时时间，比如&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 调用了有超时时间设置的方法 Object.wait(long timeout) 和 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * Thread.join(long timeout) 就会进入此状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TIMED_WAITING,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 终止状态，表示线程已经执行完成&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;BLOCKED（阻塞等待）和-WAITING（等待）有什么区别？&quot;&gt;&lt;a href=&quot;#BLOCKED（阻塞等待）和-WAITING（等待）有什么区别？&quot; class=&quot;headerlink&quot; title=&quot;BLOCKED（阻塞等待）和 WAITING（等待）有什么区别？&quot;&gt;&lt;/a&gt;BLOCKED（阻塞等待）和 WAITING（等待）有什么区别？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;虽然 BLOCKED 和 WAITING 都有等待的含义，但二者有着本质的区别，首先它们状态形成的调用方法不同，其次 BLOCKED 可以理解为当前线程还处于活跃状态，只是在阻塞等待其他线程使用完某个锁资源；而 WAITING 则是因为自身调用了 Object.wait() 或着是 Thread.join() 又或者是 LockSupport.park() 而进入等待状态，只能等待其他线程执行某个特定的动作才能被继续唤醒，比如当线程因为调用了 Object.wait() 而进入 WAITING 状态之后，则需要等待另一个线程执行 Object.notify() 或 Object.notifyAll() 才能被唤醒。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://z201.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="Java多线程" scheme="https://z201.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>面试题-HashMap</title>
    <link href="https://z201.github.io/2020/07/29/%E9%9D%A2%E8%AF%95%E9%A2%98-HashMap/"/>
    <id>https://z201.github.io/2020/07/29/%E9%9D%A2%E8%AF%95%E9%A2%98-HashMap/</id>
    <published>2020-07-29T15:32:00.000Z</published>
    <updated>2020-07-30T18:22:06.372Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章属于持续学习、长期更修。</p></blockquote><ul><li><p><a href="%5Bhttps://z201.cn/2018/08/23/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAHashMap/%5D(https://z201.cn/2018/08/23/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAHashMap/)">深入浅出HashMap</a></p></li><li><p>HashMap 是使用频率最高的类型之一，同时也是面试经常被问到的问题之一，这是因为 HashMap 的知识点有很多，同时它又属于 Java 基础知识的一部分，因此在面试中经常被问到。</p></li></ul><h3 id="加载因子为什么是-0-75？"><a href="#加载因子为什么是-0-75？" class="headerlink" title="加载因子为什么是 0.75？"></a>加载因子为什么是 0.75？</h3><ul><li><p>加载因子也叫扩容因子或负载因子，用来判断什么时候进行扩容的，假如加载因子是 0.5，HashMap 的初始化容量是 16，那么当 HashMap 中有 16*0.5=8 个元素时，HashMap 就会进行扩容。</p></li><li><p>那加载因子为什么是 0.75 而不是 0.5 或者 1.0 呢？</p><ul><li><p>这其实是出于容量和性能之间平衡的结果：</p></li><li><p>当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生 Hash 冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；</p></li><li><p>而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，因此操作性能会比较高。</p></li></ul></li><li><p>所以综合了以上情况就取了一个 0.5 到 1.0 的平均数 0.75 作为加载因子。</p></li></ul><h3 id="当有哈希冲突时，HashMap-是如何查找并确认元素的？"><a href="#当有哈希冲突时，HashMap-是如何查找并确认元素的？" class="headerlink" title="当有哈希冲突时，HashMap 是如何查找并确认元素的？"></a>当有哈希冲突时，HashMap 是如何查找并确认元素的？</h3><ul><li>当哈希冲突时我们需要通过判断 key 值是否相等，才确认此元素是不是我们想要的元素。</li></ul><h3 id="HashMap-源码中有哪些重要的方法？"><a href="#HashMap-源码中有哪些重要的方法？" class="headerlink" title="HashMap 源码中有哪些重要的方法？"></a>HashMap 源码中有哪些重要的方法？</h3><ul><li>putVal()新增</li><li>resize()扩容</li><li>get()查询</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本章属于持续学习、长期更修。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;%5Bhttps://z201.cn/2018/08/23/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAHash
      
    
    </summary>
    
    
      <category term="面试" scheme="https://z201.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="Java-Collecions-Framework" scheme="https://z201.github.io/tags/Java-Collecions-Framework/"/>
    
      <category term="HashMap" scheme="https://z201.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>实践-spring-boot替换内置tomcat版本</title>
    <link href="https://z201.github.io/2020/07/23/%E5%AE%9E%E8%B7%B5-spring-boot%E6%9B%BF%E6%8D%A2%E5%86%85%E7%BD%AEtomcat%E7%89%88%E6%9C%AC/"/>
    <id>https://z201.github.io/2020/07/23/%E5%AE%9E%E8%B7%B5-spring-boot%E6%9B%BF%E6%8D%A2%E5%86%85%E7%BD%AEtomcat%E7%89%88%E6%9C%AC/</id>
    <published>2020-07-23T09:03:27.000Z</published>
    <updated>2020-07-23T09:35:21.482Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章只是回顾一次eureka版本升级后tomcat资源占用过高的问题，临时解决。</p></blockquote><h3 id="升级springBoot、SpringCloud版本"><a href="#升级springBoot、SpringCloud版本" class="headerlink" title="升级springBoot、SpringCloud版本"></a>升级springBoot、SpringCloud版本</h3><ul><li>升级完成后直接在测试环境测试部署，结果发现eureka的cpu资源占用过高，导致假死。通过arthas发现是tomcat线程阻塞。通过dependepency看了下springboot中内嵌tomcat的版本是9了。之前是8，测试环境一大堆人等着测试接口。首先想着降低tomcat版本。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看依赖</span><br><span class="line">gradle dependencies</span><br><span class="line">mvn dependency:tree &gt; output.txt   # 输出到文件里</span><br></pre></td></tr></table></figure><h3 id="排除SpringBoot的Tomcat，指定Tomcat版本"><a href="#排除SpringBoot的Tomcat，指定Tomcat版本" class="headerlink" title="排除SpringBoot的Tomcat，指定Tomcat版本"></a>排除SpringBoot的Tomcat，指定Tomcat版本</h3><p>有时候我们需要在特定情况下使用特定的Tomcat版本，这时候总不能因为Tomcat就改变SpringBoot的版本，所以可以采用排除SpringBoot中的Tomcat包，然后手动指定Tomcat的版本，当然还要引入Tomcat相关的包。</p><h5 id="Gradle的配置"><a href="#Gradle的配置" class="headerlink" title="Gradle的配置"></a>Gradle的配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>) &#123;</span><br><span class="line">  exclude <span class="keyword">module</span>: <span class="string">"spring-boot-starter-tomcat"</span></span><br><span class="line">&#125;</span><br><span class="line">compile <span class="string">'org.apache.tomcat.embed:tomcat-embed-core:8.5.37'</span></span><br><span class="line">compile <span class="string">'org.apache.tomcat.embed:tomcat-embed-el:8.5.37'</span></span><br><span class="line">compile <span class="string">'org.apache.tomcat.embed:tomcat-embed-logging-juli:8.5.2'</span></span><br><span class="line">compile <span class="string">'org.apache.tomcat.embed:tomcat-embed-websocket:8.5.37'</span></span><br></pre></td></tr></table></figure><p>如果不指定版本，则会使用最新的Tomcat版本, 否则直接指定对应的版本号。</p><h5 id="Maven的配置"><a href="#Maven的配置" class="headerlink" title="Maven的配置"></a>Maven的配置</h5><ol><li>在 pom.xml文件里面添加一个标签<properties>，添加期望的版本。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tomcat.version</span>&gt;</span>8.5.37<span class="tag">&lt;/<span class="name">tomcat.version</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>添加必要的Jar包：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-juli<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;tomcat.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-logging-juli<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;tomcat.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重新部署eureka后一切正常。处理时间短暂，没有影响大家工作。时间过了大半年了，也忘记具体是啥原因了。有机会本地复现试试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本章只是回顾一次eureka版本升级后tomcat资源占用过高的问题，临时解决。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;升级springBoot、SpringCloud版本&quot;&gt;&lt;a href=&quot;#升级springBoot、Spring
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Eureka" scheme="https://z201.github.io/tags/Eureka/"/>
    
      <category term="Tomcat" scheme="https://z201.github.io/tags/Tomcat/"/>
    
      <category term="SpringBoot" scheme="https://z201.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Git清理提交纪录</title>
    <link href="https://z201.github.io/2020/07/18/Git%E6%B8%85%E7%90%86%E6%8F%90%E4%BA%A4%E7%BA%AA%E5%BD%95/"/>
    <id>https://z201.github.io/2020/07/18/Git%E6%B8%85%E7%90%86%E6%8F%90%E4%BA%A4%E7%BA%AA%E5%BD%95/</id>
    <published>2020-07-18T15:39:21.000Z</published>
    <updated>2020-07-18T15:55:56.534Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有时候需要清理提交的历史纪录，这个时候可以采用暴力的方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Checkout </span><br><span class="line"></span><br><span class="line">   git checkout --orphan latest_branch</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Add all the files</span><br><span class="line"></span><br><span class="line">   git add -A</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Commit the changes</span><br><span class="line"></span><br><span class="line">   git commit -am <span class="string">"commit message"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> Delete the branch</span><br><span class="line"></span><br><span class="line">   git branch -D master</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>Rename the current branch to master</span><br><span class="line"></span><br><span class="line">   git branch -m master</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>Finally, force update your repository</span><br><span class="line"></span><br><span class="line">   git push -f origin master</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有时候需要清理提交的历史纪录，这个时候可以采用暴力的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="Git" scheme="https://z201.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://z201.github.io/tags/Git/"/>
    
      <category term="工作流程" scheme="https://z201.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>实践eureka钉钉告警通知</title>
    <link href="https://z201.github.io/2020/07/16/%E5%AE%9E%E8%B7%B5-eureka%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6%E9%80%9A%E7%9F%A5/"/>
    <id>https://z201.github.io/2020/07/16/%E5%AE%9E%E8%B7%B5-eureka%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6%E9%80%9A%E7%9F%A5/</id>
    <published>2020-07-16T09:04:36.000Z</published>
    <updated>2020-07-28T18:20:36.700Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇幅只是回顾使用eureka的时候如何钉钉告警。</p></blockquote><h3 id="eureka如何快速实现钉钉告警"><a href="#eureka如何快速实现钉钉告警" class="headerlink" title="eureka如何快速实现钉钉告警"></a>eureka如何快速实现钉钉告警</h3><p><a href="https://z201.cn/2020/07/15/%E5%AE%9E%E8%B7%B5-spring-boot%E5%BC%82%E5%B8%B8%E9%92%89%E9%92%89%E9%80%9A%E7%9F%A5/" target="_blank" rel="noopener">实践-spring-boot异常钉钉通知</a></p><p>​        上面实践了springboot全局异常钉钉告警机制。这篇主要回顾eureka监听机制钉钉告警。在日常维护工作中，如果出现网络抖动或者其它问题导致应用不可用，需要第一件发出告警提醒相关人员尽快处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">eureka -&gt;&gt; eventListener : event</span><br><span class="line">eventListener -&gt;&gt;  钉钉 : alarmNoticeSend</span><br><span class="line">钉钉 -&gt;&gt; 开发人员  : eurekaInstanceInfo</span><br></pre></td></tr></table></figure><ul><li>实例图</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/eureka%E5%AE%9E%E4%BE%8B%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6.png"></p><p>​        关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(EurekaInstanceCanceledEvent event)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"告警通知 [&#123;&#125;] 服务注销 timestamp [&#123;&#125;] serverId [&#123;&#125;]"</span>,</span><br><span class="line">                event.getAppName(),</span><br><span class="line">                event.getTimestamp(),</span><br><span class="line">                event.getServerId());</span><br><span class="line">        <span class="keyword">if</span> (!event.isReplication()) &#123;</span><br><span class="line">            ServiceNotice serviceNotice = <span class="keyword">new</span> ServiceNotice();</span><br><span class="line">            serviceNotice.setTitle(<span class="string">"告警通知 服务下线"</span>);</span><br><span class="line">            serviceNotice.setAppName(event.getAppName());</span><br><span class="line">            serviceNotice.setTimestamp(event.getTimestamp());</span><br><span class="line">            serviceNotice.setServerId(event.getServerId());</span><br><span class="line">            serviceNotice.setProfiles(active);</span><br><span class="line">            alarmNoticeManage.createNotice(serviceNotice, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(EurekaInstanceRegisteredEvent event)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"告警通知 [&#123;&#125;] 服务注册 timestamp [&#123;&#125;] id [&#123;&#125;] ipAddr [&#123;&#125;] "</span>,</span><br><span class="line">                event.getInstanceInfo().getAppName(),</span><br><span class="line">                event.getTimestamp(),</span><br><span class="line">                event.getInstanceInfo().getId(),</span><br><span class="line">                event.getInstanceInfo().getIPAddr()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (!event.isReplication()) &#123;</span><br><span class="line">            ServiceNotice serviceNotice = <span class="keyword">new</span> ServiceNotice();</span><br><span class="line">            serviceNotice.setTitle(<span class="string">"告警通知 服务上线"</span>);</span><br><span class="line">            serviceNotice.setAppName(event.getInstanceInfo().getAppName());</span><br><span class="line">            serviceNotice.setTimestamp(event.getTimestamp());</span><br><span class="line">            serviceNotice.setServerId(event.getInstanceInfo().getId());</span><br><span class="line">            serviceNotice.setProfiles(active);</span><br><span class="line">            alarmNoticeManage.createNotice(serviceNotice, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>效果如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">告警通知 服务下线</span><br><span class="line">2020-07-16 16:03:20 Z-GATEWAY 192.168.31.7:z-gateway:9000 profiles dev1</span><br><span class="line">@xxx</span><br></pre></td></tr></table></figure><ul><li>eureka查看源码得知有五个事件。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EurekaServerStartedEvent - Eureka服务端启动事件</span><br><span class="line">EurekaRegistryAvailableEvent - Eureka服务端可用事件</span><br><span class="line">EurekaInstanceRegisteredEvent - Eureka客户端服务注册事件</span><br><span class="line">EurekaInstanceRenewedEvent - Eureka客户端续约事件</span><br><span class="line">EurekaInstanceCanceledEvent - Eureka客户端下线事件</span><br></pre></td></tr></table></figure><p>这里就比较简单了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇幅只是回顾使用eureka的时候如何钉钉告警。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;eureka如何快速实现钉钉告警&quot;&gt;&lt;a href=&quot;#eureka如何快速实现钉钉告警&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="Eureka" scheme="https://z201.github.io/tags/Eureka/"/>
    
      <category term="钉钉" scheme="https://z201.github.io/tags/%E9%92%89%E9%92%89/"/>
    
  </entry>
  
  <entry>
    <title>实践SpringBoot异常钉钉通知</title>
    <link href="https://z201.github.io/2020/07/15/%E5%AE%9E%E8%B7%B5-spring-boot%E5%BC%82%E5%B8%B8%E9%92%89%E9%92%89%E9%80%9A%E7%9F%A5/"/>
    <id>https://z201.github.io/2020/07/15/%E5%AE%9E%E8%B7%B5-spring-boot%E5%BC%82%E5%B8%B8%E9%92%89%E9%92%89%E9%80%9A%E7%9F%A5/</id>
    <published>2020-07-15T07:23:20.000Z</published>
    <updated>2020-07-23T09:04:39.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇幅只是回顾使用钉钉做异常告警需要那些关键业务信息。</p></blockquote><h3 id="为什么要做钉钉通知？"><a href="#为什么要做钉钉通知？" class="headerlink" title="为什么要做钉钉通知？"></a>为什么要做钉钉通知？</h3><p>​        事情要从我入职上家公司说起，进入公司后把线上项目clone下来大致看了下。代码风格过于滞后、编码风格混乱。进入公司第一周就出现了线上故障，嗯。我去线上检查日志，emmmm竟然没有日志输出。这次故障是由客户反馈来的。当时我非常吃惊，大伙好像很淡定的样子，习以为常了？</p><p>​        想到当初面试的时候和总监的谈话，主要是带领团队落地微服务架构，看来必须大刀阔斧了。</p><p>​        首先想到的时候改进日志输出、定义全局异常级别，根据异常级别输出日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">Java应用 -&gt;&gt; SpringAop全局异常拦截 : runtimeException</span><br><span class="line">SpringAop全局异常拦截 -&gt;&gt;  钉钉 : alarmNoticeSend</span><br><span class="line">钉钉 -&gt;&gt; 开发人员  : exceptionInfo</span><br></pre></td></tr></table></figure><ul><li>效果图</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/springboot%E9%92%89%E9%92%89%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA.png"></p><p>​        我们需要从钉钉里面看到那些异常信息呢？这是当时输出到钉钉的信息。通过编写全局拦截器，在公共基础项目里面添加了aop全局拦截。刚开始上线的时候钉钉一天动不动就几千个异常告警。刚开始大伙都很紧张，过了个把月大伙已经又麻木了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">告警信息</span><br><span class="line">工程名：z201-gateway</span><br><span class="line">类路径：cn.z201.cloud.gateway.VlinkFrameworkGatewayApplicationTest</span><br><span class="line">方法名：alarm</span><br><span class="line">异常信息：java.lang.IllegalAccessException</span><br><span class="line">异常追踪：</span><br><span class="line">cn.z201.cloud.gateway.VlinkFrameworkGatewayApplicationTest.alarm(VlinkFrameworkGatewayApplicationTest.java:<span class="number">64</span>)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">org.junit.runners.model.FrameworkMethod$<span class="number">1</span>.runReflectiveCall(FrameworkMethod.java:<span class="number">50</span>)</span><br><span class="line">org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:<span class="number">12</span>)</span><br><span class="line">org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:<span class="number">47</span>)</span><br><span class="line">org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:<span class="number">17</span>)</span><br><span class="line">org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:<span class="number">74</span>)</span><br></pre></td></tr></table></figure><h3 id="这样的告警信息就够了吗？"><a href="#这样的告警信息就够了吗？" class="headerlink" title="这样的告警信息就够了吗？"></a>这样的告警信息就够了吗？</h3><p>​        明显这样是不够够的，前端有安卓、ios、微信小程序、web、快应用。太多前端项目了，后端需要识别出是哪里的项目出的问题。于是又改进了一次。邀请前端开发人员在HttpHeader里面增加额外参数。为了做流量区分也增加了一些参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  <span class="string">"Content-Type"</span>:<span class="string">"application/json"</span> </span><br><span class="line">  "Authorization":"Bearer xxxxxxxxxx"  ## jwt</span><br><span class="line">  "Client-Business-Group-Source": "1", ##  业务组来源唯一标号</span><br><span class="line">  "Client-Business-Source": "1000", ## 业务来源唯一标号</span><br><span class="line">  "Client-Business-Activity-Source": "1", ## 查看介绍、更多 针对特殊业务流量识别</span><br><span class="line">  "Client-Env-Source": "1", ##客户端环境来源  1 ios  2 android  3 windows</span><br><span class="line">  "Client-Platform-Source": "xxx", ##客户端平台 xxx手机型号、浏览器</span><br><span class="line">  "Client-Start-Time": "1",        ##请求时间戳</span><br><span class="line">  "Client-Version-Source": "1.0.0" ##客户端版本号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        通过上面的改进告警信息完善很多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">告警信息</span><br><span class="line">工程名：z201-gateway</span><br><span class="line">类路径：cn.z201.cloud.gateway.VlinkFrameworkGatewayApplicationTest</span><br><span class="line">方法名：alarm</span><br><span class="line">异常信息：java.lang.IllegalAccessException</span><br><span class="line">异常扩展信息： &#123;</span><br><span class="line">  &quot;Client-Business-Source&quot;: &quot;1000&quot;, </span><br><span class="line">  &quot;Client-Business-Activity-Source&quot;: &quot;1&quot;, </span><br><span class="line">  &quot;Client-Env-Source&quot;: &quot;1&quot;, </span><br><span class="line">  &quot;Client-Platform-Source&quot;: &quot;xxx&quot;,   </span><br><span class="line">  &quot;Client-Version-Source&quot;: &quot;1.0.0&quot; </span><br><span class="line">&#125; </span><br><span class="line">异常追踪：</span><br><span class="line">cn.z201.cloud.gateway.VlinkFrameworkGatewayApplicationTest.alarm(VlinkFrameworkGatewayApplicationTest.java:64)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)</span><br><span class="line">org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)</span><br><span class="line">org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)</span><br><span class="line">org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)</span><br><span class="line">org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74)</span><br></pre></td></tr></table></figure><h3 id="分布式下面临的问题！"><a href="#分布式下面临的问题！" class="headerlink" title="分布式下面临的问题！"></a>分布式下面临的问题！</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">gateway -&gt;&gt; 应用A : httpRequest</span><br><span class="line">应用A -&gt;&gt;  应用B : httpRequest</span><br><span class="line">应用B --&gt;&gt; 应用A : httpResponse</span><br><span class="line">应用A --&gt;&gt; gateway : httpResponse</span><br></pre></td></tr></table></figure><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E5%A4%9A%E5%BA%94%E7%94%A8%E9%93%BE%E8%B7%AF%E8%AF%B7%E6%B1%82.png"></p><p>​        当调用链多的时候定位问题就有点麻烦，比如应用a调用应用b。应用b执行了异常信息直接抛出了告警信息。但是spring cloud http rpc默认是不会吧请求参数传递到后面的服务中，需要我们做下简单的扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> z201.coding@gmail.com</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpApiConstant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String X_REAL_IP = <span class="string">"x-real-ip"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求头跟踪id名。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String HTTP_HEADER_TRACE_ID = <span class="string">"AppTraceId"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String HTTP_TOKEN_HEADER = <span class="string">"Authorization"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * app租户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String APP_TENANT = <span class="string">"Tenant"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_BUSINESS_GROUP_SOURCE = <span class="string">"Client-Business-Group-Source"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_BUSINESS_SOURCE = <span class="string">"Client-Business-Source"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_BUSINESS_ACTIVITY_SOURCE = <span class="string">"Client-Business-Activity-Source"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_EVN_SOURCE = <span class="string">"Client-Env-Source"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_PLATFORM_SOURCE = <span class="string">"Client-Platform-Source"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_START_TIME = <span class="string">"Client-Start-Time"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_VERSION_SOURCE = <span class="string">"Client-Version-Source"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> z201.coding@gmail.com</span></span><br><span class="line"><span class="comment"> * 自定义restTemplate拦截器</span></span><br><span class="line"><span class="comment"> * 这里可以把一些参数从应用层传到内部服务</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(WebMvcConfigurer<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MdcFeignInterceptorConfig</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span>, <span class="title">HttpApiConstant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MdcFeignInterceptorConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Loaded Z-REST-INTERCEPTOR [V1.0.0]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes())</span><br><span class="line">                    .getRequest();</span><br><span class="line">            String xRealIp = request.getHeader(X_REAL_IP);</span><br><span class="line">            String authentication = request.getHeader(HTTP_TOKEN_HEADER);</span><br><span class="line">            String appTraceId = request.getHeader(HTTP_HEADER_TRACE_ID);</span><br><span class="line">            String businessGroupSource = request.getHeader(CLIENT_BUSINESS_GROUP_SOURCE);</span><br><span class="line">            String clientBusinessSource = request.getHeader(CLIENT_BUSINESS_SOURCE);</span><br><span class="line">            String clientBusinessActivitySource = request.getHeader(CLIENT_BUSINESS_ACTIVITY_SOURCE);</span><br><span class="line">            String clientEnvSource = request.getHeader(CLIENT_EVN_SOURCE);</span><br><span class="line">            String clientPlatformSource = request.getHeader(CLIENT_PLATFORM_SOURCE);</span><br><span class="line">            String clientStartTime = request.getHeader(CLIENT_START_TIME);</span><br><span class="line">            String clientVersionSource = request.getHeader(CLIENT_VERSION_SOURCE);</span><br><span class="line">            template.header(HttpHeaders.ACCEPT_ENCODING, <span class="string">"gzip"</span>);</span><br><span class="line">            template.header(X_REAL_IP, xRealIp);</span><br><span class="line">            template.header(HTTP_TOKEN_HEADER, authentication);</span><br><span class="line">            template.header(CLIENT_BUSINESS_GROUP_SOURCE, businessGroupSource);</span><br><span class="line">            template.header(CLIENT_BUSINESS_SOURCE, clientBusinessSource);</span><br><span class="line">            template.header(CLIENT_BUSINESS_ACTIVITY_SOURCE, clientBusinessActivitySource);</span><br><span class="line">            template.header(CLIENT_EVN_SOURCE, clientEnvSource);</span><br><span class="line">            template.header(CLIENT_PLATFORM_SOURCE, clientPlatformSource);</span><br><span class="line">            template.header(CLIENT_START_TIME, clientStartTime);</span><br><span class="line">            template.header(CLIENT_VERSION_SOURCE, clientVersionSource);</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                Enumeration&lt;String&gt; headerNames = request.getHeaderNames();</span><br><span class="line">                <span class="keyword">while</span> (headerNames.hasMoreElements()) &#123;</span><br><span class="line">                    String name = headerNames.nextElement();</span><br><span class="line">                    String value = request.getHeader(name);</span><br><span class="line">                    log.debug(<span class="string">"header &#123;&#125; - &#123;&#125;"</span>, name, value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"template exception &#123;&#125;"</span>,e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的异常钉钉告警就到这里结束了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇幅只是回顾使用钉钉做异常告警需要那些关键业务信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;为什么要做钉钉通知？&quot;&gt;&lt;a href=&quot;#为什么要做钉钉通知？&quot; class=&quot;headerlink&quot; title=&quot;为什么要做钉钉通知？
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://z201.github.io/tags/Spring/"/>
    
      <category term="钉钉" scheme="https://z201.github.io/tags/%E9%92%89%E9%92%89/"/>
    
  </entry>
  
  <entry>
    <title>redis-cli使用</title>
    <link href="https://z201.github.io/2019/12/15/redis-cli%E4%BD%BF%E7%94%A8/"/>
    <id>https://z201.github.io/2019/12/15/redis-cli%E4%BD%BF%E7%94%A8/</id>
    <published>2019-12-15T08:56:48.000Z</published>
    <updated>2020-07-18T15:27:19.713Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在mac中使用redis-cli。相比rdm我可能更喜欢这个命令行工具。</p></blockquote><h3 id="在mac中之安装redis-cli"><a href="#在mac中之安装redis-cli" class="headerlink" title="在mac中之安装redis-cli"></a>在mac中之安装redis-cli</h3><blockquote><p>按照标准的按照流程，需要先安装redis-server。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew tap ringohub/redis-cli</span><br><span class="line"></span><br><span class="line">brew update &amp;&amp; brew doctor</span><br><span class="line"></span><br><span class="line">brew install redis-cli</span><br></pre></td></tr></table></figure><ul><li>相关文档<a href="https://stackoverflow.com/questions/39704273/macos-x-is-there-a-way-to-install-only-redis-cli" target="_blank" rel="noopener">https://stackoverflow.com/questions/39704273/macos-x-is-there-a-way-to-install-only-redis-cli</a></li></ul><h3 id="根据redis常用命令来学习使用redis-cli。"><a href="#根据redis常用命令来学习使用redis-cli。" class="headerlink" title="根据redis常用命令来学习使用redis-cli。"></a>根据redis常用命令来学习使用redis-cli。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在mac中使用redis-cli。相比rdm我可能更喜欢这个命令行工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;在mac中之安装redis-cli&quot;&gt;&lt;a href=&quot;#在mac中之安装redis-cli&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="redis" scheme="https://z201.github.io/categories/redis/"/>
    
    
      <category term="Redis" scheme="https://z201.github.io/tags/Redis/"/>
    
      <category term="Redis-cli" scheme="https://z201.github.io/tags/Redis-cli/"/>
    
  </entry>
  
  <entry>
    <title>brew个人工具清单</title>
    <link href="https://z201.github.io/2019/12/15/brew%E4%B8%AA%E4%BA%BA%E5%B7%A5%E5%85%B7%E6%B8%85%E5%8D%95/"/>
    <id>https://z201.github.io/2019/12/15/brew%E4%B8%AA%E4%BA%BA%E5%B7%A5%E5%85%B7%E6%B8%85%E5%8D%95/</id>
    <published>2019-12-15T07:00:02.000Z</published>
    <updated>2019-12-15T17:03:40.033Z</updated>
    
    <content type="html"><![CDATA[<p>#Mac下个人工具清单。</p><h2 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h2><table><thead><tr><th>Tool name</th><th>Install command</th><th>Description</th></tr></thead><tbody><tr><td>Wget</td><td>brew install  wget</td><td>下载工具</td></tr><tr><td>Curl</td><td>brew install curl</td><td>下载工具</td></tr><tr><td>Diff</td><td>brew install difftuils</td><td>Gnu 比较工具</td></tr><tr><td>Find</td><td>brew install findtuils</td><td>Gnu 查找工具</td></tr><tr><td>htop</td><td>brew install stop</td><td>代替top</td></tr><tr><td>Axel</td><td>brew install axel</td><td>多线程下载</td></tr><tr><td>Tmux</td><td>brew install tmux</td><td>终端复用</td></tr><tr><td>cloc</td><td>brew install cloc</td><td>代码统计</td></tr><tr><td>Tldr</td><td>brew install tldr</td><td>命令提示行</td></tr><tr><td>Ncdu</td><td>brew install ncdu</td><td>磁盘空间占用成分</td></tr><tr><td>ctop</td><td>brew install stop</td><td>Docker 容器监控工具</td></tr><tr><td>Pstree</td><td>brew install</td><td>进程树查看</td></tr><tr><td>Bash-completion</td><td>brew install</td><td>bash补全</td></tr><tr><td>Graphviz</td><td>brew install</td><td>拓扑图绘制工具</td></tr></tbody></table><h2 id="brew-cask"><a href="#brew-cask" class="headerlink" title="brew cask"></a>brew cask</h2><table><thead><tr><th>Tool name</th><th>Install command</th><th>Description</th></tr></thead><tbody><tr><td>cask</td><td>brew tap cask room/cask</td><td>Cask</td></tr><tr><td>Macpass</td><td>brew cask install macpass</td><td>免费密码管理</td></tr><tr><td>docker</td><td>brew cask install docker</td><td>docker 必备</td></tr><tr><td>Fonts</td><td>brew tap cask room/fonts</td><td>字体管理</td></tr><tr><td>licecap</td><td>brew cask install licecap</td><td>录屏软件</td></tr><tr><td>Kap</td><td>brew cask install kap</td><td>视频录屏</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#Mac下个人工具清单。&lt;/p&gt;
&lt;h2 id=&quot;brew&quot;&gt;&lt;a href=&quot;#brew&quot; class=&quot;headerlink&quot; title=&quot;brew&quot;&gt;&lt;/a&gt;brew&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tool name&lt;/th&gt;
&lt;th&gt;I
      
    
    </summary>
    
    
      <category term="工具" scheme="https://z201.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="mac" scheme="https://z201.github.io/tags/mac/"/>
    
      <category term="brew" scheme="https://z201.github.io/tags/brew/"/>
    
      <category term="tools" scheme="https://z201.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>学习中自我认知</title>
    <link href="https://z201.github.io/2019/11/17/%E5%AD%A6%E4%B9%A0%E4%B8%AD%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5/"/>
    <id>https://z201.github.io/2019/11/17/%E5%AD%A6%E4%B9%A0%E4%B8%AD%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5/</id>
    <published>2019-11-17T08:38:13.000Z</published>
    <updated>2020-07-27T12:55:15.703Z</updated>
    
    <content type="html"><![CDATA[<h3 id="了解真实的自己"><a href="#了解真实的自己" class="headerlink" title="了解真实的自己"></a>了解真实的自己</h3><blockquote><p>自己从小到大都不是一个学习好的孩子，但是从来不觉得自己的智商差。但是自己的学习方式或者说学习思维确实一点都没养成。</p></blockquote><ul><li><p>逐步改变自己之前，需要对自己的情况进行一个了解。近几天都在看关于学习相关的资料和视频。今天突然发现一个特别有趣的话<code>间歇性踌躇满志，持续性混吃等死</code>，感觉这就是我十多年来对学习这会事态度的完美诠释。更可怕的是这大概是我早期应对焦虑的手段之一。</p></li><li><p>根据自己当前的实际情况，分析整理专业知识。整理自己的时间，对于时间这个事情。这是世上对所有人都公平的事情，所以如何根据自己的情况合理分配时间至关重要。</p></li><li><p>整理需要掌握的知识方向，归纳需要掌握的知识点。优先改善自己的学习思维，刻意有目标的去学习。</p></li><li><p>冲动性学习很难长久，所以需要对自己更为了解才行。</p></li></ul><h3 id="通过各种途径去了解自己"><a href="#通过各种途径去了解自己" class="headerlink" title="通过各种途径去了解自己"></a>通过各种途径去了解自己</h3><blockquote><p>了解自己是一个漫长的过程，自律是漫长的。每个人的坚持的方法都不一样，自律就是对自己不满意。对现实不满意，才会让自己努力去改变自己。</p></blockquote><ul><li><a href="https://www.apesk.com/mbti/dati.asp" target="_blank" rel="noopener">mbti测试</a> 这是非常权威的心理测试。</li><li>每个人坚持的方法都不一样，比如背单词的app每天打卡，或者番茄工作法。寻找自己的坚持点非常重要，如果不能找到自己的坚持点，大多情况下都会所谓的坚持都只会仓促结束。</li></ul><h3 id="让自己更加优秀"><a href="#让自己更加优秀" class="headerlink" title="让自己更加优秀"></a>让自己更加优秀</h3><ol><li><strong>理解和接受自己会犯错误。</strong>关键是要尽早发现，在错误进入到最终产品前发现它们。幸运的是，除了我们少数几个在喷气推进实验所开发火箭导航系统的人外，在软件行业中犯错误通常不会导致灾难性事故。我们可以，也应该从错误中吸取教训，微笑，并继续前进。</li><li><strong>你不是你的代码。</strong>记住代码审查的全部目的就是去发现问题，相信问题会被我们发现。当有问题疏漏时不要自责。</li><li><strong>不管你对“空手道”有多了解，一定会有人知道的更多。</strong>如果你去问，这样的人可以告诉你一些新的招数。从别人那里寻找和接受新的知识，特别是那些你认为不需要的知识。</li><li><strong>不要在没有讨论的情况下重写代码。</strong>在“调整代码”和“重写代码”之间有一条很细致的界限，你应该在代码审查的制度下做风格上的调整，不要独断专行。</li><li><strong>对那些不如你的人要尊敬，礼遇，有耐心。</strong>经常跟开发人员打交道的非技术人士通常持有这样的观点：程序员凭借一技之长狂放不羁。不要让你的发怒和缺乏耐性让他们心中的这种形象加深。</li><li><strong>这世界上唯一不变的就是变化。</strong>开放思考，面带微笑的接受它。把需求上、平台或工具里的每个改变都视作一种新的挑战，而不是把它们当作大麻烦来抵制。</li><li><strong>真正的权威来自知识，而不是职位。</strong>知识造就权威，权威带来尊敬——所以，如果你想在一个无私的环境中获得尊敬，去培养自己的知识吧。</li><li><strong>为信仰奋斗，但我文雅的接受失败。</strong>要理解，有时候你的想法会被拒绝。即使你是对的，你也不要报复或说“I told you so.”千万不要让你心爱的被抛弃的想法变成殉道者或抱怨素材。</li><li><strong>不要成为“角落里的程序员。”</strong>不要成为隐藏在黑暗办公室里、只因为口渴才出现的人。藏在角落的里程序员短视、与世隔绝、不受控制。这样的人在公开的、合作的工作环境中发不出声音。参与到交流中，成为你的办公室团体中的一员。</li><li><strong>批评代码而不是人——对编码人友善，但不要对代码友善。</strong>尽可能的让你的批评具有积极性，以改进代码为目标。批评要联系本地标准，编程规格文档和提高后的性能等。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;了解真实的自己&quot;&gt;&lt;a href=&quot;#了解真实的自己&quot; class=&quot;headerlink&quot; title=&quot;了解真实的自己&quot;&gt;&lt;/a&gt;了解真实的自己&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;自己从小到大都不是一个学习好的孩子，但是从来不觉得自己的智商差。但是自己的
      
    
    </summary>
    
    
      <category term="改变自己" scheme="https://z201.github.io/categories/%E6%94%B9%E5%8F%98%E8%87%AA%E5%B7%B1/"/>
    
    
      <category term="自律" scheme="https://z201.github.io/tags/%E8%87%AA%E5%BE%8B/"/>
    
      <category term="计划" scheme="https://z201.github.io/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="学习" scheme="https://z201.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="人生" scheme="https://z201.github.io/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>学习自律</title>
    <link href="https://z201.github.io/2019/11/17/%E5%AD%A6%E4%B9%A0%E8%87%AA%E5%BE%8B/"/>
    <id>https://z201.github.io/2019/11/17/%E5%AD%A6%E4%B9%A0%E8%87%AA%E5%BE%8B/</id>
    <published>2019-11-17T01:12:31.000Z</published>
    <updated>2020-07-27T12:55:20.632Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面对焦虑"><a href="#面对焦虑" class="headerlink" title="面对焦虑"></a>面对焦虑</h3><blockquote><p>随着年龄不断提升,生活和未来带来的焦虑。让自己难以招架，这个年龄在来改变自己晚吗？其实不晚。</p></blockquote><ul><li><p>面对焦虑最好的办法就是改变自己，不断提升自己。让自己过的充实。</p></li><li><p>工业化的社会，拥有的自由时间应该是用来提升自己的。而不是一味的娱乐。</p></li><li><p>改变自己、提升自己。让自己的生活变得充实健康。不努力只会和那些正在努力的人差距只会只会越来越大。最终可能完全丧失竞争力。</p></li></ul><h3 id="尝试计划"><a href="#尝试计划" class="headerlink" title="尝试计划"></a>尝试计划</h3><blockquote><p>尝试和自己斗智斗勇，如果想要改变自己首先要能约束自己。让自己的行为按照自己预期的方向前进。</p></blockquote><ul><li><p>尝试对每天的事情，进行一个安排。</p></li><li><p>尝试对每天安排的事情，逐个完成。</p></li><li><p>根据自己当前的情况调整安排的计划，让计划和生活更加协调。</p></li><li><p>细化计划内容，让大脑习惯这种方式。</p></li></ul><h3 id="高效习惯"><a href="#高效习惯" class="headerlink" title="高效习惯"></a>高效习惯</h3><blockquote><p>尝试更加高效的生活，而不是让自己的生活一味的随心所欲。去思考去实践，让生活更加高效有趣。</p></blockquote><ul><li>生活的琐事上，会消耗的大量的时间。高效简洁的处理，让自己的可以掌控时间增加。</li><li>科学、健康、合理的安排的自己的时间。计划永远赶不上变化，适当调整计划，保持住一个合理的时间安排。</li></ul><h3 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h3><blockquote><p>每个人的学习方式都不一样，不断的去寻找适合自己的方式、方法。</p></blockquote><ul><li>一流的企业做标准，二流的企业做品牌，三流的企业做产品。</li><li>优秀的学生练思维，良好的学生找方法，一般的学生学知识。</li></ul><h3 id="养成习惯"><a href="#养成习惯" class="headerlink" title="养成习惯"></a>养成习惯</h3><blockquote><p>养成好的习惯终生适用。</p></blockquote><ul><li>我们的大脑是有非常强的可塑性，通过刻意的练习锻炼大脑。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面对焦虑&quot;&gt;&lt;a href=&quot;#面对焦虑&quot; class=&quot;headerlink&quot; title=&quot;面对焦虑&quot;&gt;&lt;/a&gt;面对焦虑&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;随着年龄不断提升,生活和未来带来的焦虑。让自己难以招架，这个年龄在来改变自己晚吗？其实不晚。&lt;/p
      
    
    </summary>
    
    
      <category term="改变自己" scheme="https://z201.github.io/categories/%E6%94%B9%E5%8F%98%E8%87%AA%E5%B7%B1/"/>
    
    
      <category term="自律" scheme="https://z201.github.io/tags/%E8%87%AA%E5%BE%8B/"/>
    
      <category term="计划" scheme="https://z201.github.io/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="学习" scheme="https://z201.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="人生" scheme="https://z201.github.io/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>实践nginx日志简单的统计</title>
    <link href="https://z201.github.io/2019/06/04/%E5%AE%9E%E8%B7%B5nginx%E6%97%A5%E5%BF%97%E7%AE%80%E5%8D%95%E7%9A%84%E7%BB%9F%E8%AE%A1/"/>
    <id>https://z201.github.io/2019/06/04/%E5%AE%9E%E8%B7%B5nginx%E6%97%A5%E5%BF%97%E7%AE%80%E5%8D%95%E7%9A%84%E7%BB%9F%E8%AE%A1/</id>
    <published>2019-06-04T03:21:21.000Z</published>
    <updated>2019-06-04T15:30:17.712Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>公司没有日志采集平台，又不太可能在业务系统里面搞事情。好在之前有玩过elk日志分析组合。直接从服务器上面撸出日志简单的用linux命令分析下吧。</p></blockquote><p>Nginx日志统计（简单的）</p><p>（日志文件叫access.log 在当前目录下）</p><p><strong>统计 PV，就是日志行数</strong></p><p><code>cat access.log |wc -l</code></p><p><strong>UV, 即是统计 IP 数</strong></p><p><code>cat access.log |awk &#39;{print $1}&#39; |sort |uniq -c |wc -l</code></p><p><strong>使用linux grep 进行统计</strong></p><p><code>grep -E &quot;POST|GET&quot; access.log | awk -F &#39;&quot;&#39; &#39;{print $2,$3}&#39; | awk &#39;{print $2}&#39;| sort | uniq -c | sort -k1nr | head -100</code></p><p><strong>耗时的请求发生时间、所请求的 URI 和耗时</strong></p><p><code>cat access.log | awk &#39;{print $4,$7,$10,$NF}&#39; | sort -k3 -nr | head -100</code></p><p><strong>统计</strong>nginx<strong>访问频次最高的</strong>100<strong>个</strong>Ip**</p><p><code>grep -E &quot;POST|GET&quot; access.log | awk -F &#39;&quot;&#39; &#39;{print $(NF-1)}&#39; | sort | uniq -c | sort -k1nr | head -100</code></p><p><strong>统计</strong>nginx<strong>访问不正常（状态码</strong>400+<strong>）的前</strong>100<strong>个</strong>url<strong>和频次</strong></p><p><code>grep -E &quot;POST|GET&quot; access.log | awk -F &#39;&quot;&#39; &#39;{print $2,$3}&#39; | awk &#39;{if ($4&gt;=&quot;400&quot;) {print $4,$1,$2}}&#39; | sort | uniq -c | sort -k1nr | head -100</code></p><p><strong>统计nginx访问状态码非200的前100个</strong>url<strong>和频次**</strong></p><p><code>grep -E &quot;POST|GET&quot; access.log | awk -F &#39;&quot;&#39; &#39;{print $2,$3}&#39; | awk &#39;{if ($4!=200) {print $4,$1,$2}}&#39; | sort | uniq -c | sort -k1nr | head -100</code></p><p><strong>不同 URI 的平均耗时</strong></p><p><code>grep -E &quot;POST|GET&quot; access.log  | awk &#39;{s[$10] += $NF;c[$10]++}END{for(i in s){print i,s[i]/c[i]}}&#39; |sort -k2 -nr | head</code></p><p><strong>每秒请求量统计</strong></p><p>统计每秒的请求数,top100的时间点(精确到秒)</p><p><code>grep -E &quot;POST|GET&quot; access.log |  awk &#39;{print $4}&#39; access.log |cut -c 14-21|sort|uniq -c|sort -nr|head -n 100</code></p><p><strong>每分钟请求量统计</strong></p><p>统计每分钟的请求数,top100的时间点(精确到分钟)</p><p><code>grep -E &quot;POST|GET&quot; access.log |  awk &#39;{print $4}&#39; access.log |cut -c 14-18|sort|uniq -c|sort -nr|head -n 100</code></p><p><strong>每小时请求量统计</strong></p><p>统计每小时的请求数,top100的时间点(精确到小时)</p><p><code>grep -E &quot;POST|GET&quot; access.log |  awk &#39;{print $4}&#39; access.log |cut -c 14-15|sort|uniq -c|sort -nr|head -n 100</code></p><p><strong>统计蜘蛛抓取次数</strong></p><p><code>grep &#39;Baiduspider&#39; access.log |wc -l</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;公司没有日志采集平台，又不太可能在业务系统里面搞事情。好在之前有玩过elk日志分析组合。直接从服务器上面撸出日志简单的用linux命令分析下吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Nginx日志统计（简单的）&lt;/p&gt;
&lt;p&gt;（日志文件叫ac
      
    
    </summary>
    
    
      <category term="nginx" scheme="https://z201.github.io/categories/nginx/"/>
    
    
      <category term="nginx" scheme="https://z201.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>总结代码风格</title>
    <link href="https://z201.github.io/2019/05/27/%E6%80%BB%E7%BB%93%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    <id>https://z201.github.io/2019/05/27/%E6%80%BB%E7%BB%93%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</id>
    <published>2019-05-27T12:49:08.000Z</published>
    <updated>2020-02-02T12:25:03.743Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>好久没更新博客，最近公司让我出一个代码规范，我吓了一跳。赶忙翻出阿里《 码出高效》，不敢造次，我就补充点个人的想法吧。代码是给人看的。代码风格应该遵循<code>极简主义</code>                                                                                                      </p></blockquote><h3 id="1、避免复杂、追求简单"><a href="#1、避免复杂、追求简单" class="headerlink" title="1、避免复杂、追求简单"></a>1、避免复杂、追求简单</h3><blockquote><p>日常开发中，除了解决业务问题还需要解决许多的工程问题。如何选择当下合适的方法解决问题；需要不断尝试和摸索，没有最好的方法只有更好的方法。</p></blockquote><h3 id="2、合理平滑的处理技术债务"><a href="#2、合理平滑的处理技术债务" class="headerlink" title="2、合理平滑的处理技术债务"></a>2、合理平滑的处理技术债务</h3><blockquote><p>技术的演变速度太快，如何避免长时间的技术债务是非常严重的问题，总之弊大于利。尽可能保持轻装上阵，避免拖油瓶项目。</p><p>关键字：</p><ul><li>一方库: 本工程内部子项目模块依赖的库(jar 包)。 </li><li>二方库: 公司内部发布到中央仓库，可供公司内部其它应用依赖的库(jar包)。 </li><li>三方库: 公司之外的开源库(jar 包)。 </li></ul></blockquote><h4 id="『避免过度封装』"><a href="#『避免过度封装』" class="headerlink" title="『避免过度封装』"></a>『避免过度封装』</h4><blockquote><p>特别是没有完整的技术人员编制的情况下，怎么简单怎么处理（去除中间商赚差价一个道理。）避免过度开发<code>一方库</code>；建议使用原生方式(综合评估代码量)<code>避免框架过度封装</code>。（Java的方法调用链过长是出了名的恶心）</p></blockquote><h4 id="『避免代码过度重复』"><a href="#『避免代码过度重复』" class="headerlink" title="『避免代码过度重复』"></a>『避免代码过度重复』</h4><blockquote><p>每次开发业务都会写很多的代码。定期对公司项目进行基础代码的重构。合理的拆分<code>业务无关的基础代码</code>。</p></blockquote><h4 id="『避免版本混乱』"><a href="#『避免版本混乱』" class="headerlink" title="『避免版本混乱』"></a>『避免版本混乱』</h4><p>使用统一的版本管理。约束所有的项目jar版本依赖。防止因为过度使用<code>三方库</code>出现奇怪的bug。公司<code>bom</code>需要单独处理。尽量保持与社区版本同步，比如springboot最新版是2.1.3 ，那么公司使用的版本最好是近半年的GA版本。</p><h4 id="『物极必反』"><a href="#『物极必反』" class="headerlink" title="『物极必反』"></a>『物极必反』</h4><blockquote><p>请勿过度依赖某框架栈或者解决方式，客观的对比相关解决方案优缺点。</p></blockquote><h4 id="『选择大于努力』"><a href="#『选择大于努力』" class="headerlink" title="『选择大于努力』"></a>『选择大于努力』</h4><blockquote><p>集中精力掌握核心知识。按照目前技术演变的速度，更新最快的是应用技术，其次是行业规范相关技术。最后才是革命性的技术。</p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/%E6%8A%80%E6%9C%AF%E8%B1%A1%E9%99%90%E5%9B%BE.png"></p><a id="more"></a><h3 id="3、指定一种工程结构"><a href="#3、指定一种工程结构" class="headerlink" title="3、指定一种工程结构"></a>3、指定一种工程结构</h3><blockquote><p>统一的工程结构，对开发人员来说如同指路明灯，可以快速的区分相关代码位置。</p></blockquote><h4 id="『阿里巴巴Java开发手册-应用分层』"><a href="#『阿里巴巴Java开发手册-应用分层』" class="headerlink" title="『阿里巴巴Java开发手册-应用分层』"></a>『阿里巴巴Java开发手册-应用分层』</h4><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png"></p><ul><li>开放接口层:可直接封装 Service 方法暴露成 RPC 接口;通过 Web 封装成 http 接口;进行 网关安全控制、流量控制等。 </li><li>终端显示层:各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染， JSP 渲染，移动端展示等。 </li><li>Web 层:主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。 </li><li>Service 层:相对具体的业务逻辑服务层。 </li><li>Manager 层:通用业务处理层，它有如下特征:<ol><li>对第三方平台封装的层，预处理返回结果及转化异常信息;</li><li>对Service层通用能力的下沉，如缓存方案、中间件通用处理; </li><li>与DAO层交互，对多个DAO的组合复用。 </li></ol></li><li>DAO 层:数据访问层，与底层 MySQL、Oracle、Hbase 等进行数据交互。 </li><li>外部接口或第三方平台:包括其它部门RPC开放接口，基础平台，其它公司的HTTP接口。 </li></ul><h4 id="『建议分层方式』"><a href="#『建议分层方式』" class="headerlink" title="『建议分层方式』"></a>『建议分层方式』</h4><blockquote><p>根据工作实际情况，参考阿里的应用分层后适当采纳。</p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/%E5%BB%BA%E8%AE%AE%E5%BA%94%E7%94%A8%E5%88%86%E5%B1%82.png"></p><ul><li><p>开放接口层:可直接封装 Service 方法暴露成 RPC 接口;通过 Web 封装成 http 接口;进行 网关安全控制、流量控制等。 </p></li><li><p><del>终端显示层:各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染， JSP 渲染，移动端展示等</del>  </p></li><li><p><del>Web 层:主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等</del>  </p></li><li><p>Service 层:相对具体的业务逻辑服务层。 </p></li><li><p>Manager 层:通用业务处理层，它有如下特征:</p><ol><li><p>对第三方平台封装的层，预处理返回结果及转化异常信息。</p></li><li><p>对Service层通用能力的下沉，如缓存方案、中间件通用处理。</p></li><li><p>与DAO层交互，对多个DAO的组合复用。 </p></li></ol></li><li><p>DAO 层:数据访问层，与底层 MySQL、Oracle、Hbase 等进行数据交互。 </p></li><li><p>外部接口或第三方平台:包括其它部门RPC开放接口，基础平台，其它公司的HTTP接口。</p></li></ul><blockquote><p>目前Java已经不写前端代码，所以终端显示层和Web已经没有使用的价值。这里需要额外的注意，开放接口层不需要任何的业务操作，方便做完整的单元测试。将参数校验等操作放在具体业务执行的过程中。</p></blockquote><h4 id="『建议分层异常处理方式』"><a href="#『建议分层异常处理方式』" class="headerlink" title="『建议分层异常处理方式』"></a>『建议分层异常处理方式』</h4><ul><li>(分层异常处理规约)在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行catch，使用catch(Exception e)方式，并throw new xxxException(e)，不需要打印日志，因为日志在 Manager/Service 层一定需要捕获并打印到日志文件中去，如果同台服务器再打日志，浪费性能和存储。<code>在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场</code>。如果 Manager 层与 Service 同机部署，日志方式与 DAO层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。</li></ul><h4 id="『分层领域模型规约』"><a href="#『分层领域模型规约』" class="headerlink" title="『分层领域模型规约』"></a>『分层领域模型规约』</h4><ul><li>DO(Data Object):此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。 </li><li>DTO(Data Transfer Object):数据传输对象，Service 或 Manager 向外传输的对象。 </li><li>BO(Business Object):业务对象，由 Service 层输出的封装业务逻辑的对象。 </li><li><del>AO(ApplicationObject):应用对象，在Web层与Service层之间抽象的复用对象模型， 极为贴近展示层，复用度不高</del>。</li><li><del>VO(View Object):显示层对象，通常是 Web 向模板渲染引擎层传输的对象</del>。</li><li><del>Query:数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的建议查询封装，<code>禁止使用 Map 类来传输</code>。</del> </li></ul><blockquote><p>没有必要过度设计、导致代码量增加。DTO、AO、VO Query 在实际开发过程实际上可以完全复用。Query是查询参数,通常用于用户分页查询和普通参数查询等封装体。BO需要高度抽象，属于业务模型。目前接口数据显示要求不高的情况可以适当放宽，不使用 BO层。</p></blockquote><h4 id="『分层参考』"><a href="#『分层参考』" class="headerlink" title="『分层参考』"></a>『分层参考』</h4><ul><li>推荐的参考</li></ul><blockquote><p>主目录示例:com.github.z201.pre</p><ul><li>com.github.z201   公司域名(这只是例子)</li><li>pre               项目名称</li><li>dao              模块名称</li></ul><p>模块示例:com.github.z201.pre</p><ul><li>dao     #mybaits接口映射层</li><li>entity  # mysql表映射层</li><li>dto      # 网络传输层</li><li>manger # 第三方（缓存、事务、mp、外部接口）</li><li>service  # 主要业务实现（无事务处理、简单业务）</li><li>utils       # 项目工具类（该项目独立使用的）</li></ul><p>对于该模块关键模块，建议单独区分，用于识别。按照黄金法则，一个模块中核心接口少数。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(develop) ✗ tree src/main -d -L 7</span><br><span class="line">src/main</span><br><span class="line">├── java</span><br><span class="line">│   └── com</span><br><span class="line">│       └── github</span><br><span class="line">│           └── z201</span><br><span class="line">│               └── pre</span><br><span class="line">│                   ├── annotation <span class="comment"># 关键业务（注解拦截层）</span></span><br><span class="line">│                   ├── dao        <span class="comment"># mybaits接口映射层</span></span><br><span class="line">│                   ├── entity     <span class="comment"># 实体映射层</span></span><br><span class="line">│                   ├── dto     </span><br><span class="line">│                   │   ├── cache <span class="comment"># 缓存传输层</span></span><br><span class="line">│                   │   ├── param  <span class="comment"># 请求参数封装体（Query的细化）</span></span><br><span class="line">│                   │   ├── result <span class="comment"># 响应参数封装体</span></span><br><span class="line">│                   │   └── search <span class="comment"># 查询参数封装体（Query的细化）</span></span><br><span class="line">│                   ├── <span class="built_in">limit</span>      <span class="comment"># 关键业务实现（关键业务不建议放到service层，方便快速识别。）</span></span><br><span class="line">│                   │   └── impl</span><br><span class="line">│                   ├── manger     <span class="comment"># 第三方（缓存、事务、mp、外部接口）</span></span><br><span class="line">│                   │   └── impl   <span class="comment"># 实现类</span></span><br><span class="line">│                   ├── service    <span class="comment"># 主要业务实现（无事务处理）</span></span><br><span class="line">│                   │   └── impl   <span class="comment"># 实现类</span></span><br><span class="line">│                   └── utils      <span class="comment"># 项目工具类（该项目独立使用的）</span></span><br><span class="line">│                       └── common  </span><br><span class="line">│                       </span><br><span class="line">└── resource</span><br><span class="line">    └── mapper <span class="comment"># mybatis文件。</span></span><br></pre></td></tr></table></figure><h3 id="4、保持代码的整洁"><a href="#4、保持代码的整洁" class="headerlink" title="4、保持代码的整洁"></a>4、保持代码的整洁</h3><blockquote><p>写出运行代码（bug）是简单的、写出适合阅读的代码是困难，建议阅读<code>阿里巴巴Java开发手册</code> 以及<code>码出高效Java开发手册</code>相关章节。这里做下内容补充。</p></blockquote><h4 id="『尽可能少写代码』"><a href="#『尽可能少写代码』" class="headerlink" title="『尽可能少写代码』"></a>『尽可能少写代码』</h4><blockquote><p>写的越多错的越多，错的越多修复越难。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用lombok语法糖，简化模版代码。</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmSpaceFunctionCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片主键id（使用运营后台 sm_admin_pictrue表存储图片)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer adminPictureId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String picPath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序 默认 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer orderBy;</span><br><span class="line"><span class="comment">// 无 get 、 set 更多特性请查阅lombok使用方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="『提高代码覆盖率』"><a href="#『提高代码覆盖率』" class="headerlink" title="『提高代码覆盖率』"></a>『提高代码覆盖率』</h4><blockquote><p>（避免无调用代码，避免过度使用代码生成器）健壮的代码是干净、简洁的。避免重型项目出现（保持项目业务代码1-2W行，可以适当的模块化）</p></blockquote><h4 id="『合理拆分代码逻辑』"><a href="#『合理拆分代码逻辑』" class="headerlink" title="『合理拆分代码逻辑』"></a>『合理拆分代码逻辑』</h4><blockquote><p>（避免代码过度优化和过早优化，<code>需求一定会改、一定会改、一定会改</code>）适当调整代码，保证阅读方便即可。推荐使用阿里<code>p3c</code>代码检查工具。鬼故事：李光磊以前劝华为的同事用Eclipse，人家打死不肯用。他自己搞起来，给人家说，你看，多方便。华为的同时默默的输入了一个文件名，跳过去，Eclipse崩贵了，文件太大。</p></blockquote><h4 id="『更新注释』"><a href="#『更新注释』" class="headerlink" title="『更新注释』"></a>『更新注释』</h4><blockquote><p>代码千万行，注释第一行。注释不规范，同事两行泪。改代码不改注释非常容易误导他人。尽可能保持个人代码的注释信息合理。</p></blockquote><h4 id="『面向接口编程』"><a href="#『面向接口编程』" class="headerlink" title="『面向接口编程』"></a>『面向接口编程』</h4><blockquote><ul><li>面向接口编程和面向对象编程并不是平级的，它并不是比面向对象编程更先进的一种独立的编程思想，而是附属于面向对象思想体系，属于其一部分。或者说，它是面向对象编程体系中的思想精髓之一。</li><li>在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了；而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。</li></ul></blockquote><ul><li>降低程序的耦合性。在程序中紧密的联系并不是一件好的事情，因为两种事物之间联系越紧密，更换其中之一的难度就越大，扩展功能和debug的难度也就越大。 </li><li>易于程序的扩展。</li><li>有利于程序的维护。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 示例代码,在接口暴露层，是不建议做任何的业务操作。建议使用bean封装数据。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(FunctionController.ROUTER_INDEX)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionController</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTER_INDEX = <span class="string">"/api/space"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    PackageFunctionServiceI packageFunctionService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取功能分页列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/function/list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">listSpaceFunction</span><span class="params">(@RequestBody SpacePackageFunctionSearch pageSearch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> packageFunctionService.listSpaceFunction(pageSearch);</span><br><span class="line">    &#125;</span><br><span class="line">  .....</span><br></pre></td></tr></table></figure><ul><li>if/for/while/switch/do等保留字与左右括号之间都必须加空格。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 合理的增加空格，方便阅读代码。</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == endTime || <span class="number">0L</span> == endTime) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"获取用户vip的到期时间失败了，数据出现异常。～～～"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、防御式编程"><a href="#5、防御式编程" class="headerlink" title="5、防御式编程"></a>5、防御式编程</h3><ul><li>请不要相信任何参数。尽可能保持客观的态度编写代码。参考&lt;&lt;代码大全&gt;&gt; <code>『人类都是不安全、不值得信任的，所有的人，都会犯错误，而你写的代码，应该考虑到所有可能发生的错误，让你的程序不会因为他人的错误而发生错误』</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是从内部接口调用的数据，首先不信任给的数据。避免常规错误导致自己的逻辑出现明显的bug。</span></span><br><span class="line"><span class="comment">// 获取vip的到期时间</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  endTime = spaceVipCacheService.getSpaceVipEndTimeByUserId(userId);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">  log.warn(<span class="string">"获取用户vip的到期时间失败了，系统出现异常。～～～ "</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"获取用户vip的到期时间失败了，系统出现异常。～～～"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == endTime || <span class="number">0L</span> == endTime) &#123;</span><br><span class="line">  log.warn(<span class="string">"获取用户vip的到期时间失败了，系统出现异常。～～～ "</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"获取用户vip的到期时间失败了，数据出现异常。～～～"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、抛异常-or-返回错误码-or-日志"><a href="#6、抛异常-or-返回错误码-or-日志" class="headerlink" title="6、抛异常 or 返回错误码 or 日志"></a>6、抛异常 or 返回错误码 or 日志</h3><blockquote><p>公司外的http/api开放接口必须使用“错误码”；应用内部推荐异常抛出(适当抛出堆栈，性能影响)。避免恶意请求接口，并通过返回消息猜出接口参数的问题。日志文件推荐至少保存15天，因为有些异常具备以“周”为频次发生的特点。</p></blockquote><ul><li>就java日志框架而言，建议使用侨接slf4j来输出日志。<ul><li>当遇到问题的时候，只能功过debug功能来确定问题。应该考虑输出日志信息，良好的系统日志信息对问题进行定位的。</li><li>项目中大量的分支判断if \else、switch 的分支时候使用日志可以定位具体是哪个业务流程。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尽可能参数化日志信息，日志是给人看的。不是为了输出而输出。关键参数可以隔离显示比如 [&#123;&#125;]</span></span><br><span class="line">logger.debug(<span class="string">"这是一条debug日志 [&#123;&#125;]"</span> , userId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于debug日志，必须判断日志的级别才能进行输出。</span></span><br><span class="line"><span class="keyword">if</span>(logger.isDebugEnabled())&#123;</span><br><span class="line">  logger.debug(<span class="string">"这是一条debug日志 [&#123;&#125;]"</span> , userId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免使用字符串拼接的方式输出日志，这样会导致生产了很多的string对象。</span></span><br><span class="line">logger.debug(<span class="string">"这是一条字符串拼接的日志输出 : ["</span>  + userId +<span class="string">"]"</span>);</span><br></pre></td></tr></table></figure><ul><li>日志级别的使用<ul><li><code>日志级别 trace, debug, info, warn, error, fatal</code></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 这里以log4j相关的日志的打印级别，OFF即不打印，其他则按照标准级别配置即可，如 debug </span><br><span class="line">       关闭：OFF(0)</span><br><span class="line">致命：FATAL(100)，对应Logger.fatal方法</span><br><span class="line">错误：ERROR(200)，对应Logger.error方法</span><br><span class="line">警告：WARN(300)，对应Logger.warn方法</span><br><span class="line">信息：INFO(400)，对应Logger.info方法</span><br><span class="line">调试：DEBUG(500)，对应Logger.debug方法</span><br><span class="line">跟踪：TRACE(600)，对应Logger.trace方法</span><br><span class="line">全部：ALL(Integer.MAX_VALUE)</span><br><span class="line">当指定某一个级别时，比如DEBUG，那么所有低于这个级别的其它级别日志，都会被打印。</span><br><span class="line">当指定级别为DEBUG时，Logger.debug、Logger.info、Logger.warn、Logger.error以及Logger.fatal等方法</span><br><span class="line">都能输出日志，但Logger.trace无法输出日志。</span><br></pre></td></tr></table></figure><ul><li>error：对于影响到程序正常运行的信息，需要及时补货并输出，适用范围<code>配置文件读取失败、第三方调用失败、数据库连接失败、缓存等关键组件失败异常</code></li></ul><h3 id="7、方法命名、变量命名"><a href="#7、方法命名、变量命名" class="headerlink" title="7、方法命名、变量命名"></a>7、方法命名、变量命名</h3><blockquote><p>建议阅读<code>阿里巴巴Java开发手册</code> 以及<code>码出高效Java开发手册</code>相关章节。这里做下内容补充。</p></blockquote><ul><li><p>变量命名</p><blockquote><p>如果想不到合适的变量名字，麻烦把注释写清楚。如果连思考的时间都没有请使用TODO标记。</p></blockquote></li><li><p>service层</p><blockquote><p>如果想不到合适的方法名字，麻烦把注释写全。如果连思考的时间都没有请使用TODO标记。</p></blockquote></li><li><p>Dao层</p><blockquote><p>如果是批量建议加上Batch。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">获取单个对象 &#96;getXxx&#96;</span><br><span class="line">获取多个对象&#96;listXxx&#96;</span><br><span class="line">通过复杂的查询&#96;listXxxBySearch&#96;这里的&#96;search&#96;就是参数封装体</span><br><span class="line">获取统计值 &#96;countXxx&#96;</span><br><span class="line">插入&#96;saveXxx&#96; &#x2F; &#96;insertXxx&#96;</span><br><span class="line">删除 &#96;removeXxx&#96; &#x2F; &#96;deleteXxx&#96;</span><br><span class="line">修改 &#96;updateXxx&#96;</span><br></pre></td></tr></table></figure><h3 id="8、Redis"><a href="#8、Redis" class="headerlink" title="8、Redis"></a>8、Redis</h3><ul><li>key名设计</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#建议：可读性和可管理性（redis作为标准缓存时推荐）</span><br><span class="line">#以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</span><br><span class="line">ugc:video:1</span><br><span class="line"></span><br><span class="line">#简洁性</span><br><span class="line">#建议：保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</span><br><span class="line">user:&#123;uid&#125;:friends:messages:&#123;mid&#125;简化为u:&#123;uid&#125;:fr:m:&#123;mid&#125;。</span><br><span class="line"></span><br><span class="line">#强制：不要包含特殊字符</span><br><span class="line">反例：包含空格、换行、单双引号以及其他转义字符</span><br></pre></td></tr></table></figure><ul><li>value设计</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 强制：拒绝bigkey(防止网卡流量、慢查询)</span><br><span class="line">string类型控制在20KB以内，hash、list、set、zset元素个数不要超过5000，这里指的是field(不是key)。</span><br><span class="line"># 反例：一个包含200万个元素的list。</span><br><span class="line">非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))。</span><br><span class="line"></span><br><span class="line"># 建议- 选择适合的数据类型。</span><br><span class="line">例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如ziplist，但也要注意节省内存和性能之间的平衡)</span><br><span class="line"></span><br><span class="line"># 反例</span><br><span class="line">set user:1:name tom</span><br><span class="line">set user:1:age 19</span><br><span class="line">set user:1:favor football</span><br><span class="line"></span><br><span class="line">改进</span><br><span class="line">hmset user:1 name tom age 19 favor football</span><br></pre></td></tr></table></figure><ul><li>控制key的生命周期，redis不是垃圾桶。</li></ul><p><code>建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime。</code></p><ul><li>【建议】：禁用命令</li></ul><p>禁止线上（正式环境）使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。</p><ul><li>【建议】使用批量操作提高效率</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原生命令：例如mget、mset。</span><br><span class="line">非原生命令：可以使用pipeline提高效率。</span><br><span class="line">但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。</span><br><span class="line">注意两者不同：</span><br><span class="line">1. 原生是原子操作，pipeline是非原子操作。</span><br><span class="line">2. pipeline可以打包不同的命令，原生做不到。</span><br><span class="line">3. pipeline需要客户端和服务端同时支持。</span><br></pre></td></tr></table></figure><ul><li>【建议】Redis（伪）事务功能较弱，不建议过多使用</li></ul><p>Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot上(可以使用hashtag功能解决)。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;好久没更新博客，最近公司让我出一个代码规范，我吓了一跳。赶忙翻出阿里《 码出高效》，不敢造次，我就补充点个人的想法吧。代码是给人看的。代码风格应该遵循&lt;code&gt;极简主义&lt;/code&gt;                                                                                                      &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1、避免复杂、追求简单&quot;&gt;&lt;a href=&quot;#1、避免复杂、追求简单&quot; class=&quot;headerlink&quot; title=&quot;1、避免复杂、追求简单&quot;&gt;&lt;/a&gt;1、避免复杂、追求简单&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;日常开发中，除了解决业务问题还需要解决许多的工程问题。如何选择当下合适的方法解决问题；需要不断尝试和摸索，没有最好的方法只有更好的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2、合理平滑的处理技术债务&quot;&gt;&lt;a href=&quot;#2、合理平滑的处理技术债务&quot; class=&quot;headerlink&quot; title=&quot;2、合理平滑的处理技术债务&quot;&gt;&lt;/a&gt;2、合理平滑的处理技术债务&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;技术的演变速度太快，如何避免长时间的技术债务是非常严重的问题，总之弊大于利。尽可能保持轻装上阵，避免拖油瓶项目。&lt;/p&gt;
&lt;p&gt;关键字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一方库: 本工程内部子项目模块依赖的库(jar 包)。 &lt;/li&gt;
&lt;li&gt;二方库: 公司内部发布到中央仓库，可供公司内部其它应用依赖的库(jar包)。 &lt;/li&gt;
&lt;li&gt;三方库: 公司之外的开源库(jar 包)。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;『避免过度封装』&quot;&gt;&lt;a href=&quot;#『避免过度封装』&quot; class=&quot;headerlink&quot; title=&quot;『避免过度封装』&quot;&gt;&lt;/a&gt;『避免过度封装』&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;特别是没有完整的技术人员编制的情况下，怎么简单怎么处理（去除中间商赚差价一个道理。）避免过度开发&lt;code&gt;一方库&lt;/code&gt;；建议使用原生方式(综合评估代码量)&lt;code&gt;避免框架过度封装&lt;/code&gt;。（Java的方法调用链过长是出了名的恶心）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;『避免代码过度重复』&quot;&gt;&lt;a href=&quot;#『避免代码过度重复』&quot; class=&quot;headerlink&quot; title=&quot;『避免代码过度重复』&quot;&gt;&lt;/a&gt;『避免代码过度重复』&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;每次开发业务都会写很多的代码。定期对公司项目进行基础代码的重构。合理的拆分&lt;code&gt;业务无关的基础代码&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;『避免版本混乱』&quot;&gt;&lt;a href=&quot;#『避免版本混乱』&quot; class=&quot;headerlink&quot; title=&quot;『避免版本混乱』&quot;&gt;&lt;/a&gt;『避免版本混乱』&lt;/h4&gt;&lt;p&gt;使用统一的版本管理。约束所有的项目jar版本依赖。防止因为过度使用&lt;code&gt;三方库&lt;/code&gt;出现奇怪的bug。公司&lt;code&gt;bom&lt;/code&gt;需要单独处理。尽量保持与社区版本同步，比如springboot最新版是2.1.3 ，那么公司使用的版本最好是近半年的GA版本。&lt;/p&gt;
&lt;h4 id=&quot;『物极必反』&quot;&gt;&lt;a href=&quot;#『物极必反』&quot; class=&quot;headerlink&quot; title=&quot;『物极必反』&quot;&gt;&lt;/a&gt;『物极必反』&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;请勿过度依赖某框架栈或者解决方式，客观的对比相关解决方案优缺点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;『选择大于努力』&quot;&gt;&lt;a href=&quot;#『选择大于努力』&quot; class=&quot;headerlink&quot; title=&quot;『选择大于努力』&quot;&gt;&lt;/a&gt;『选择大于努力』&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;集中精力掌握核心知识。按照目前技术演变的速度，更新最快的是应用技术，其次是行业规范相关技术。最后才是革命性的技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/%E6%8A%80%E6%9C%AF%E8%B1%A1%E9%99%90%E5%9B%BE.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件工程" scheme="https://z201.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>idea常用插件</title>
    <link href="https://z201.github.io/2019/05/08/idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://z201.github.io/2019/05/08/idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</id>
    <published>2019-05-08T08:35:04.000Z</published>
    <updated>2019-05-08T15:56:05.247Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有必要记录下自己常用的插件，避免特殊事件的发生。</p></blockquote><h4 id="Free-Mybatis-plugin"><a href="#Free-Mybatis-plugin" class="headerlink" title="Free Mybatis plugin"></a>Free Mybatis plugin</h4><blockquote><p>Mybatis 插件，可以定位java和xml关系。通过java接口快速生成相关xml文件或者方法。</p></blockquote><h4 id="Mybaits-Log-plugin"><a href="#Mybaits-Log-plugin" class="headerlink" title="Mybaits Log plugin"></a>Mybaits Log plugin</h4><blockquote><p>使用插件将mybaits默认的日志输出转换成可以运行的sql日志。</p></blockquote><h4 id="Alibaba-java-coding-guidelines"><a href="#Alibaba-java-coding-guidelines" class="headerlink" title="Alibaba-java-coding-guidelines"></a>Alibaba-java-coding-guidelines</h4><blockquote><p>阿里巴巴java代码检查工具</p></blockquote><h4 id="json2pojo"><a href="#json2pojo" class="headerlink" title="json2pojo"></a>json2pojo</h4><blockquote><p>json转bean的工具</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有必要记录下自己常用的插件，避免特殊事件的发生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;Free-Mybatis-plugin&quot;&gt;&lt;a href=&quot;#Free-Mybatis-plugin&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Idea" scheme="https://z201.github.io/tags/Idea/"/>
    
  </entry>
  
  <entry>
    <title>idea快捷键练习</title>
    <link href="https://z201.github.io/2019/05/06/idea%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%BB%83%E4%B9%A0/"/>
    <id>https://z201.github.io/2019/05/06/idea%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%BB%83%E4%B9%A0/</id>
    <published>2019-05-06T01:37:48.000Z</published>
    <updated>2019-05-27T07:11:51.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每次都需要重新去查阅文档，不如整理一下idea常用的快捷键</p></blockquote><h4 id="查看某个方法被调用的地方。-鼠标选中方法名称"><a href="#查看某个方法被调用的地方。-鼠标选中方法名称" class="headerlink" title="查看某个方法被调用的地方。(鼠标选中方法名称)"></a>查看某个方法被调用的地方。(鼠标选中方法名称)</h4><p><code>Navigate | Call Hierarchy </code> 快捷键<code>control + option + h</code></p><h4 id="Genterate-代码生成"><a href="#Genterate-代码生成" class="headerlink" title="Genterate 代码生成"></a>Genterate 代码生成</h4><p><code>Code | Genterate</code> #快捷键 <code>command + n</code></p><h4 id="Copyright-模版"><a href="#Copyright-模版" class="headerlink" title="Copyright 模版"></a>Copyright 模版</h4><p><code>Edit | Copyright | Copyright profiles </code></p><ul><li>样板</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyright (c) $today.year  </span><br><span class="line">@Author:z201.coding@gamil.com</span><br><span class="line">@LastModified:$today.format(&quot;yyyy-MM-dd&quot;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="快捷搜索"><a href="#快捷搜索" class="headerlink" title="快捷搜索"></a>快捷搜索</h4><p><code>shift 两次</code></p><h4 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h4><p><code>command + shift + f</code></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;每次都需要重新去查阅文档，不如整理一下idea常用的快捷键&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;查看某个方法被调用的地方。-鼠标选中方法名称&quot;&gt;&lt;a href=&quot;#查看某个方法被调用的地方。-鼠标选中方法名称&quot; class=&quot;headerlink&quot; title=&quot;查看某个方法被调用的地方。(鼠标选中方法名称)&quot;&gt;&lt;/a&gt;查看某个方法被调用的地方。(鼠标选中方法名称)&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Navigate | Call Hierarchy &lt;/code&gt; 快捷键&lt;code&gt;control + option + h&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;Genterate-代码生成&quot;&gt;&lt;a href=&quot;#Genterate-代码生成&quot; class=&quot;headerlink&quot; title=&quot;Genterate 代码生成&quot;&gt;&lt;/a&gt;Genterate 代码生成&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Code | Genterate&lt;/code&gt; #快捷键 &lt;code&gt;command + n&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;Copyright-模版&quot;&gt;&lt;a href=&quot;#Copyright-模版&quot; class=&quot;headerlink&quot; title=&quot;Copyright 模版&quot;&gt;&lt;/a&gt;Copyright 模版&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Edit | Copyright | Copyright profiles &lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;样板&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Copyright (c) $today.year  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Author:z201.coding@gamil.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@LastModified:$today.format(&amp;quot;yyyy-MM-dd&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Idea" scheme="https://z201.github.io/tags/Idea/"/>
    
  </entry>
  
  <entry>
    <title>源码分析-skywalking源码环境搭建</title>
    <link href="https://z201.github.io/2019/04/21/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-skywalking%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://z201.github.io/2019/04/21/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-skywalking%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2019-04-21T10:40:55.000Z</published>
    <updated>2019-04-22T16:03:29.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-阅读源代码"><a href="#0x00-阅读源代码" class="headerlink" title="0x00 阅读源代码"></a>0x00 阅读源代码</h2><blockquote><p>长达9天的断网终于结束了。</p></blockquote><h3 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h3><ul><li>代码仓库地址 <a href="https://gitee.com/Z201/skywalking.git" target="_blank" rel="noopener">https://gitee.com/Z201/skywalking.git</a></li><li>阅读版本号 <code>v6.0.0-GA</code></li><li>下载版本<code>git clone -b v6.0.0-GA https://github.com/apache/skywalking.git</code><ul><li>由于github下载速度是在太慢了，这里用gitee克隆一个镜像。</li><li>下载版本<code>git clone -b v6.0.0-GA https://gitee.com/Z201/skywalking.git</code></li></ul></li></ul><h3 id="查看源代码结构"><a href="#查看源代码结构" class="headerlink" title="查看源代码结构"></a>查看源代码结构</h3><blockquote><p>源码设计子项目过多，这里简单暂时2级目录。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tree -d L 2</span><br><span class="line">.</span><br><span class="line">├── src  </span><br><span class="line">│   ├── main # 源代码</span><br><span class="line">│   ├── site # 站点稳当</span><br><span class="line">│   └── test # 单元测试</span><br><span class="line">└── travis   # 官方的ci集成</span><br></pre></td></tr></table></figure><ul><li>查看项目源码主目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  skywalking git:(8b638258b) tree -d -L 1</span><br><span class="line">.</span><br><span class="line">├── apm-application-toolkit</span><br><span class="line">├── apm-checkstyle</span><br><span class="line">├── apm-commons</span><br><span class="line">├── apm-dist</span><br><span class="line">├── apm-protocol <span class="comment"># pd文件</span></span><br><span class="line">├── apm-sniffer <span class="comment"># 插件</span></span><br><span class="line">├── apm-webapp  </span><br><span class="line">├── docker</span><br><span class="line">├── docs</span><br><span class="line">├── licenses</span><br><span class="line">├── oap-server <span class="comment"># 这里和5.x 有很大的不同改动了很多东西。</span></span><br><span class="line">├── skywalking-ui </span><br><span class="line">└── tools</span><br></pre></td></tr></table></figure><ul><li>将项目导入idea中。</li></ul><p>官方文档:<a href="https://github.com/apache/skywalking/blob/master/docs/en/guides/How-to-build.md" target="_blank" rel="noopener">如何构建</a></p><p><code>git submodule init</code></p><p><code>git submodule update</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  skywalking git:(8b638258b) git submodule init</span><br><span class="line">Submodule <span class="string">'apm-protocol/apm-network/src/main/proto'</span> (https://github.com/apache/incubator-skywalking-data-collect-protocol.git) registered <span class="keyword">for</span> path <span class="string">'apm-protocol/apm-network/src/main/proto'</span></span><br><span class="line">Submodule <span class="string">'oap-server/server-query-plugin/query-graphql-plugin/src/main/resources/query-protocol'</span> (https://github.com/apache/incubator-skywalking-query-protocol.git) registered <span class="keyword">for</span> path <span class="string">'oap-server/server-query-plugin/query-graphql-plugin/src/main/resources/query-protocol'</span></span><br><span class="line">Submodule <span class="string">'skywalking-ui'</span> (https://github.com/apache/incubator-skywalking-ui) registered <span class="keyword">for</span> path <span class="string">'skywalking-ui'</span></span><br><span class="line">➜  skywalking git:(8b638258b) git submodule update</span><br><span class="line">Cloning into <span class="string">'/Users/zengqingfeng/word/source-code/skywalking/apm-protocol/apm-network/src/main/proto'</span>...</span><br><span class="line">Cloning into <span class="string">'/Users/zengqingfeng/word/source-code/skywalking/oap-server/server-query-plugin/query-graphql-plugin/src/main/resources/query-protocol'</span>...</span><br><span class="line">Cloning into <span class="string">'/Users/zengqingfeng/word/source-code/skywalking/skywalking-ui'</span>...</span><br><span class="line">Submodule path <span class="string">'apm-protocol/apm-network/src/main/proto'</span>: checked out <span class="string">'b66fa070fd647662f06497e4ed3657eb258cb6e9'</span></span><br><span class="line">Submodule path <span class="string">'oap-server/server-query-plugin/query-graphql-plugin/src/main/resources/query-protocol'</span>: checked out <span class="string">'c65a23bd6b9bba8d1df30d4de261624952df2b7b'</span></span><br><span class="line">Submodule path <span class="string">'skywalking-ui'</span>: checked out <span class="string">'c44642f73b9f73a54b0d716cade5094304e1a67b'</span></span><br></pre></td></tr></table></figure><p><code>clean package -DskipTests</code></p><blockquote><p>这个时候慢慢等吧v6.0.0-GA有120个子项目。更新完之后导入IDEA就好了。</p></blockquote><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-阅读源代码&quot;&gt;&lt;a href=&quot;#0x00-阅读源代码&quot; class=&quot;headerlink&quot; title=&quot;0x00 阅读源代码&quot;&gt;&lt;/a&gt;0x00 阅读源代码&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;长达9天的断网终于结束了。&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
    
      <category term="源码分析" scheme="https://z201.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>关于spring.redis.timeout=0依然超时的问题</title>
    <link href="https://z201.github.io/2019/04/10/%E5%85%B3%E4%BA%8Espring-redis-timeout-0%E4%BE%9D%E7%84%B6%E8%B6%85%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://z201.github.io/2019/04/10/%E5%85%B3%E4%BA%8Espring-redis-timeout-0%E4%BE%9D%E7%84%B6%E8%B6%85%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2019-04-10T14:16:10.000Z</published>
    <updated>2019-04-10T17:08:41.240Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在看项目的时候发现一个临时问题，就是redis.timeout设置0依然超时的问题。</p></blockquote><ul><li>代码适用版本 <code>jedis:2.9.0</code> , <code>org.springframework.data.redis:1.8.1</code></li></ul><h3 id="timeout设置0的问题"><a href="#timeout设置0的问题" class="headerlink" title="timeout设置0的问题"></a>timeout设置0的问题</h3><blockquote><p>spring.redis.timeout =0 如果设置成0 redis默认超时时间就是2秒. </p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/Jedis/jedis-timeout-1.jpg"></p><blockquote><p>根据debug发现设置0点时候依然是2000毫秒。</p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/Jedis/jedis-timeout-2.jpg"></p><blockquote><p>根据初始化方法找到的原因。</p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/Jedis/jedis-timeout-3.png"></p><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/Jedis/jedis-timeout-4.png"></p><blockquote><p>这里可以看到，当timeout设置0点时候不会被赋值。</p></blockquote><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在看项目的时候发现一个临时问题，就是redis.timeout设置0依然超时的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;代码适用版本 &lt;code&gt;jedis:2.9.0&lt;/code&gt; , &lt;code&gt;org.springfr
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Redis" scheme="https://z201.github.io/tags/Redis/"/>
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://z201.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>实践-annotation-aop</title>
    <link href="https://z201.github.io/2019/04/08/%E5%AE%9E%E8%B7%B5-annotation-aop/"/>
    <id>https://z201.github.io/2019/04/08/%E5%AE%9E%E8%B7%B5-annotation-aop/</id>
    <published>2019-04-08T01:42:50.000Z</published>
    <updated>2019-04-10T15:51:47.645Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>整理一下以前的学习代码。</p></blockquote><h3 id="Spring-Aop"><a href="#Spring-Aop" class="headerlink" title="Spring Aop"></a>Spring Aop</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lmbok.version</span>&gt;</span>1.18.4<span class="tag">&lt;/<span class="name">lmbok.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logback.version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">logback.version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- pom文件需要指定打包编码集，[WARNING] File encoding has not been set, using platform encoding GBK, i.e. build is platform dependent!  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lmbok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于注解的aop实现"><a href="#基于注解的aop实现" class="headerlink" title="基于注解的aop实现"></a>基于注解的aop实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.z201.io.annotation.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> z201.coding@gmail.com</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationAop &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.z201.io.annotation.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> z201.coding@gmail.com</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogsAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(cn.z201.io.annotation.aop.AnnotationAop)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cutMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知：目标方法抛出异常时执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"cutMethod()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"  after throwing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知：灵活自由的在目标方法中切入代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"cutMethod()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 获取目标方法的名称</span></span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        <span class="comment">// 获取方法传入参数</span></span><br><span class="line">        Object[] params = joinPoint.getArgs();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != params &amp;&amp; params.length != <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">" method name "</span> + methodName + <span class="string">" args "</span> + params[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行源方法</span></span><br><span class="line">        AnnotationAop annotationAop = getDeclaredAnnotation(joinPoint);</span><br><span class="line">        System.out.println(<span class="string">"  annotationAop  value "</span> + annotationAop.value());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取方法中声明的注解</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchMethodException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnnotationAop <span class="title">getDeclaredAnnotation</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取方法名</span></span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        <span class="comment">// 反射获取目标类</span></span><br><span class="line">        Class&lt;?&gt; targetClass = joinPoint.getTarget().getClass();</span><br><span class="line">        <span class="comment">// 拿到方法对应的参数类型</span></span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = ((MethodSignature) joinPoint.getSignature()).getParameterTypes();</span><br><span class="line">        <span class="comment">// 根据类、方法、参数类型（重载）获取到方法的具体信息</span></span><br><span class="line">        Method objMethod = targetClass.getMethod(methodName, parameterTypes);</span><br><span class="line">        <span class="comment">// 拿到方法定义的注解信息</span></span><br><span class="line">        AnnotationAop annotation = objMethod.getDeclaredAnnotation(AnnotationAop<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> annotation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.z201.io.annotation.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> z201.coding@gmail.com</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationApp</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AnnotationApp<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.z201.io.annotation.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> z201.coding@gmail.com</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">""</span>)</span><br><span class="line">    <span class="meta">@AnnotationAop</span>(<span class="string">"Aop"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        modelAndView.addObject(<span class="string">"value"</span>, <span class="string">"hello annotationApp  "</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView.getModelMap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果</p><p>​    控制台 annotationAop  value Aop</p><p>​        响应 <strong>{</strong>“value”: “hello annotationApp  “<strong>}</strong></p></blockquote><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;整理一下以前的学习代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Spring-Aop&quot;&gt;&lt;a href=&quot;#Spring-Aop&quot; class=&quot;headerlink&quot; title=&quot;Spring Aop&quot;&gt;&lt;/a&gt;Spring Ao
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://z201.github.io/tags/Spring/"/>
    
      <category term="Aop" scheme="https://z201.github.io/tags/Aop/"/>
    
  </entry>
  
  <entry>
    <title>初探Grpc</title>
    <link href="https://z201.github.io/2019/04/03/%E5%88%9D%E6%8E%A2Grpc/"/>
    <id>https://z201.github.io/2019/04/03/%E5%88%9D%E6%8E%A2Grpc/</id>
    <published>2019-04-03T14:18:34.000Z</published>
    <updated>2019-05-06T01:28:57.386Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>17年年底做的技术调研，文档好想没有写完。</p></blockquote><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC "></a><a href="https://github.com/grpc/grpc" target="_blank" rel="noopener">gRPC </a></h2><h3 id="流程概念"><a href="#流程概念" class="headerlink" title="流程概念"></a>流程概念</h3><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/Grpc/grpc-1.png"></p><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/Grpc/grpc-2.png"></p><h3 id="谁在使用"><a href="#谁在使用" class="headerlink" title="谁在使用"></a>谁在使用</h3><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/Grpc/grpc-3.png"></p><a id="more"></a><h2 id="ProtoBuf"><a href="#ProtoBuf" class="headerlink" title="ProtoBuf"></a>ProtoBuf</h2><blockquote><p>Protocol Buffers 是 google 的一种数据交换的格式，它独立于语言，独立于平台。google 提供了多种语言的实现：java、c#、c++、go、PHP 和 python，每一种实现都包含了相应语言的编译器以及库文件。由于它是一种二进制的格式，比使用 xml 进行数据交换快许多。可以把它用于分布式应用之间的数据通信或者异构环境下的数据交换。作为一种效率和兼容性都很优秀的二进制数据传输格式，可以用于诸如网络传输、配置文件、数据存储等诸多领域。</p><p>至于protobuf是什么、使用场景、有什么好处，本文不做说明，这里将会为大家介绍怎么用 <code>protobuf</code> 来定义我们的交互协议，包括 <code>.proto</code> 的语法以及如何根据proto文件生成相应的代码。本文基于<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">proto3</a>，读者也可以点击了解<a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">proto2</a></p></blockquote><h2 id="proto3语法"><a href="#proto3语法" class="headerlink" title="proto3语法"></a>proto3语法</h2><h3 id="定义一个-Message"><a href="#定义一个-Message" class="headerlink" title="定义一个 Message"></a>定义一个 Message</h3><p>首先我们来定义一个 Search 请求，在这个请求里面，我们需要给服务端发送三个信息：</p><ul><li>query：查询条件</li><li>page_number：你想要哪一页数据</li><li>result_per_page：每一页有多少条数据</li></ul><p>于是我们可以这样定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 指定使用proto3，如果不指定的话，编译器会使用proto2去编译</span><br><span class="line">syntax &#x3D; &quot;proto3&quot;; &#x2F;&#x2F;[proto2|proto3]</span><br><span class="line"></span><br><span class="line">message SearchRequests &#123;</span><br><span class="line">    &#x2F;&#x2F; 定义SearchRequests的成员变量，需要指定：变量类型、变量名、变量Tag</span><br><span class="line">    string query &#x3D; 1;</span><br><span class="line">    int32 page_number &#x3D; 2;</span><br><span class="line">    int32 result_per_page &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义多个-message-类型"><a href="#定义多个-message-类型" class="headerlink" title="定义多个 message 类型"></a>定义多个 message 类型</h3><p>一个 proto 文件可以定义多个 message ，比如我们可以在刚才那个 proto 文件中把服务端返回的消息结构也一起定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">    string query &#x3D; 1;</span><br><span class="line">    int32 page_number &#x3D; 2;</span><br><span class="line">    int32 result_per_page &#x3D; 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SearchResponse &#123;</span><br><span class="line">    repeated string result &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>message 可以嵌套定义，比如 message 可以定义在另一个 message 内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">message SearchResponse &#123;</span><br><span class="line">    message Result &#123;</span><br><span class="line">        string url &#x3D; 1;</span><br><span class="line">        string title &#x3D; 2;</span><br><span class="line">        repeated string snippets &#x3D; 3;</span><br><span class="line">    &#125;</span><br><span class="line">    repeated Result results &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义在 message 内部的 message 可以这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message SomeOtherMessage &#123;</span><br><span class="line">    SearchResponse.Result result &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义变量类型"><a href="#定义变量类型" class="headerlink" title="定义变量类型"></a>定义变量类型</h3><p>在刚才的例子之中，我们使用了2个<code>标准值类型</code>： string 和 int32，除了这些标准类型之外，变量的类型还可以是复杂类型，比如自定义的<code>枚举</code>和自定义的 <code>message</code></p><p>这里我们把标准类型列举一下protobuf内置的标准类型以及跟各平台对应的关系：</p><table><thead><tr><th>.proto</th><th>说明</th><th>Java</th><th>Python</th><th>Go</th></tr></thead><tbody><tr><td>double</td><td></td><td>double</td><td>float</td><td>float64</td></tr><tr><td>float</td><td></td><td>float</td><td>float</td><td>float32</td></tr><tr><td>int32</td><td>使用变长编码，对负数编码效率低，如果你的变量可能是负数，可以使用sint32</td><td>int</td><td>int</td><td>int32</td></tr><tr><td>int64</td><td>使用变长编码，对负数编码效率低，如果你的变量可能是负数，可以使用sint64</td><td>long</td><td>int/long</td><td>int64</td></tr><tr><td>uint32</td><td>使用变长编码</td><td>int</td><td>int/long</td><td>uint32</td></tr><tr><td>uint64</td><td>使用变长编码</td><td>long</td><td>int/long</td><td>uint64</td></tr><tr><td>sint32</td><td>使用变长编码，带符号的int类型，对负数编码比int32高效</td><td>int</td><td>int</td><td>int32</td></tr><tr><td>sint64</td><td>使用变长编码，带符号的int类型，对负数编码比int64高效</td><td>long</td><td>int/long</td><td>int64</td></tr><tr><td>fixed32</td><td>4字节编码， 如果变量经常大于228 的话，会比uint32高效</td><td>int</td><td>int</td><td>int32</td></tr><tr><td>fixed64</td><td>8字节编码， 如果变量经常大于256 的话，会比uint64高效</td><td>long</td><td>int/long</td><td>uint64</td></tr><tr><td>sfixed32</td><td>4字节编码</td><td>int</td><td>int</td><td>int32</td></tr><tr><td>sfixed64</td><td>8字节编码</td><td>long</td><td>int/long</td><td>int64</td></tr><tr><td>bool</td><td></td><td>boolean</td><td>bool</td><td>bool</td></tr><tr><td>string</td><td>必须包含utf-8编码或者7-bit ASCII text</td><td>String</td><td>str/unicode</td><td>string</td></tr><tr><td>bytes</td><td>任意的字节序列</td><td>ByteString</td><td>str</td><td>[]byte</td></tr></tbody></table><p>补充说明：</p><ul><li>In Java, unsigned 32-bit and 64-bit integers are represented using their signed counterparts, with the top bit simply being stored in the sign bit.</li><li>In all cases, setting values to a field will perform type checking to make sure it is valid.</li><li>64-bit or unsigned 32-bit integers are always represented as long when decoded, but can be an int if an int is given when setting the field. In all cases, the value must fit in the type represented when set. See <a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="noopener">2</a>.</li><li>Python strings are represented as unicode on decode but can be str if an ASCII string is given (this is subject to change).</li><li>Integer is used on 64-bit machines and string is used on 32-bit machines.</li></ul><p>关于标准值类型，还可以参考<a href="https://developers.google.com/protocol-buffers/docs/proto3#scalar" target="_blank" rel="noopener">Scalar Value Types</a></p><p>如果你想了解这些数据是怎么序列化和反序列化的，可以点击 <a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">Protocol Buffer Encoding</a> 了解更多关于protobuf编码内容。</p><h3 id="分配Tag"><a href="#分配Tag" class="headerlink" title="分配Tag"></a>分配Tag</h3><p>每一个变量在message内都需要自定义一个<strong>唯一的数字Tag</strong>，protobuf会根据Tag从数据中查找变量对应的位置，具体原理跟protobuf的<a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">二进制数据格式</a>有关。Tag一旦指定，以后更新协议的时候也不能修改，否则无法对旧版本兼容。</p><p>Tag的取值范围最小是1，最大是229-1，但 19000~19999 是 protobuf 预留的，用户不能使用。</p><p>虽然 Tag 的定义范围比较大，但不同 Tag 也会对 protobuf 编码带来一些影响：</p><ul><li>1 ~ 15：单字节编码</li><li>16 ~ 2047：双字节编码</li></ul><p>使用频率高的变量最好设置为1 ~ 15，这样可以减少编码后的数据大小，但由于Tag一旦指定不能修改，所以为了以后扩展，也记得为未来保留一些 1 ~ 15 的 Tag</p><h3 id="指定变量规则"><a href="#指定变量规则" class="headerlink" title="指定变量规则"></a>指定变量规则</h3><p>在 proto3 中，可以给变量指定以下两个规则：</p><ul><li><code>singular</code>：0或者1个，但不能多于1个</li><li><code>repeated</code>：任意数量（包括0）</li></ul><p>当构建 message 的时候，build 数据的时候，会检测设置的数据跟规则是否匹配</p><p>在proto2中，规则为：</p><ul><li>required：必须有一个</li><li>optional：0或者1个</li><li>repeated：任意数量（包括0）</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>用<code>//</code>表示注释开头，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">    string query &#x3D; 1;</span><br><span class="line">    int32 page_number &#x3D; 2; &#x2F;&#x2F; Which page number do we want</span><br><span class="line">    int32 result_per_page &#x3D; 3; &#x2F;&#x2F; Number of results to return per page</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="保留变量不被使用"><a href="#保留变量不被使用" class="headerlink" title="保留变量不被使用"></a>保留变量不被使用</h3><p>上面我们说到，一旦 Tag 指定后就不能变更，这就会带来一个问题，假如在版本1的协议中，我们有个变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int32 number &#x3D; 1；</span><br></pre></td></tr></table></figure><p>在版本2中，我们决定废弃对它的使用，那我们应该如何修改协议呢？注释掉它？删除掉它？如果把它删除了，后来者很可能在定义新变量的时候，使新的变量 Tag = 1 ，这样会导致协议不兼容。那有没有办法规避这个问题呢？我们可以用 <code>reserved</code> 关键字，当一个变量不再使用的时候，我们可以把它的变量名或 Tag 用 <code>reserved</code> 标注，这样，当这个 Tag 或者变量名字被重新使用的时候，编译器会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">    &#x2F;&#x2F; 注意，同一个 reserved 语句不能同时包含变量名和 Tag </span><br><span class="line">    reserved 2, 15, 9 to 11;</span><br><span class="line">    reserved &quot;foo&quot;, &quot;bar&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>当解析 message 时，如果被编码的 message 里没有包含某些变量，那么根据类型不同，他们会有不同的默认值：</p><ul><li>string：默认是空的字符串</li><li>byte：默认是空的bytes</li><li>bool：默认为false</li><li>numeric：默认为0</li><li>enums：定义在第一位的枚举值，也就是0</li><li>messages：根据生成的不同语言有不同的表现，参考<a href="https://developers.google.com/protocol-buffers/docs/reference/overview" target="_blank" rel="noopener">generated code guide</a></li></ul><p>注意，收到数据后反序列化后，对于标准值类型的数据，比如bool，如果它的值是 false，那么我们无法判断这个值是对方设置的，还是对方压根就没给这个变量设置值。</p><h3 id="定义枚举-Enumerations"><a href="#定义枚举-Enumerations" class="headerlink" title="定义枚举 Enumerations"></a>定义枚举 Enumerations</h3><p>在 protobuf 中，我们也可以定义枚举，并且使用该枚举类型，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">    string query &#x3D; 1;</span><br><span class="line">    int32 page_number &#x3D; 2; &#x2F;&#x2F; Which page number do we want</span><br><span class="line">    int32 result_per_page &#x3D; 3; &#x2F;&#x2F; Number of results to return per page</span><br><span class="line">    enum Corpus &#123;</span><br><span class="line">        UNIVERSAL &#x3D; 0;</span><br><span class="line">        WEB &#x3D; 1;</span><br><span class="line">        IMAGES &#x3D; 2;</span><br><span class="line">        LOCAL &#x3D; 3;</span><br><span class="line">        NEWS &#x3D; 4;</span><br><span class="line">        PRODUCTS &#x3D; 5;</span><br><span class="line">        VIDEO &#x3D; 6;</span><br><span class="line">    &#125;</span><br><span class="line">    Corpus corpus &#x3D; 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举定义在一个消息内部或消息外部都是可以的，如果枚举是 定义在 message 内部，而其他 message 又想使用，那么可以通过 <code>MessageType.EnumType</code> 的方式引用。定义枚举的时候，我们要保证<strong>第一个枚举值必须是0</strong>，枚举值不能重复，除非使用 <code>option allow_alias = true</code> 选项来开启别名。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum EnumAllowingAlias &#123;</span><br><span class="line">    option allow_alias &#x3D; true;</span><br><span class="line">    UNKNOWN &#x3D; 0;</span><br><span class="line">    STARTED &#x3D; 1;</span><br><span class="line">    RUNNING &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举值的范围是32-bit integer，但因为枚举值使用变长编码，所以不推荐使用负数作为枚举值，因为这会带来效率问题。</p><h3 id="如何引用其他-proto-文件"><a href="#如何引用其他-proto-文件" class="headerlink" title="如何引用其他 proto 文件"></a>如何引用其他 proto 文件</h3><p>在proto语法中，有两种引用其他 proto 文件的方法： <code>import</code> 和 <code>import public</code>，这两者有什么区别呢？下面举个例子说明：<br><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/Grpc/grpc-4.png" alt="这里写图片描述"></p><ul><li>在情景1中， my.proto <strong>不能</strong>使用 second.proto 中定义的内容</li><li>在情景2中， my.proto <strong>可以</strong>使用 second.proto 中定义的内容</li><li>情景1和情景2中，my.proto 都可以使用 first.proto</li><li>情景1和情景2中，first.proto 都可以使用 second.proto</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; my.proto</span><br><span class="line">import &quot;first.proto&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; first.proto</span><br><span class="line">&#x2F;&#x2F;import &quot;second.proto&quot;;</span><br><span class="line">import public &quot;second.proto&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; second.proto</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="升级-proto-文件正确的姿势"><a href="#升级-proto-文件正确的姿势" class="headerlink" title="升级 proto 文件正确的姿势"></a>升级 proto 文件正确的姿势</h3><p>升级更改 proto 需要遵循以下原则</p><ul><li>不要修改任何已存在的变量的 Tag</li><li>如果你新增了变量，新生成的代码依然能解析旧的数据，但新增的变量将会变成默认值。相应的，新代码序列化的数据也能被旧的代码解析，但旧代码会自动忽略新增的变量。</li><li>废弃不用的变量用 reserved 标注</li><li>int32、 uint32、 int64、 uint64 和 bool 是相互兼容的，这意味你可以更改这些变量的类型而不会影响兼容性</li><li>sint32 和 sint64 是兼容的，但跟其他类型不兼容</li><li>string 和 bytes 可以兼容，前提是他们都是UTF-8编码的数据</li><li>fixed32 和 sfixed32 是兼容的, fixed64 和 sfixed64是兼容的</li></ul><h3 id="Any-的使用"><a href="#Any-的使用" class="headerlink" title="Any 的使用"></a>Any 的使用</h3><p>Any可以让你在 proto 文件中使用未定义的类型，具体里面保存什么数据，是在上层业务代码使用的时候决定的，使用 Any 必须导入 <code>import google/protobuf/any.proto</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;google&#x2F;protobuf&#x2F;any.proto&quot;;</span><br><span class="line"></span><br><span class="line">message ErrorStatus &#123;</span><br><span class="line">    string message &#x3D; 1;</span><br><span class="line">    repeated google.protobuf.Any details &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Oneof-的使用"><a href="#Oneof-的使用" class="headerlink" title="Oneof 的使用"></a>Oneof 的使用</h3><p>Oneof 类似union，如果你的消息中有很多可选字段，而同一个时刻最多仅有其中的一个字段被设置的话，你可以使用oneof来强化这个特性并且节约存储空间，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">message LoginReply &#123;</span><br><span class="line">    oneof test_oneof &#123;</span><br><span class="line">        string name &#x3D; 3;</span><br><span class="line">        string age &#x3D; 4;</span><br><span class="line">    &#125;</span><br><span class="line">    required string status &#x3D; 1;</span><br><span class="line">    required string token &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，name 和 age 都是 LoginReply 的成员，但不能给他们同时设置值（设置一个oneof字段会自动清理其他的oneof字段）。</p><h3 id="Maps-的使用"><a href="#Maps-的使用" class="headerlink" title="Maps 的使用"></a>Maps 的使用</h3><p>protobuf 支持定义 map 类型的成员，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field &#x3D; N;</span><br><span class="line">&#x2F;&#x2F; 举例：map&lt;string, Project&gt; projects &#x3D; 3;</span><br></pre></td></tr></table></figure><ul><li>key_type:必须是string或者int</li><li>value_type：任意类型</li></ul><p>使用 map 要注意：</p><ul><li>Map 类型不能使 repeated</li><li>Map 是无序的</li><li>以文本格式展示时，Map 以 key 来排序</li><li>如果有相同的键会导致解析失败</li></ul><h3 id="Packages-的使用"><a href="#Packages-的使用" class="headerlink" title="Packages 的使用"></a>Packages 的使用</h3><p>为了防止不同消息之间的命名冲突，你可以对特定的.proto文件提指定 package 名字。在定义消息的成员的时候，可以指定包的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package foo.bar;</span><br><span class="line">message Open &#123; ... &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 带上包名</span><br><span class="line">    foo.bar.Open open &#x3D; 1;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><p>Options 分为 file-level options（只能出现在最顶层，不能在消息、枚举、服务内部使用）、 message-level options（只能在消息内部使用）、field-level options（只能在变量定义时使用）</p><ul><li>java_package (file option)：指定生成类的包名，如果没有指定此选项，将由关键字package指定包名。此选项只在生成 java 代码时有效</li><li>java_multiple_files (file option)：如果为 true， 定义在最外层的 message 、enum、service 将作为单独的类存在</li><li>java_outer_classname (file option)：指定最外层class的类名，如果不指定，将会以文件名作为类名</li><li>optimize_for (file option)：可选有 [SPEED|CODE_SIZE|LITE_RUNTIME] ，分别是效率优先、空间优先，第三个lite是兼顾效率和代码大小，但是运行时需要依赖 libprotobuf-lite</li><li>cc_enable_arenas (file option):启动arena allocation，c++代码使用</li><li>objc_class_prefix (file option)：Objective-C使用</li><li>deprecated (field option)：提示变量已废弃、不建议使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">option java_package &#x3D; &quot;com.example.foo&quot;;</span><br><span class="line">option java_multiple_files &#x3D; true;</span><br><span class="line">option java_outer_classname &#x3D; &quot;Ponycopter&quot;;</span><br><span class="line">option optimize_for &#x3D; CODE_SIZE;</span><br><span class="line">int32 old_field &#x3D; 6 [deprecated&#x3D;true];</span><br></pre></td></tr></table></figure><h2 id="定义-Services"><a href="#定义-Services" class="headerlink" title="定义 Services"></a>定义 Services</h2><p>这个其实和gRPC相关，详细可参考：<a href="http://www.grpc.io/" target="_blank" rel="noopener">gRPC</a>， 这里做一个简单的介绍<br>要定义一个服务，你必须在你的 .proto 文件中指定 <code>service</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service RouteGuide &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在我们的服务中定义 <code>rpc</code> 方法，指定它们的请求的和响应类型。<code>gRPC</code> 允许你定义4种类型的 service 方法</p><h2 id="简单RPC"><a href="#简单RPC" class="headerlink" title="简单RPC"></a>简单RPC</h2><p>客户端使用 Stub 发送请求到服务器并等待响应返回，就像平常的函数调用一样，这是一个阻塞型的调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Obtains the feature at a given position.</span><br><span class="line">rpc GetFeature(Point) returns (Feature) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="服务器端流式-RPC"><a href="#服务器端流式-RPC" class="headerlink" title="服务器端流式 RPC"></a>服务器端流式 RPC</h2><p>客户端发送请求到服务器，拿到一个流去读取返回的消息序列。客户端读取返回的流，直到里面没有任何消息。从例子中可以看出，通过在响应类型前插入 <code>stream</code> 关键字，可以指定一个服务器端的流方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Obtains the Features available within the given Rectangle.  Results are</span><br><span class="line">&#x2F;&#x2F; streamed rather than returned at once (e.g. in a response message with a</span><br><span class="line">&#x2F;&#x2F; repeated field), as the rectangle may cover a large area and contain a</span><br><span class="line">&#x2F;&#x2F; huge number of features.</span><br><span class="line">rpc ListFeatures(Rectangle) returns (stream Feature) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="客户端流式-RPC"><a href="#客户端流式-RPC" class="headerlink" title="客户端流式 RPC"></a>客户端流式 RPC</h2><p>客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦客户端完成写入消息，它等待服务器完成读取返回它的响应。通过在请求类型前指定 <code>stream</code> 关键字来指定一个客户端的流方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Accepts a stream of Points on a route being traversed, returning a</span><br><span class="line">&#x2F;&#x2F; RouteSummary when traversal is completed.</span><br><span class="line">rpc RecordRoute(stream Point) returns (RouteSummary) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="双向流式-RPC"><a href="#双向流式-RPC" class="headerlink" title="双向流式 RPC"></a>双向流式 RPC</h2><p>双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器可以以任意喜欢的顺序读写：比如， 服务器可以在写入响应前等待接收所有的客户端消息，或者可以交替的读取和写入消息，或者其他读写的组合。每个流中的消息顺序被预留。你可以通过在请求和响应前加 <code>stream</code> 关键字去制定方法的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Accepts a stream of RouteNotes sent while a route is being traversed,</span><br><span class="line">&#x2F;&#x2F; while receiving other RouteNotes (e.g. from other users).</span><br><span class="line">rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h2><p>使用 <code>protoc</code> 工具可以把编写好的 <code>proto</code> 文件“编译”为Java, Python, C++, Go, Ruby, JavaNano, Objective-C,或C#代码， <code>protoc</code> 可以从<a href="https://developers.google.com/protocol-buffers/docs/downloads" target="_blank" rel="noopener">点击这里</a>进行下载。<code>protoc</code> 的使用方式如下：</p><blockquote><p> GitHub: tags地址 <a href="https://github.com/protocolbuffers/protobuf/tags" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/tags</a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR --go_out=DST_DIR --ruby_out=DST_DIR --javanano_out=DST_DIR --objc_out=DST_DIR --csharp_out=DST_DIR path/to/file.proto1</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>IMPORT_PATH：指定 proto 文件的路径，如果没有指定， protoc 会从当前目录搜索对应的 proto 文件，如果有多个路径，那么可以指定多次<code>--proto_path</code></li><li>指定各语言代码的输出路径<ul><li>–cpp_out：生成c++代码</li><li>java_out ：生成java代码</li><li>python_out ：生成python代码</li><li>go_out ：生成go代码</li><li>ruby_out ：生成ruby代码</li><li>javanano_out ：适合运行在有资源限制的平台（如Android）的java代码</li><li>objc_out ：生成 Objective-C代码</li><li>csharp_out ：生成C#代码</li><li>php_out ：生成PHP代码</li></ul></li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener">IMB Google Protocol Buffer 的使用和原理</a></li><li><a href="http://doc.oschina.net/grpc?t=57966" target="_blank" rel="noopener">osChina gRPC 官方文档翻译</a></li><li><a href="https://www.cnblogs.com/shitouer/archive/2013/04/10/google-protocol-buffers-tutorial.html" target="_blank" rel="noopener">cnblogs Protocol Buffers</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;17年年底做的技术调研，文档好想没有写完。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;gRPC&quot;&gt;&lt;a href=&quot;#gRPC&quot; class=&quot;headerlink&quot; title=&quot;gRPC &quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/grpc/grpc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;gRPC &lt;/a&gt;&lt;/h2&gt;&lt;h3 id=&quot;流程概念&quot;&gt;&lt;a href=&quot;#流程概念&quot; class=&quot;headerlink&quot; title=&quot;流程概念&quot;&gt;&lt;/a&gt;流程概念&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/Grpc/grpc-1.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;性能对比&quot;&gt;&lt;a href=&quot;#性能对比&quot; class=&quot;headerlink&quot; title=&quot;性能对比&quot;&gt;&lt;/a&gt;性能对比&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/Grpc/grpc-2.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;谁在使用&quot;&gt;&lt;a href=&quot;#谁在使用&quot; class=&quot;headerlink&quot; title=&quot;谁在使用&quot;&gt;&lt;/a&gt;谁在使用&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/Grpc/grpc-3.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="基础理论" scheme="https://z201.github.io/categories/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="Grpc" scheme="https://z201.github.io/tags/Grpc/"/>
    
      <category term="ProtoBuf" scheme="https://z201.github.io/tags/ProtoBuf/"/>
    
  </entry>
  
  <entry>
    <title>初探Arthas</title>
    <link href="https://z201.github.io/2019/04/01/%E5%88%9D%E6%8E%A2Arthas/"/>
    <id>https://z201.github.io/2019/04/01/%E5%88%9D%E6%8E%A2Arthas/</id>
    <published>2019-04-01T14:19:20.000Z</published>
    <updated>2019-04-02T15:54:00.115Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基础理论篇学习笔记</p></blockquote><h2 id="Arthas（阿尔萨斯）-能为你做什么？"><a href="#Arthas（阿尔萨斯）-能为你做什么？" class="headerlink" title="Arthas（阿尔萨斯） 能为你做什么？"></a>Arthas（阿尔萨斯） 能为你做什么？</h2><p><img src="https://alibaba.github.io/arthas/_images/arthas.png" alt="arthas"></p><p><code>Arthas</code> 是Alibaba开源的Java诊断工具，深受开发者喜爱。</p><p>当你遇到以下类似问题而束手无策时，<code>Arthas</code>可以帮助你解决：</p><ol><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到JVM的实时运行状态？</li></ol><p><code>Arthas</code>支持JDK 6+，支持Linux/Mac/Winodws，采用命令行交互模式，同时提供丰富的 <code>Tab</code> 自动补全功能，进一步方便进行问题的定位和诊断。</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://alibaba.github.io/arthas/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p>打印帮助信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar -h</span><br></pre></td></tr></table></figure><p>快速启动(使用国内阿里下载包)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar --repo-mirror aliyun</span><br></pre></td></tr></table></figure><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/Arthas/arthas-up-01.png"></p><ul><li>如果当前没有java程序运行则提示这个内容，并且不会被正常启动。</li></ul><p>demo程序作为演示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/hengyunabc/spring-boot-inside</span><br></pre></td></tr></table></figure><ul><li>运行效果</li></ul><blockquote><p>我们先运行一个demo，然后让arthas运行起来。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> spring-boot-inside // 进入文件夹</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> demo-arthas-spring-boot // 进入demo项目</span><br><span class="line"></span><br><span class="line">mvn clean install  // 构建项目</span><br><span class="line"></span><br><span class="line">java -jar demo-arthas-spring-boot-0.0.1-SNAPSHOT.jar  // 启动项目</span><br></pre></td></tr></table></figure><blockquote><p>启动项目之后在运行arthas</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/Arthas/arthas-up-02.png"></p><blockquote><p>如果已经有启动的项目,会提示 [1] project-name 这种。输入数字选择对应的项目即可。</p></blockquote><p>END</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;基础理论篇学习笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Arthas（阿尔萨斯）-能为你做什么？&quot;&gt;&lt;a href=&quot;#Arthas（阿尔萨斯）-能为你做什么？&quot; class=&quot;headerlink&quot; title=&quot;Arthas（阿
      
    
    </summary>
    
    
      <category term="基础理论" scheme="https://z201.github.io/categories/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="Arthas" scheme="https://z201.github.io/tags/Arthas/"/>
    
  </entry>
  
</feed>
