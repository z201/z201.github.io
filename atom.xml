<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫叶的小博客</title>
  
  <subtitle>先完成、在完美。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://z201.github.io/"/>
  <updated>2020-07-23T09:35:21.482Z</updated>
  <id>https://z201.github.io/</id>
  
  <author>
    <name>小峰同学</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>实践-spring-boot替换内置tomcat版本</title>
    <link href="https://z201.github.io/2020/07/23/%E5%AE%9E%E8%B7%B5-spring-boot%E6%9B%BF%E6%8D%A2%E5%86%85%E7%BD%AEtomcat%E7%89%88%E6%9C%AC/"/>
    <id>https://z201.github.io/2020/07/23/%E5%AE%9E%E8%B7%B5-spring-boot%E6%9B%BF%E6%8D%A2%E5%86%85%E7%BD%AEtomcat%E7%89%88%E6%9C%AC/</id>
    <published>2020-07-23T09:03:27.000Z</published>
    <updated>2020-07-23T09:35:21.482Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章只是回顾一次eureka版本升级后tomcat资源占用过高的问题，临时解决。</p></blockquote><h3 id="升级springBoot、SpringCloud版本"><a href="#升级springBoot、SpringCloud版本" class="headerlink" title="升级springBoot、SpringCloud版本"></a>升级springBoot、SpringCloud版本</h3><ul><li>升级完成后直接在测试环境测试部署，结果发现eureka的cpu资源占用过高，导致假死。通过arthas发现是tomcat线程阻塞。通过dependepency看了下springboot中内嵌tomcat的版本是9了。之前是8，测试环境一大堆人等着测试接口。首先想着降低tomcat版本。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看依赖</span><br><span class="line">gradle dependencies</span><br><span class="line">mvn dependency:tree &gt; output.txt   # 输出到文件里</span><br></pre></td></tr></table></figure><h3 id="排除SpringBoot的Tomcat，指定Tomcat版本"><a href="#排除SpringBoot的Tomcat，指定Tomcat版本" class="headerlink" title="排除SpringBoot的Tomcat，指定Tomcat版本"></a>排除SpringBoot的Tomcat，指定Tomcat版本</h3><p>有时候我们需要在特定情况下使用特定的Tomcat版本，这时候总不能因为Tomcat就改变SpringBoot的版本，所以可以采用排除SpringBoot中的Tomcat包，然后手动指定Tomcat的版本，当然还要引入Tomcat相关的包。</p><h5 id="Gradle的配置"><a href="#Gradle的配置" class="headerlink" title="Gradle的配置"></a>Gradle的配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>) &#123;</span><br><span class="line">  exclude <span class="keyword">module</span>: <span class="string">"spring-boot-starter-tomcat"</span></span><br><span class="line">&#125;</span><br><span class="line">compile <span class="string">'org.apache.tomcat.embed:tomcat-embed-core:8.5.37'</span></span><br><span class="line">compile <span class="string">'org.apache.tomcat.embed:tomcat-embed-el:8.5.37'</span></span><br><span class="line">compile <span class="string">'org.apache.tomcat.embed:tomcat-embed-logging-juli:8.5.2'</span></span><br><span class="line">compile <span class="string">'org.apache.tomcat.embed:tomcat-embed-websocket:8.5.37'</span></span><br></pre></td></tr></table></figure><p>如果不指定版本，则会使用最新的Tomcat版本, 否则直接指定对应的版本号。</p><h5 id="Maven的配置"><a href="#Maven的配置" class="headerlink" title="Maven的配置"></a>Maven的配置</h5><ol><li>在 pom.xml文件里面添加一个标签<properties>，添加期望的版本。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tomcat.version</span>&gt;</span>8.5.37<span class="tag">&lt;/<span class="name">tomcat.version</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>添加必要的Jar包：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-juli<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;tomcat.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-logging-juli<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;tomcat.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重新部署eureka后一切正常。处理时间短暂，没有影响大家工作。时间过了大半年了，也忘记具体是啥原因了。有机会本地复现试试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本章只是回顾一次eureka版本升级后tomcat资源占用过高的问题，临时解决。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;升级springBoot、SpringCloud版本&quot;&gt;&lt;a href=&quot;#升级springBoot、Spring
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Eureka" scheme="https://z201.github.io/tags/Eureka/"/>
    
      <category term="Tomcat" scheme="https://z201.github.io/tags/Tomcat/"/>
    
      <category term="SpringBoot" scheme="https://z201.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Git清理提交纪录</title>
    <link href="https://z201.github.io/2020/07/18/Git%E6%B8%85%E7%90%86%E6%8F%90%E4%BA%A4%E7%BA%AA%E5%BD%95/"/>
    <id>https://z201.github.io/2020/07/18/Git%E6%B8%85%E7%90%86%E6%8F%90%E4%BA%A4%E7%BA%AA%E5%BD%95/</id>
    <published>2020-07-18T15:39:21.000Z</published>
    <updated>2020-07-18T15:55:56.534Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有时候需要清理提交的历史纪录，这个时候可以采用暴力的方法。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Checkout </span><br><span class="line"></span><br><span class="line">   git checkout --orphan latest_branch</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Add all the files</span><br><span class="line"></span><br><span class="line">   git add -A</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Commit the changes</span><br><span class="line"></span><br><span class="line">   git commit -am <span class="string">"commit message"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> Delete the branch</span><br><span class="line"></span><br><span class="line">   git branch -D master</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>Rename the current branch to master</span><br><span class="line"></span><br><span class="line">   git branch -m master</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>Finally, force update your repository</span><br><span class="line"></span><br><span class="line">   git push -f origin master</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有时候需要清理提交的历史纪录，这个时候可以采用暴力的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="Git" scheme="https://z201.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://z201.github.io/tags/Git/"/>
    
      <category term="工作流程" scheme="https://z201.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>实践eureka钉钉告警通知</title>
    <link href="https://z201.github.io/2020/07/16/%E5%AE%9E%E8%B7%B5-eureka%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6%E9%80%9A%E7%9F%A5/"/>
    <id>https://z201.github.io/2020/07/16/%E5%AE%9E%E8%B7%B5-eureka%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6%E9%80%9A%E7%9F%A5/</id>
    <published>2020-07-16T09:04:36.000Z</published>
    <updated>2020-07-28T18:20:36.700Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇幅只是回顾使用eureka的时候如何钉钉告警。</p></blockquote><h3 id="eureka如何快速实现钉钉告警"><a href="#eureka如何快速实现钉钉告警" class="headerlink" title="eureka如何快速实现钉钉告警"></a>eureka如何快速实现钉钉告警</h3><p><a href="https://z201.cn/2020/07/15/%E5%AE%9E%E8%B7%B5-spring-boot%E5%BC%82%E5%B8%B8%E9%92%89%E9%92%89%E9%80%9A%E7%9F%A5/" target="_blank" rel="noopener">实践-spring-boot异常钉钉通知</a></p><p>​        上面实践了springboot全局异常钉钉告警机制。这篇主要回顾eureka监听机制钉钉告警。在日常维护工作中，如果出现网络抖动或者其它问题导致应用不可用，需要第一件发出告警提醒相关人员尽快处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">eureka -&gt;&gt; eventListener : event</span><br><span class="line">eventListener -&gt;&gt;  钉钉 : alarmNoticeSend</span><br><span class="line">钉钉 -&gt;&gt; 开发人员  : eurekaInstanceInfo</span><br></pre></td></tr></table></figure><ul><li>实例图</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/eureka%E5%AE%9E%E4%BE%8B%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6.png"></p><p>​        关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(EurekaInstanceCanceledEvent event)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"告警通知 [&#123;&#125;] 服务注销 timestamp [&#123;&#125;] serverId [&#123;&#125;]"</span>,</span><br><span class="line">                event.getAppName(),</span><br><span class="line">                event.getTimestamp(),</span><br><span class="line">                event.getServerId());</span><br><span class="line">        <span class="keyword">if</span> (!event.isReplication()) &#123;</span><br><span class="line">            ServiceNotice serviceNotice = <span class="keyword">new</span> ServiceNotice();</span><br><span class="line">            serviceNotice.setTitle(<span class="string">"告警通知 服务下线"</span>);</span><br><span class="line">            serviceNotice.setAppName(event.getAppName());</span><br><span class="line">            serviceNotice.setTimestamp(event.getTimestamp());</span><br><span class="line">            serviceNotice.setServerId(event.getServerId());</span><br><span class="line">            serviceNotice.setProfiles(active);</span><br><span class="line">            alarmNoticeManage.createNotice(serviceNotice, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(EurekaInstanceRegisteredEvent event)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"告警通知 [&#123;&#125;] 服务注册 timestamp [&#123;&#125;] id [&#123;&#125;] ipAddr [&#123;&#125;] "</span>,</span><br><span class="line">                event.getInstanceInfo().getAppName(),</span><br><span class="line">                event.getTimestamp(),</span><br><span class="line">                event.getInstanceInfo().getId(),</span><br><span class="line">                event.getInstanceInfo().getIPAddr()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (!event.isReplication()) &#123;</span><br><span class="line">            ServiceNotice serviceNotice = <span class="keyword">new</span> ServiceNotice();</span><br><span class="line">            serviceNotice.setTitle(<span class="string">"告警通知 服务上线"</span>);</span><br><span class="line">            serviceNotice.setAppName(event.getInstanceInfo().getAppName());</span><br><span class="line">            serviceNotice.setTimestamp(event.getTimestamp());</span><br><span class="line">            serviceNotice.setServerId(event.getInstanceInfo().getId());</span><br><span class="line">            serviceNotice.setProfiles(active);</span><br><span class="line">            alarmNoticeManage.createNotice(serviceNotice, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>效果如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">告警通知 服务下线</span><br><span class="line">2020-07-16 16:03:20 Z-GATEWAY 192.168.31.7:z-gateway:9000 profiles dev1</span><br><span class="line">@xxx</span><br></pre></td></tr></table></figure><ul><li>eureka查看源码得知有五个事件。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EurekaServerStartedEvent - Eureka服务端启动事件</span><br><span class="line">EurekaRegistryAvailableEvent - Eureka服务端可用事件</span><br><span class="line">EurekaInstanceRegisteredEvent - Eureka客户端服务注册事件</span><br><span class="line">EurekaInstanceRenewedEvent - Eureka客户端续约事件</span><br><span class="line">EurekaInstanceCanceledEvent - Eureka客户端下线事件</span><br></pre></td></tr></table></figure><p>这里就比较简单了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇幅只是回顾使用eureka的时候如何钉钉告警。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;eureka如何快速实现钉钉告警&quot;&gt;&lt;a href=&quot;#eureka如何快速实现钉钉告警&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="Eureka" scheme="https://z201.github.io/tags/Eureka/"/>
    
      <category term="钉钉" scheme="https://z201.github.io/tags/%E9%92%89%E9%92%89/"/>
    
  </entry>
  
  <entry>
    <title>实践SpringBoot异常钉钉通知</title>
    <link href="https://z201.github.io/2020/07/15/%E5%AE%9E%E8%B7%B5-spring-boot%E5%BC%82%E5%B8%B8%E9%92%89%E9%92%89%E9%80%9A%E7%9F%A5/"/>
    <id>https://z201.github.io/2020/07/15/%E5%AE%9E%E8%B7%B5-spring-boot%E5%BC%82%E5%B8%B8%E9%92%89%E9%92%89%E9%80%9A%E7%9F%A5/</id>
    <published>2020-07-15T07:23:20.000Z</published>
    <updated>2020-07-23T09:04:39.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇幅只是回顾使用钉钉做异常告警需要那些关键业务信息。</p></blockquote><h3 id="为什么要做钉钉通知？"><a href="#为什么要做钉钉通知？" class="headerlink" title="为什么要做钉钉通知？"></a>为什么要做钉钉通知？</h3><p>​        事情要从我入职上家公司说起，进入公司后把线上项目clone下来大致看了下。代码风格过于滞后、编码风格混乱。进入公司第一周就出现了线上故障，嗯。我去线上检查日志，emmmm竟然没有日志输出。这次故障是由客户反馈来的。当时我非常吃惊，大伙好像很淡定的样子，习以为常了？</p><p>​        想到当初面试的时候和总监的谈话，主要是带领团队落地微服务架构，看来必须大刀阔斧了。</p><p>​        首先想到的时候改进日志输出、定义全局异常级别，根据异常级别输出日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">Java应用 -&gt;&gt; SpringAop全局异常拦截 : runtimeException</span><br><span class="line">SpringAop全局异常拦截 -&gt;&gt;  钉钉 : alarmNoticeSend</span><br><span class="line">钉钉 -&gt;&gt; 开发人员  : exceptionInfo</span><br></pre></td></tr></table></figure><ul><li>效果图</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/springboot%E9%92%89%E9%92%89%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA.png"></p><p>​        我们需要从钉钉里面看到那些异常信息呢？这是当时输出到钉钉的信息。通过编写全局拦截器，在公共基础项目里面添加了aop全局拦截。刚开始上线的时候钉钉一天动不动就几千个异常告警。刚开始大伙都很紧张，过了个把月大伙已经又麻木了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">告警信息</span><br><span class="line">工程名：z201-gateway</span><br><span class="line">类路径：cn.z201.cloud.gateway.VlinkFrameworkGatewayApplicationTest</span><br><span class="line">方法名：alarm</span><br><span class="line">异常信息：java.lang.IllegalAccessException</span><br><span class="line">异常追踪：</span><br><span class="line">cn.z201.cloud.gateway.VlinkFrameworkGatewayApplicationTest.alarm(VlinkFrameworkGatewayApplicationTest.java:<span class="number">64</span>)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">org.junit.runners.model.FrameworkMethod$<span class="number">1</span>.runReflectiveCall(FrameworkMethod.java:<span class="number">50</span>)</span><br><span class="line">org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:<span class="number">12</span>)</span><br><span class="line">org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:<span class="number">47</span>)</span><br><span class="line">org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:<span class="number">17</span>)</span><br><span class="line">org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:<span class="number">74</span>)</span><br></pre></td></tr></table></figure><h3 id="这样的告警信息就够了吗？"><a href="#这样的告警信息就够了吗？" class="headerlink" title="这样的告警信息就够了吗？"></a>这样的告警信息就够了吗？</h3><p>​        明显这样是不够够的，前端有安卓、ios、微信小程序、web、快应用。太多前端项目了，后端需要识别出是哪里的项目出的问题。于是又改进了一次。邀请前端开发人员在HttpHeader里面增加额外参数。为了做流量区分也增加了一些参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  <span class="string">"Content-Type"</span>:<span class="string">"application/json"</span> </span><br><span class="line">  "Authorization":"Bearer xxxxxxxxxx"  ## jwt</span><br><span class="line">  "Client-Business-Group-Source": "1", ##  业务组来源唯一标号</span><br><span class="line">  "Client-Business-Source": "1000", ## 业务来源唯一标号</span><br><span class="line">  "Client-Business-Activity-Source": "1", ## 查看介绍、更多 针对特殊业务流量识别</span><br><span class="line">  "Client-Env-Source": "1", ##客户端环境来源  1 ios  2 android  3 windows</span><br><span class="line">  "Client-Platform-Source": "xxx", ##客户端平台 xxx手机型号、浏览器</span><br><span class="line">  "Client-Start-Time": "1",        ##请求时间戳</span><br><span class="line">  "Client-Version-Source": "1.0.0" ##客户端版本号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        通过上面的改进告警信息完善很多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">告警信息</span><br><span class="line">工程名：z201-gateway</span><br><span class="line">类路径：cn.z201.cloud.gateway.VlinkFrameworkGatewayApplicationTest</span><br><span class="line">方法名：alarm</span><br><span class="line">异常信息：java.lang.IllegalAccessException</span><br><span class="line">异常扩展信息： &#123;</span><br><span class="line">  &quot;Client-Business-Source&quot;: &quot;1000&quot;, </span><br><span class="line">  &quot;Client-Business-Activity-Source&quot;: &quot;1&quot;, </span><br><span class="line">  &quot;Client-Env-Source&quot;: &quot;1&quot;, </span><br><span class="line">  &quot;Client-Platform-Source&quot;: &quot;xxx&quot;,   </span><br><span class="line">  &quot;Client-Version-Source&quot;: &quot;1.0.0&quot; </span><br><span class="line">&#125; </span><br><span class="line">异常追踪：</span><br><span class="line">cn.z201.cloud.gateway.VlinkFrameworkGatewayApplicationTest.alarm(VlinkFrameworkGatewayApplicationTest.java:64)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)</span><br><span class="line">org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)</span><br><span class="line">org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)</span><br><span class="line">org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)</span><br><span class="line">org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74)</span><br></pre></td></tr></table></figure><h3 id="分布式下面临的问题！"><a href="#分布式下面临的问题！" class="headerlink" title="分布式下面临的问题！"></a>分布式下面临的问题！</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">gateway -&gt;&gt; 应用A : httpRequest</span><br><span class="line">应用A -&gt;&gt;  应用B : httpRequest</span><br><span class="line">应用B --&gt;&gt; 应用A : httpResponse</span><br><span class="line">应用A --&gt;&gt; gateway : httpResponse</span><br></pre></td></tr></table></figure><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E5%A4%9A%E5%BA%94%E7%94%A8%E9%93%BE%E8%B7%AF%E8%AF%B7%E6%B1%82.png"></p><p>​        当调用链多的时候定位问题就有点麻烦，比如应用a调用应用b。应用b执行了异常信息直接抛出了告警信息。但是spring cloud http rpc默认是不会吧请求参数传递到后面的服务中，需要我们做下简单的扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> z201.coding@gmail.com</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpApiConstant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String X_REAL_IP = <span class="string">"x-real-ip"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求头跟踪id名。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String HTTP_HEADER_TRACE_ID = <span class="string">"AppTraceId"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String HTTP_TOKEN_HEADER = <span class="string">"Authorization"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * app租户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String APP_TENANT = <span class="string">"Tenant"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_BUSINESS_GROUP_SOURCE = <span class="string">"Client-Business-Group-Source"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_BUSINESS_SOURCE = <span class="string">"Client-Business-Source"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_BUSINESS_ACTIVITY_SOURCE = <span class="string">"Client-Business-Activity-Source"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_EVN_SOURCE = <span class="string">"Client-Env-Source"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_PLATFORM_SOURCE = <span class="string">"Client-Platform-Source"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_START_TIME = <span class="string">"Client-Start-Time"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_VERSION_SOURCE = <span class="string">"Client-Version-Source"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> z201.coding@gmail.com</span></span><br><span class="line"><span class="comment"> * 自定义restTemplate拦截器</span></span><br><span class="line"><span class="comment"> * 这里可以把一些参数从应用层传到内部服务</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(WebMvcConfigurer<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MdcFeignInterceptorConfig</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span>, <span class="title">HttpApiConstant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MdcFeignInterceptorConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Loaded Z-REST-INTERCEPTOR [V1.0.0]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes())</span><br><span class="line">                    .getRequest();</span><br><span class="line">            String xRealIp = request.getHeader(X_REAL_IP);</span><br><span class="line">            String authentication = request.getHeader(HTTP_TOKEN_HEADER);</span><br><span class="line">            String appTraceId = request.getHeader(HTTP_HEADER_TRACE_ID);</span><br><span class="line">            String businessGroupSource = request.getHeader(CLIENT_BUSINESS_GROUP_SOURCE);</span><br><span class="line">            String clientBusinessSource = request.getHeader(CLIENT_BUSINESS_SOURCE);</span><br><span class="line">            String clientBusinessActivitySource = request.getHeader(CLIENT_BUSINESS_ACTIVITY_SOURCE);</span><br><span class="line">            String clientEnvSource = request.getHeader(CLIENT_EVN_SOURCE);</span><br><span class="line">            String clientPlatformSource = request.getHeader(CLIENT_PLATFORM_SOURCE);</span><br><span class="line">            String clientStartTime = request.getHeader(CLIENT_START_TIME);</span><br><span class="line">            String clientVersionSource = request.getHeader(CLIENT_VERSION_SOURCE);</span><br><span class="line">            template.header(HttpHeaders.ACCEPT_ENCODING, <span class="string">"gzip"</span>);</span><br><span class="line">            template.header(X_REAL_IP, xRealIp);</span><br><span class="line">            template.header(HTTP_TOKEN_HEADER, authentication);</span><br><span class="line">            template.header(CLIENT_BUSINESS_GROUP_SOURCE, businessGroupSource);</span><br><span class="line">            template.header(CLIENT_BUSINESS_SOURCE, clientBusinessSource);</span><br><span class="line">            template.header(CLIENT_BUSINESS_ACTIVITY_SOURCE, clientBusinessActivitySource);</span><br><span class="line">            template.header(CLIENT_EVN_SOURCE, clientEnvSource);</span><br><span class="line">            template.header(CLIENT_PLATFORM_SOURCE, clientPlatformSource);</span><br><span class="line">            template.header(CLIENT_START_TIME, clientStartTime);</span><br><span class="line">            template.header(CLIENT_VERSION_SOURCE, clientVersionSource);</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                Enumeration&lt;String&gt; headerNames = request.getHeaderNames();</span><br><span class="line">                <span class="keyword">while</span> (headerNames.hasMoreElements()) &#123;</span><br><span class="line">                    String name = headerNames.nextElement();</span><br><span class="line">                    String value = request.getHeader(name);</span><br><span class="line">                    log.debug(<span class="string">"header &#123;&#125; - &#123;&#125;"</span>, name, value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"template exception &#123;&#125;"</span>,e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的异常钉钉告警就到这里结束了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇幅只是回顾使用钉钉做异常告警需要那些关键业务信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;为什么要做钉钉通知？&quot;&gt;&lt;a href=&quot;#为什么要做钉钉通知？&quot; class=&quot;headerlink&quot; title=&quot;为什么要做钉钉通知？
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://z201.github.io/tags/Spring/"/>
    
      <category term="钉钉" scheme="https://z201.github.io/tags/%E9%92%89%E9%92%89/"/>
    
  </entry>
  
  <entry>
    <title>面试题-Redis</title>
    <link href="https://z201.github.io/2020/07/03/%E9%9D%A2%E8%AF%95%E9%A2%98-Redis/"/>
    <id>https://z201.github.io/2020/07/03/%E9%9D%A2%E8%AF%95%E9%A2%98-Redis/</id>
    <published>2020-07-02T20:39:42.000Z</published>
    <updated>2020-08-02T20:40:05.989Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章属于持续学习、长期更修。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本章属于持续学习、长期更修。&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="面试题" scheme="https://z201.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Redis" scheme="https://z201.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>面试题-Mysql</title>
    <link href="https://z201.github.io/2020/07/03/%E9%9D%A2%E8%AF%95%E9%A2%98-Mysql/"/>
    <id>https://z201.github.io/2020/07/03/%E9%9D%A2%E8%AF%95%E9%A2%98-Mysql/</id>
    <published>2020-07-02T20:33:01.000Z</published>
    <updated>2020-08-02T20:34:26.790Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章属于持续学习、长期更修。</p></blockquote><h3 id="数据库的三范式是什么"><a href="#数据库的三范式是什么" class="headerlink" title="数据库的三范式是什么"></a>数据库的三范式是什么</h3><ul><li><p>第一范式：列不可再分</p></li><li><p>第二范式：行可以唯一区分，主键约束</p></li><li><p>第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束</p></li><li><p>且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本章属于持续学习、长期更修。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;数据库的三范式是什么&quot;&gt;&lt;a href=&quot;#数据库的三范式是什么&quot; class=&quot;headerlink&quot; title=&quot;数据库的三范式是什么&quot;&gt;&lt;/a&gt;数据库的三范式
      
    
    </summary>
    
    
      <category term="面试" scheme="https://z201.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Mysql" scheme="https://z201.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>面试题-线程池</title>
    <link href="https://z201.github.io/2020/07/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://z201.github.io/2020/07/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-06-30T18:12:50.000Z</published>
    <updated>2020-08-02T19:46:57.491Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章属于持续学习、长期更修。</p></blockquote><ul><li><p><a href="https://z201.cn/2019/02/27/%E5%88%9D%E6%8E%A2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">初探Java多线程</a></p></li><li><p><a href="https://z201.cn/2020/07/30/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">面试题-多线程</a></p></li></ul><blockquote><p>为避免线程频繁创建和销毁带来的性能问题，而池化的一种方案。</p></blockquote><ul><li><p>利用线程池管理并复用线程、控制最大并发数等。</p></li><li><p>实现任务线程队列缓存策略和拒绝机制。</p></li><li><p>实现某些与时间相关的功能，如定时执行、周期执行等。</p></li><li><p>隔离线程环境。比如，交易服务和搜索服务在同一台服务器上，分别开启两个线程池，交易线程的资源消耗明显要大；因此，通过配置独立的线程池将较慢的交易服务与搜索服务隔离开，避免各服务线程相互影响。</p></li></ul><blockquote><p>这里直接参考阿里巴巴的手册。线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的读者更加明确线程池的运行规则，规避资源耗尽的风险。</p></blockquote><h3 id="常⽤线程池：ExecutorService-是主要的实现类"><a href="#常⽤线程池：ExecutorService-是主要的实现类" class="headerlink" title="常⽤线程池：ExecutorService 是主要的实现类"></a>常⽤线程池：ExecutorService 是主要的实现类</h3><ul><li>Executors.newSingleT hreadPool()</li><li>newFixedThreadPool()</li><li>newcachedTheadPool()</li><li>newScheduledThreadPool()</li></ul><h3 id="Executors-返回的线程池对象的弊端"><a href="#Executors-返回的线程池对象的弊端" class="headerlink" title="Executors 返回的线程池对象的弊端"></a>Executors 返回的线程池对象的弊端</h3><ul><li>FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</li><li>CachedThreadPool 和 ScheduledThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</li><li>查看 Executors 的源码会发现，Executors.newFixedThreadPool()、Executors.newSingleThreadExecutor() 和 Executors.newCachedThreadPool() 等方法的底层都是通过 ThreadPoolExecutor 实现的。</li></ul><h3 id="ThreadPoolExecutor的核心参数"><a href="#ThreadPoolExecutor的核心参数" class="headerlink" title="ThreadPoolExecutor的核心参数"></a>ThreadPoolExecutor的核心参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        <span class="comment">// maximumPoolSize 必须大于 0，且必须大于 corePoolSize</span></span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第 1 个参数：corePoolSize 表示线程池的常驻核心线程数。如果设置为 0，则表示在没有任何任务时，销毁线程池；如果大于 0，即使没有任务时也会保证线程池的线程数量等于此值。但需要注意，此值如果设置的比较小，则会频繁的创建和销毁线程（创建和销毁的原因会在本课时的下半部分讲到）；如果设置的比较大，则会浪费系统资源，所以开发者需要根据自己的实际业务来调整此值。</li><li>第 2 个参数：maximumPoolSize 表示线程池在任务最多时，最大可以创建的线程数。官方规定此值必须大于 0，也必须大于等于 corePoolSize，此值只有在任务比较多，且不能存放在任务队列时，才会用到。</li><li>第 3 个参数：keepAliveTime 表示线程的存活时间，当线程池空闲时并且超过了此时间，多余的线程就会销毁，直到线程池中的线程数量销毁的等于 corePoolSize 为止，如果 maximumPoolSize 等于 corePoolSize，那么线程池在空闲的时候也不会销毁任何线程。</li><li>第 4 个参数：unit 表示存活时间的单位，它是配合 keepAliveTime 参数共同使用的。</li><li>第 5 个参数：workQueue 表示线程池执行的任务队列，当线程池的所有线程都在处理任务时，如果来了新任务就会缓存到此任务队列中排队等待执行。</li><li>第 6 个参数：threadFactory 表示线程的创建工厂，此参数一般用的比较少，我们通常在创建线程池时不指定此参数，它会使用默认的线程创建工厂的方法来创建线程。</li><li>第 7 个参数：RejectedExecutionHandler 表示指定线程池的拒绝策略，当线程池的任务已经在缓存队列 workQueue 中存储满了之后，并且不能创建新的线程来执行此任务时，就会用到此拒绝策略，它属于一种限流保护的机制。</li><li>原理<ul><li>如果当前池⼤⼩ poolSize ⼩于 corePoolSize，则创建新线程执⾏任务。</li><li>如果当前池⼤⼩poolSize⼤于corePoolSize，且等待队列未满，则进⼊等待队列。</li><li>如果当前池⼤⼩ poolSize ⼤于 corePoolSize 且⼩于 maximumPoolSize ，且等待队列已满，则创建新线程执⾏任务。</li><li>如果当前池⼤⼩ poolSize ⼤于 corePoolSize 且⼤于 maximumPoolSize ，且等待队列已满，则调⽤拒绝策略来处理该任务。<ul><li>线程池⾥的每个线程执⾏完任务后不会⽴刻退出，⽽是会去检查下等待队列⾥是否还有线程任务需要执⾏，如果在 keepAliveTime ⾥等不到新的任务了，那么线程就会退出。</li></ul></li></ul></li></ul><a id="more"></a><h3 id="线程池任务执行的主要流程"><a href="#线程池任务执行的主要流程" class="headerlink" title="线程池任务执行的主要流程"></a>线程池任务执行的主要流程</h3><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B.png"></p><h3 id="execute-VS-submit"><a href="#execute-VS-submit" class="headerlink" title="execute() VS submit()"></a>execute() VS submit()</h3><blockquote><p>execute() 和 submit() 都是用来执行线程池任务的，它们最主要的区别是，submit() 方法可以接收线程池执行的返回值，而 execute() 不能接收返回值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">10</span>, <span class="number">10L</span>,</span><br><span class="line">        TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">20</span>));</span><br><span class="line"><span class="comment">// execute 使用</span></span><br><span class="line">executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, execute."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// submit 使用</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, submit."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(future.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">//Hello, submit.</span></span><br><span class="line"><span class="comment">//Hello, execute.</span></span><br><span class="line"><span class="comment">//Success</span></span><br></pre></td></tr></table></figure><h3 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h3><blockquote><p>当线程池中的任务队列已经被存满，再有任务添加时会先判断当前线程池中的线程数是否大于等于线程池的最大值，如果是，则会触发线程池的拒绝策略。</p></blockquote><ul><li><p>Java 自带的拒绝策略有 4 种：</p></li><li><p>AbortPolicy，终止策略，线程池会抛出异常并终止执行，它是默认的拒绝策略。</p></li><li><p>CallerRunsPolicy，把任务交给当前线程来执行。</p></li><li><p>DiscardPolicy，忽略此任务（最新的任务）。</p></li><li><p>DiscardOldestPolicy，忽略最早的任务（最先加入队列的任务）。</p></li><li><p>演示AbortPolicy</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">        TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()); <span class="comment">// 添加 AbortPolicy 拒绝策略</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-2</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task com.lagou.interview.ThreadPoolExample$$Lambda$1&#x2F;1096979270@448139f0 rejected from java.util.concurrent.ThreadPoolExecutor@7cca494b[Running, pool size &#x3D; 3, active threads &#x3D; 3, queued tasks &#x3D; 2, completed tasks &#x3D; 0]</span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)</span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)</span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)</span><br><span class="line"> at com.lagou.interview.ThreadPoolExample.rejected(ThreadPoolExample.java:35)</span><br><span class="line"> at com.lagou.interview.ThreadPoolExample.main(ThreadPoolExample.java:26)</span><br></pre></td></tr></table></figure><ul><li>第 6 个任务来的时候，线程池则执行了 AbortPolicy  拒绝策略，抛出了异常。因为队列最多存储 2 个任务，最大可以创建 3 个线程来执行任务（2+3=5），所以当第 6 个任务来的时候，此线程池就“忙”不过来了。</li></ul><h3 id="如果你提交任务时，线程池队列已满。会时发会⽣什么？"><a href="#如果你提交任务时，线程池队列已满。会时发会⽣什么？" class="headerlink" title="如果你提交任务时，线程池队列已满。会时发会⽣什么？"></a>如果你提交任务时，线程池队列已满。会时发会⽣什么？</h3><ul><li>⼀个任务不能被调度执⾏那么ThreadPoolExecutor’s submit()⽅法将会抛出⼀个RejectedExecutionException异常。</li></ul><h3 id="Java线程池中submit-和-execute-⽅法有什么区别？"><a href="#Java线程池中submit-和-execute-⽅法有什么区别？" class="headerlink" title="Java线程池中submit() 和 **execute()**⽅法有什么区别？"></a><strong>Java</strong>线程池中<strong>submit()</strong> 和 **execute()**⽅法有什么区别？</h3><ul><li>两个⽅法都可以向线程池提交任务，execute()⽅法的返回类型是void，它定义在Executor接⼝中, ⽽submit()⽅法可以返回持有计算结果的Future对象，它定义在ExecutorService接⼝中，它扩展了Executor接⼝，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些⽅法。</li></ul><h3 id="如何合理的配置java线程池？"><a href="#如何合理的配置java线程池？" class="headerlink" title="如何合理的配置java线程池？"></a>如何合理的配置<strong>java</strong>线程池？</h3><ul><li><p>如CPU密集型的任务，基本线程池应该配置多⼤？IO密集型的任务，基本线程池应该配置多⼤？⽤有界队列好还是⽆界队列好？任务⾮常多的时候，使⽤什么阻塞队列能获取最好的吞吐量？</p><ul><li>配置线程池时CPU密集型任务可以少配置线程数，⼤概和机器的cpu核数相当，可以使得每个线程都在执⾏任务</li><li>IO密集型时，⼤部分线程都阻塞，故需要多配置线程数，2*cpu核数</li><li>有界队列和⽆界队列的配置需区分业务场景，⼀般情况下配置有界队列，在⼀些可能会有爆发性增⻓的情况下使⽤⽆界队列。</li><li>任务⾮常多时，使⽤⾮阻塞队列使⽤CAS操作替代锁可以获得好的吞吐量。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本章属于持续学习、长期更修。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://z201.cn/2019/02/27/%E5%88%9D%E6%8E%A2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;初探Java多线程&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://z201.cn/2020/07/30/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试题-多线程&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;为避免线程频繁创建和销毁带来的性能问题，而池化的一种方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;利用线程池管理并复用线程、控制最大并发数等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现任务线程队列缓存策略和拒绝机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现某些与时间相关的功能，如定时执行、周期执行等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;隔离线程环境。比如，交易服务和搜索服务在同一台服务器上，分别开启两个线程池，交易线程的资源消耗明显要大；因此，通过配置独立的线程池将较慢的交易服务与搜索服务隔离开，避免各服务线程相互影响。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这里直接参考阿里巴巴的手册。线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的读者更加明确线程池的运行规则，规避资源耗尽的风险。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;常⽤线程池：ExecutorService-是主要的实现类&quot;&gt;&lt;a href=&quot;#常⽤线程池：ExecutorService-是主要的实现类&quot; class=&quot;headerlink&quot; title=&quot;常⽤线程池：ExecutorService 是主要的实现类&quot;&gt;&lt;/a&gt;常⽤线程池：ExecutorService 是主要的实现类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Executors.newSingleT hreadPool()&lt;/li&gt;
&lt;li&gt;newFixedThreadPool()&lt;/li&gt;
&lt;li&gt;newcachedTheadPool()&lt;/li&gt;
&lt;li&gt;newScheduledThreadPool()&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Executors-返回的线程池对象的弊端&quot;&gt;&lt;a href=&quot;#Executors-返回的线程池对象的弊端&quot; class=&quot;headerlink&quot; title=&quot;Executors 返回的线程池对象的弊端&quot;&gt;&lt;/a&gt;Executors 返回的线程池对象的弊端&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。&lt;/li&gt;
&lt;li&gt;CachedThreadPool 和 ScheduledThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。&lt;/li&gt;
&lt;li&gt;查看 Executors 的源码会发现，Executors.newFixedThreadPool()、Executors.newSingleThreadExecutor() 和 Executors.newCachedThreadPool() 等方法的底层都是通过 ThreadPoolExecutor 实现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;ThreadPoolExecutor的核心参数&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor的核心参数&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor的核心参数&quot;&gt;&lt;/a&gt;ThreadPoolExecutor的核心参数&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; corePoolSize,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maximumPoolSize,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; keepAliveTime,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          TimeUnit unit,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          ThreadFactory threadFactory,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          RejectedExecutionHandler handler)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (corePoolSize &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// maximumPoolSize 必须大于 0，且必须大于 corePoolSize&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        maximumPoolSize &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        maximumPoolSize &amp;lt; corePoolSize ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        keepAliveTime &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (workQueue == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || threadFactory == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || handler == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.acc = System.getSecurityManager() == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            AccessController.getContext();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.corePoolSize = corePoolSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maximumPoolSize = maximumPoolSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.workQueue = workQueue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.keepAliveTime = unit.toNanos(keepAliveTime);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.threadFactory = threadFactory;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.handler = handler;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;第 1 个参数：corePoolSize 表示线程池的常驻核心线程数。如果设置为 0，则表示在没有任何任务时，销毁线程池；如果大于 0，即使没有任务时也会保证线程池的线程数量等于此值。但需要注意，此值如果设置的比较小，则会频繁的创建和销毁线程（创建和销毁的原因会在本课时的下半部分讲到）；如果设置的比较大，则会浪费系统资源，所以开发者需要根据自己的实际业务来调整此值。&lt;/li&gt;
&lt;li&gt;第 2 个参数：maximumPoolSize 表示线程池在任务最多时，最大可以创建的线程数。官方规定此值必须大于 0，也必须大于等于 corePoolSize，此值只有在任务比较多，且不能存放在任务队列时，才会用到。&lt;/li&gt;
&lt;li&gt;第 3 个参数：keepAliveTime 表示线程的存活时间，当线程池空闲时并且超过了此时间，多余的线程就会销毁，直到线程池中的线程数量销毁的等于 corePoolSize 为止，如果 maximumPoolSize 等于 corePoolSize，那么线程池在空闲的时候也不会销毁任何线程。&lt;/li&gt;
&lt;li&gt;第 4 个参数：unit 表示存活时间的单位，它是配合 keepAliveTime 参数共同使用的。&lt;/li&gt;
&lt;li&gt;第 5 个参数：workQueue 表示线程池执行的任务队列，当线程池的所有线程都在处理任务时，如果来了新任务就会缓存到此任务队列中排队等待执行。&lt;/li&gt;
&lt;li&gt;第 6 个参数：threadFactory 表示线程的创建工厂，此参数一般用的比较少，我们通常在创建线程池时不指定此参数，它会使用默认的线程创建工厂的方法来创建线程。&lt;/li&gt;
&lt;li&gt;第 7 个参数：RejectedExecutionHandler 表示指定线程池的拒绝策略，当线程池的任务已经在缓存队列 workQueue 中存储满了之后，并且不能创建新的线程来执行此任务时，就会用到此拒绝策略，它属于一种限流保护的机制。&lt;/li&gt;
&lt;li&gt;原理&lt;ul&gt;
&lt;li&gt;如果当前池⼤⼩ poolSize ⼩于 corePoolSize，则创建新线程执⾏任务。&lt;/li&gt;
&lt;li&gt;如果当前池⼤⼩poolSize⼤于corePoolSize，且等待队列未满，则进⼊等待队列。&lt;/li&gt;
&lt;li&gt;如果当前池⼤⼩ poolSize ⼤于 corePoolSize 且⼩于 maximumPoolSize ，且等待队列已满，则创建新线程执⾏任务。&lt;/li&gt;
&lt;li&gt;如果当前池⼤⼩ poolSize ⼤于 corePoolSize 且⼤于 maximumPoolSize ，且等待队列已满，则调⽤拒绝策略来处理该任务。&lt;ul&gt;
&lt;li&gt;线程池⾥的每个线程执⾏完任务后不会⽴刻退出，⽽是会去检查下等待队列⾥是否还有线程任务需要执⾏，如果在 keepAliveTime ⾥等不到新的任务了，那么线程就会退出。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://z201.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="Java多线程" scheme="https://z201.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>面试题-Jdk基础</title>
    <link href="https://z201.github.io/2020/06/30/%E9%9D%A2%E8%AF%95%E9%A2%98-Jdk%E5%9F%BA%E7%A1%80/"/>
    <id>https://z201.github.io/2020/06/30/%E9%9D%A2%E8%AF%95%E9%A2%98-Jdk%E5%9F%BA%E7%A1%80/</id>
    <published>2020-06-30T09:56:39.000Z</published>
    <updated>2020-08-02T18:35:17.644Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章属于持续学习、长期更修。</p></blockquote><h3 id="String、StringBuffer、StringBuilder的区别"><a href="#String、StringBuffer、StringBuilder的区别" class="headerlink" title="String、StringBuffer、StringBuilder的区别"></a>String、StringBuffer、StringBuilder的区别</h3><ul><li>可变性<ul><li>String 是不可变的，StringBuffer\StringBuilder是可变的。</li><li>String 类中使用 final 关键字字符数组保存字符串，<code>private　final　char　value[]</code>，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</li></ul></li><li>线程安全方面<ul><li>String 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，但是StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 </li></ul></li><li>性能<ul><li>操作少量的数据 = String</li><li>单线程操作字符串缓冲区下操作大量数据 = StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据 = StringBuffer</li></ul></li></ul><h3 id="为什么-String-类型要用-final-修饰？"><a href="#为什么-String-类型要用-final-修饰？" class="headerlink" title="为什么 String 类型要用 final 修饰？"></a>为什么 String 类型要用 final 修饰？</h3><blockquote><p> 使用 final 修饰的第一个好处是安全；第二个好处是高效，以 JVM 中的字符串常量池来举例，如下两个变量：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String s1 = <span class="string">"java"</span>;</span><br><span class="line">  String s2 = <span class="string">"java"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以上两个局部变量都存在了常量池中</span></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// new出来的对象不会放到常量池中,内存地址是不同的</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String();</span><br><span class="line">        String s4 = <span class="keyword">new</span> String();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串的比较不可以使用双等号,这样会比较内存地址</span></span><br><span class="line"><span class="comment">     * 字符串比较应当用equals,可见String重写了equals</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s3.equals(s4)); <span class="comment">// true</span></span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只有字符串是不可变时，我们才能实现字符串常量池，字符串常量池可以为我们缓存字符串，提高程序的运行效率，如下图所示：</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/String%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0.png"></p><ul><li><strong>工作原理</strong></li></ul><p>　　当代码中出现字面量形式创建字符串对象时，JVM首先会对这个字面量进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回，否则新的字符串对象被创建，然后将这个引用放入字符串常量池，并返回该引用。</p><a id="more"></a><h3 id="和-equals"><a href="#和-equals" class="headerlink" title="== 和 equals"></a>== 和 equals</h3><ul><li><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</p></li><li><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li><li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li><li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li></ul></li></ul><h3 id="i-和-i有什么区别"><a href="#i-和-i有什么区别" class="headerlink" title="i++和++i有什么区别"></a>i++和++i有什么区别</h3><ul><li>i++ 是在程序执行完毕后进行自增，而 ++i 是在程序开始执行前进行自增。<ul><li><strong>i++ 的操作分三步</strong><ul><li>栈中取出 i</li><li>i 自增 1</li><li>将 i 存到栈</li><li>三个阶段：内存到寄存器，寄存器自增，写回内存（这三个阶段中间都可以被中断分离开）</li><li>所以 i++ 不是原子操作，上面的三个步骤中任何一个步骤同时操作，都可能导致 i 的值不正确自增。</li></ul></li><li><strong>++i</strong><ul><li>在多核的机器上，CPU 在读取内存 i 时也会可能发生同时读取到同一值，这就导致两次自增，实际只增加了一次。</li><li>i++ 和 ++i 都不是原子操作。</li></ul></li><li><strong>原子性</strong>：指的是一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程打断。</li></ul></li></ul><h3 id="Java-的四种引用，强弱软虚"><a href="#Java-的四种引用，强弱软虚" class="headerlink" title="Java**的四种引用，强弱软虚**"></a><strong>Java**</strong>的四种引用，强弱软虚**</h3><ul><li><p>强引用</p><ul><li>强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用方式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"str"</span>);</span><br></pre></td></tr></table></figure></li><li><p>软引用</p><ul><li>软引用在程序内存不足时，会被回收，使用方式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的， </span></span><br><span class="line"><span class="comment">// 这里的软引用指的是指向new String("str")的引用，也就是SoftReference类中T </span></span><br><span class="line">SoftReference&lt;String&gt; wrf = <span class="keyword">new</span> SoftReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"str"</span>));</span><br><span class="line"><span class="comment">// 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。</span></span><br></pre></td></tr></table></figure></li><li><p>弱引用</p><ul><li>弱引用就是只要JVM垃圾回收器发现了它，就会将之回收，使用方式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;String&gt; wrf = <span class="keyword">new</span> WeakReference&lt;String&gt;(str);</span><br><span class="line"><span class="comment">// Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用</span></span><br><span class="line"><span class="comment">// 不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作</span></span><br></pre></td></tr></table></figure></li><li><p>虚引用</p><p>虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中。其它引用是被JVM回收后才被传入 ReferenceQueue 中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue ，使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; prf = <span class="keyword">new</span> PhantomReference&lt;String&gt;(<span class="keyword">new</span> String(<span class="string">"str"</span>), <span class="keyword">new</span> ReferenceQueue&lt;&gt;());</span><br><span class="line"><span class="comment">// 对象销毁前的一些操作，比如说资源释放等。** Object.finalize() 虽然也可以做这类动作，但是这个方式即不安全又低效x</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="为什么要重写equals和hashcode方法"><a href="#为什么要重写equals和hashcode方法" class="headerlink" title="为什么要重写equals和hashcode方法"></a>为什么要重写equals和hashcode方法</h3><ul><li>equals是Object的成员方法，默认不重写（<em>override</em>）情况下判断等价性。<ul><li>类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li><li>类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</p><ul><li>集合中使用场景。<ul><li>将对象放入到集合中时，首先判断要放入对象的 hashCode 值与集合中的任意一个元素的 hashCode 值是否相等，如果不相等直接将该对象放入集合中。</li><li>如果 hashCode 值相等，然后再通过 equals 方法判断要放入对象与集合中的任意一个对象是否相等，如果 equals 判断不相等，直接将该元素放入到集合中，否则不放入。</li></ul></li></ul></li><li><p>hashCode（）与equals（）的相关规定</p><ol><li>如果两个对象相等，则hashcode一定也是相同的。</li><li>两个对象相等,对两个对象分别调用equals方法都返回true。</li><li>两个对象有相同的hashcode值，它们也不一定是相等的。</li><li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong>。</li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol></li></ul><h3 id="描述下final-与-finally、finalize的区别。"><a href="#描述下final-与-finally、finalize的区别。" class="headerlink" title="描述下final 与 finally、finalize的区别。"></a>描述下final 与 finally、finalize的区别。</h3><ul><li><p><code>final</code> ，是修饰符关键字。</p><ul><li><p>如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在new一个对象时初始化（即只能在声明变量或构造器或代码块内初始化），而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能覆盖(重写)。</p><ul><li><p>父类的private成员方法是不能被子类覆盖的，因为被private修饰的方法默认是final类型的。</p></li><li><p>final类</p><ul><li>final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。</li></ul></li><li><p>final方法</p><ul><li>如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。</li></ul></li><li><p>final变量（常量）</p><ul><li>用final修饰的成员变量表示常量，值一旦给定就无法改变！</li><li>final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。</li><li>final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。类中的final数据成员就可以根据依赖对象而有所不同，并保持其恒定不变的特征。</li></ul></li><li><p>final参数</p><ul><li>当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。</li></ul></li><li><p><strong>注意final 不是immutable的</strong></p></li></ul></li></ul></li><li><p><code>finally</code>在异常处理时提供 <code>finally</code> 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 <code>catch</code> 子句就会执行，然后控制就会进入 <code>finally</code> 块（如果有的话）。</p><ul><li>在异常处理时提供 finally 块来执行任何清除操作。只有在与 finally 相对应的 try 语句块得到执行的情况下，finally 语句块才会执行。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。</li><li>finally 语句块可能是要执行的。<ul><li>当try流程中出现程序中断情况是不会在执行finally语句的。也就是说一个线程在执行 try 语句块或者 catch 语句块时被打断（interrupted）或者被终止（killed），与其相对应的 finally 语句块可能不会执行。还有更极端的情况，就是在线程运行 try 语句块或者 catch 语句块时，突然死机或者断电，finally 语句块肯定不会执行了。</li></ul></li></ul></li><li><p><code>finalize</code> ，是方法名。</p><ul><li>Java 允许使用 <code>#finalize()</code> 方法，在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。</li></ul></li></ul><h3 id="finally对应的try-catch语句流程"><a href="#finally对应的try-catch语句流程" class="headerlink" title="finally对应的try catch语句流程"></a>finally对应的try catch语句流程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           System.out.println(<span class="string">"try block"</span>);  </span><br><span class="line">           <span class="keyword">return</span> ;  </span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">           System.out.println(<span class="string">"finally block"</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">    &#125; </span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//try block </span></span><br><span class="line"><span class="comment">//finally block</span></span><br></pre></td></tr></table></figure><p>从结果看finally语句会在return之前执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"return value of test(): "</span> + test()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;  </span><br><span class="line">    System.out.println(<span class="string">"try block"</span>);</span><br><span class="line">        i = <span class="number">1</span> / <span class="number">0</span>; <span class="comment">//抛一个异常进catch</span></span><br><span class="line">     <span class="keyword">return</span> i;  </span><br><span class="line"> &#125;<span class="keyword">catch</span> (Exception e)&#123; </span><br><span class="line">    System.out.println(<span class="string">"exception block"</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line"> &#125;<span class="keyword">finally</span> &#123;  </span><br><span class="line">    System.out.println(<span class="string">"finally block"</span>);  </span><br><span class="line"> &#125; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//try block</span></span><br><span class="line"><span class="comment">//exception block</span></span><br><span class="line"><span class="comment">//finally block</span></span><br><span class="line"><span class="comment">//return value of test(): 2</span></span><br></pre></td></tr></table></figure><p> 从结果看finally 语句块在 catch 语句块中的 return 语句之前执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"return value of test(): "</span> + test()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"finally"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>; </span><br><span class="line">      <span class="keyword">try</span> &#123; </span><br><span class="line">         i = <span class="number">4</span>; </span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">         i++; </span><br><span class="line">         <span class="keyword">return</span> i; </span><br><span class="line">      &#125;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//return value of test(): 5</span></span><br></pre></td></tr></table></figure><p>从结果看 finally 语句块中如果出现return那么该流程就结束了。其实是finally块中的return语句会覆盖try块中的return返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"return value of test3(): "</span> + test()); </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"try block"</span>);</span><br><span class="line">        b += <span class="number">80</span>;</span><br><span class="line">        <span class="keyword">return</span> b; </span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">"catch block"</span>);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"finally block"</span>);</span><br><span class="line">        <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">           b += <span class="number">100</span>;</span><br><span class="line">           System.out.println(<span class="string">"b&gt;25 and b = "</span> + b);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> b;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">//try block</span></span><br><span class="line"><span class="comment">//finally block</span></span><br><span class="line"><span class="comment">//b&gt;25 and b = 200</span></span><br><span class="line"><span class="comment">//return value of test(): 100</span></span><br></pre></td></tr></table></figure><p>从结果看:weary:为什么不返回200！为什么finally里面的修改没有效果？因为finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变。那什么情况下会改变呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"return value of test3(): "</span> + test()); </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">"try block"</span>);</span><br><span class="line">           b += <span class="number">80</span>;</span><br><span class="line">           b = b / <span class="number">0</span>; <span class="comment">//抛异常</span></span><br><span class="line">           <span class="keyword">return</span> b; </span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           System.out.println(<span class="string">"catch block"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">finally</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">"finally block"</span>);</span><br><span class="line">           <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">            b += <span class="number">100</span>;</span><br><span class="line">               System.out.println(<span class="string">"b&gt;25 and b = "</span> + b);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//try block</span></span><br><span class="line"><span class="comment">//catch block</span></span><br><span class="line"><span class="comment">//finally block</span></span><br><span class="line"><span class="comment">//b&gt;25 and b = 200</span></span><br><span class="line"><span class="comment">//return value of test(): 200</span></span><br></pre></td></tr></table></figure><p>从结果看finally里面的修改启效果了，因为抛出了异常所以没有执行try代码块里面的return。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"return value of test3(): "</span> + test()); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             System.out.println(<span class="string">"try block"</span>);</span><br><span class="line">             b += <span class="number">80</span>;</span><br><span class="line">             b = b / <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">return</span> b; </span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             System.out.println(<span class="string">"catch block"</span>);</span><br><span class="line">             <span class="keyword">return</span> b += <span class="number">10</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">finally</span> &#123;</span><br><span class="line">             System.out.println(<span class="string">"finally block"</span>);</span><br><span class="line">             <span class="keyword">if</span> (b &gt; <span class="number">25</span>) &#123;</span><br><span class="line">                b += <span class="number">100</span>;</span><br><span class="line">                 System.out.println(<span class="string">"b&gt;25 and b = "</span> + b);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// try block</span></span><br><span class="line"><span class="comment">// catch block</span></span><br><span class="line"><span class="comment">// finally block</span></span><br><span class="line"><span class="comment">// b&gt;25 and b = 210</span></span><br><span class="line"><span class="comment">// return value of test(): 110</span></span><br><span class="line"><span class="comment">// 从结果来看，抛出异常后return 方法执行之前，也运行了finally代码块，但是并未影响catch代码块中的返回值。</span></span><br></pre></td></tr></table></figure><ul><li>finally块的语句在try或catch中的return语句执行之后返回之前执行，finally里的修改语句可能影响也可能不影响try或catch中 return已经确定的返回值，若finally里也有return语句则覆盖try或catch中的return语句直接返回。没有进入try代码块就不会执行finally代码块。</li></ul><h3 id="static-this-super-关键字总结"><a href="#static-this-super-关键字总结" class="headerlink" title="static,this,super 关键字总结"></a>static,this,super 关键字总结</h3><h4 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h4><blockquote><p>static 关键字主要有以下四种使用场景</p></blockquote><ol><li><strong>修饰成员变量和成员方法:</strong> 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：<code>类名.静态变量名</code> <code>类名.静态方法名()</code></li><li><strong>静态代码块:</strong> 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li><li><strong>静态内部类（static修饰类的话只能修饰内部类）：</strong> 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。</li><li><strong>静态导包(用来导入类中的静态资源，1.5之后的新特性):</strong> 格式为：<code>import static</code> 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li></ol><h5 id="修饰成员变量和成员方法-常用"><a href="#修饰成员变量和成员方法-常用" class="headerlink" title="修饰成员变量和成员方法(常用)"></a>修饰成员变量和成员方法(常用)</h5><p>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。</p><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p><p>HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p><p>调用格式：</p><ul><li><code>类名.静态变量名</code></li><li><code>类名.静态方法名()</code></li></ul><p>如果变量或者方法被 private 则代表该属性或者该方法只能在类的内部被访问而不能在类的外部被访问。</p><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//静态变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticBean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello i am java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"StaticBean&#123;"</span>+</span><br><span class="line">                <span class="string">"name="</span> + name + <span class="string">",age="</span> + age +</span><br><span class="line">                <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticBean staticBean = <span class="keyword">new</span> StaticBean(<span class="string">"1"</span>);</span><br><span class="line">        StaticBean staticBean2 = <span class="keyword">new</span> StaticBean(<span class="string">"2"</span>);</span><br><span class="line">        StaticBean staticBean3 = <span class="keyword">new</span> StaticBean(<span class="string">"3"</span>);</span><br><span class="line">        StaticBean staticBean4 = <span class="keyword">new</span> StaticBean(<span class="string">"4"</span>);</span><br><span class="line">        StaticBean.age = <span class="number">33</span>;</span><br><span class="line">        System.out.println(staticBean + <span class="string">" "</span> + staticBean2 + <span class="string">" "</span> + staticBean3 + <span class="string">" "</span> + staticBean4);</span><br><span class="line">        <span class="comment">//StaticBean&#123;name=1,age=33&#125; StaticBean&#123;name=2,age=33&#125; StaticBean&#123;name=3,age=33&#125; StaticBean&#123;name=4,age=33&#125;</span></span><br><span class="line">        StaticBean.SayHello();<span class="comment">//Hello i am java</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h5><p>静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</p><p>静态代码块的格式是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;    </span><br><span class="line">语句体;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p><h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><p>静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：</p><ol><li>它的创建是不需要依赖外围类的创建。</li><li>它不能使用任何外围类的非static成员变量和方法。</li></ol><p>Example（静态内部类实现单例模式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//声明为 private 避免调用默认构造方法创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 <code>getUniqueInstance() </code>方法从而触发 <code>SingletonHolder.INSTANCE</code> 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。</p><p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p><h5 id="静态导包"><a href="#静态导包" class="headerlink" title="静态导包"></a>静态导包</h5><p>格式为：import static</p><p>这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//将Math中的所有静态资源导入，这时候可以直接使用里面的静态方法，而不用通过类名进行调用</span></span><br><span class="line"> <span class="comment">//如果只想导入单一某个静态方法，只需要将换成对应的方法名即可</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;<span class="comment">//换成import static java.lang.Math.max;具有一样的效果</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> max = max(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(max);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="静态方法与非静态方法"><a href="#静态方法与非静态方法" class="headerlink" title="静态方法与非静态方法"></a>静态方法与非静态方法</h5><p>静态方法属于类本身，非静态方法属于从该类生成的每个对象。 如果您的方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。</p><p>Example</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; </span><br><span class="line">       <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"An example string that doesn't depend on i (an instance variable)"</span>;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.i + <span class="number">1</span>;  <span class="comment">//Depends on i</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以像这样调用静态方法：<code>Foo.method1()</code>。 如果您尝试使用这种方法调用 method2 将失败。 但这样可行：<code>Foo bar = new Foo(1);bar.method2();</code></p><p>总结：</p><ul><li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li></ul><h5 id="static-静态代码块与-非静态代码块-构造代码块"><a href="#static-静态代码块与-非静态代码块-构造代码块" class="headerlink" title="static{}静态代码块与{}非静态代码块(构造代码块)"></a><code>static{}</code>静态代码块与<code>{}</code>非静态代码块(构造代码块)</h5><p>相同点： 都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些static变量进行赋值。</p><p>不同点： 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。</p><p>一般情况下,如果有些代码比如一些项目最常用的变量或对象必须在项目启动的时候就执行的时候,需要使用静态代码块,这种代码是主动执行的。如果我们想要设计不需要创建对象就可以调用类中的方法，例如：Arrays类，Character类，String类等，就需要使用静态方法, 两者的区别是 静态代码块是自动执行的而静态方法是被调用的时候才执行的.</p><p>Example：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"默认构造方法！--"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">"非静态代码块！--"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">"静态代码块！--"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"静态方法中的内容! --"</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(<span class="string">"静态方法中的代码块！--"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        Test.test();<span class="comment">//静态代码块！--静态方法中的内容! --静态方法中的代码块！--</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态代码块！--非静态代码块！--默认构造方法！--静态方法中的内容! --静态方法中的代码块！--</span><br></pre></td></tr></table></figure><p>当只执行 <code>Test.test();</code> 时输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态代码块！--静态方法中的内容! --静态方法中的代码块！--</span><br></pre></td></tr></table></figure><p>当只执行 <code>Test test = new Test();</code> 时输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态代码块！--非静态代码块！--默认构造方法！--</span><br></pre></td></tr></table></figure><p>非静态代码块与构造函数的区别是： 非静态代码块是给所有对象进行统一初始化，而构造函数是给对应的对象初始化，因为构造函数是可以多个的，运行哪个构造函数就会建立什么样的对象，但无论建立哪个对象，都会先执行相同的构造代码块。也就是说，构造代码块中定义的是不同对象共性的初始化内容。</p><h4 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h4><p>this关键字用于引用类的当前实例。 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">    Employees[] employees;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">manageEmployees</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalEmp = <span class="keyword">this</span>.employees.length;</span><br><span class="line">        System.out.println(<span class="string">"Total employees: "</span> + totalEmp);</span><br><span class="line">        <span class="keyword">this</span>.report();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，this关键字用于两个地方：</p><ul><li>this.employees.length：访问类Manager的当前实例的变量。</li><li>this.report（）：调用类Manager的当前实例的方法。</li></ul><p>此关键字是可选的，这意味着如果上面的示例在不使用此关键字的情况下表现相同。 但是，使用此关键字可能会使代码更易读或易懂。</p><h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><p>super关键字用于从子类访问父类的变量和方法。 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> number;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">showNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"number = "</span> + number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.number = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">super</span>.showNumber();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，Sub 类访问父类成员变量 number 并调用其其父类 Super 的 <code>showNumber（）</code> 方法。</p><h3 id="使用-this-和-super-要注意的问题"><a href="#使用-this-和-super-要注意的问题" class="headerlink" title="使用 this 和 super 要注意的问题"></a>使用 this 和 super 要注意的问题</h3><ul><li>在构造器中使用 <code>super（）</code> 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。</li><li>this、super不能用在static方法中。</li></ul><p><strong>简单解释一下：</strong></p><ul><li>被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享。而 this 代表对本类对象的引用，指向本类对象；而 super 代表对父类对象的引用，指向父类对象；所以， <strong>this和super是属于对象范畴的东西，而静态方法是属于类范畴的东西</strong>。</li></ul><h3 id="Java程序初始化的顺序是怎么样的"><a href="#Java程序初始化的顺序是怎么样的" class="headerlink" title="Java程序初始化的顺序是怎么样的"></a>Java程序初始化的顺序是怎么样的</h3><p>　在 Java 语言中，当实例化对象时，对象所在类的所有成员变量首先要进行初始化，只有当所有类成员完成初始化后，才会调用对象所在类的构造函数创建象。</p><p><strong>初始化一般遵循3个原则：</strong></p><ul><li>静态对象（变量）优先于非静态对象（变量）初始化，静态对象（变量）只初始化一次，而非静态对象（变量）可能会初始化多次；</li><li>父类优先于子类进行初始化；</li><li>按照成员变量的定义顺序进行初始化。 即使变量定义散布于方法定义之中，它们依然在任何方法（包括构造函数）被调用之前先初始化；</li></ul><p><strong>加载顺序</strong></p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><p><strong>实例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.父类静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Base static block!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.父类非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Base block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.父类构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Base constructor!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.子类静态代码块</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Derived static block!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5.子类非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"Derived block!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.子类构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Derived</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Derived constructor!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Derived();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Base <span class="keyword">static</span> block!</span><br><span class="line">Derived <span class="keyword">static</span> block!</span><br><span class="line">Base block</span><br><span class="line">Base constructor!</span><br><span class="line">Derived block!</span><br><span class="line">Derived constructor!</span><br></pre></td></tr></table></figure><h3 id="介绍下异常类型"><a href="#介绍下异常类型" class="headerlink" title="介绍下异常类型"></a>介绍下异常类型</h3><ul><li>Throwable <ul><li>Error</li><li>Exception<ul><li>RuntimeException</li><li>IOException</li></ul></li></ul></li><li>超类Throwable ，有两个子类Error和Exception，分别表示错误和异常。<ul><li>Error是程序无法处理的错误，比如OutOfMemoryError等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</li><li>Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。<ul><li>运行时异常(RuntimeException)和非运行时异常也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）,这两种异常有很大的区别。</li><li>RuntimeException(运行时异常)，表示无法让程序恢复的异常，导致的原因通常是因为执行了错误的操作，建议终止逻辑，因此，编译器不检查这些异常。</li><li>CheckedException(受检查异常)，是表示程序可以处理的异常，也即表示程序可以修复（由程序自己接受异常并且做出处理），所以称之为受检查异常。</li></ul></li></ul></li></ul><h3 id="Throw-和-throws-的区别"><a href="#Throw-和-throws-的区别" class="headerlink" title="Throw 和 throws 的区别"></a><strong>Throw 和 throws 的区别</strong></h3><ul><li><p><code>throw</code> ，用于在程序中显式地抛出一个异常。</p></li><li><p><code>throws</code> ，用于指出在该方法中没有处理的异常。<strong>每个方法必须显式指明哪些异常没有处理，以便该方法的调用者可以预防可能发生的异常</strong>。最后，多个异常用逗号分隔。</p></li><li><p><strong>位置不同</strong></p><ul><li>throws 用在函数上，后面跟的是异常类，可以跟多个；而 throw 用在函数内，后面跟的是异常对象。</li></ul></li><li><p><strong>功能不同</strong></p><ul><li>throws 用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式；throw 抛出具体的问题对象，执行到 throw，功能就已经结束了，跳转到调用者，并将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语句，因为执行不到。</li><li>throws 表示出现异常的一种可能性，并不一定会发生这些异常；throw 则是抛出了异常，执行 throw 则一定抛出了某种异常对象。</li></ul></li></ul><h3 id="描述下异常处理方式"><a href="#描述下异常处理方式" class="headerlink" title="描述下异常处理方式"></a>描述下异常处理方式</h3><ul><li>使用System.out.println是高代价的，这这做会降低系统吞吐量。</li><li>在生成环境中避免使用printStackTrace()方法，printStackTrace默认会把调用的堆栈打印到控制台上，在生产环境中访问控制台是不现实的。</li><li>如果不能处理异常，就不要捕获该异常。</li><li>如果要捕获异常，应在最近的地方捕获它。</li><li>不要吃掉你的捕捉的异常信息，就是捕获了啥也不做，建议LOG记录。</li><li>不要将异常处理用于正常的控制流（设计良好的 API 不应该强迫它的调用者为了正常的控制流而使用异常）。</li><li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常。</li><li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）。</li><li>优先使用标准的异常。</li><li>每个方法抛出的异常都要有文档。</li><li>保持异常的原子性</li><li>不要在 <code>catch</code> 中忽略掉捕获到的异常。</li></ul><h3 id="常见的几种异常"><a href="#常见的几种异常" class="headerlink" title="常见的几种异常"></a>常见的几种异常</h3><ul><li>NullPointerException</li><li>IndexOutOfBoundsException</li><li>ClassCastException</li><li>ArrayStoreException</li><li>BufferOverflowException</li></ul><h3 id="如何正确的在一个循环中删除ArrayList中的元素。"><a href="#如何正确的在一个循环中删除ArrayList中的元素。" class="headerlink" title="如何正确的在一个循环中删除ArrayList中的元素。"></a>如何正确的在一个循环中删除ArrayList中的元素。</h3><ul><li><p>如果使用普通for循环直接删除会出现IndexOutOfBoundsException异常，非法索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"1"</span>);</span><br><span class="line">list.add(<span class="string">"2"</span>);</span><br><span class="line">list.add(<span class="string">"2"</span>);</span><br><span class="line">list.add(<span class="string">"2"</span>);</span><br><span class="line">list.add(<span class="string">"3"</span>);</span><br><span class="line">list.add(<span class="string">"4"</span>);</span><br><span class="line">list.add(<span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样做肯定抛异常，非法访问数据越界</span></span><br><span class="line"><span class="keyword">int</span> len = list.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="string">"1"</span>.equals(list.get(i)))&#123;</span><br><span class="line">    list.remove(i);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Exception in thread "main" java.lang.IndexOutOfBoundsException: Index: 4, Size: 4</span></span><br><span class="line"><span class="comment">//改进后,删除元素后更新List长度，更新循环下标。但是这样的可读性很差。而且不适用于多线程场景</span></span><br><span class="line"><span class="keyword">int</span> len = list.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="string">"1"</span>.equals(list.get(i)))&#123;</span><br><span class="line">    list.remove(i);</span><br><span class="line">    --len;</span><br><span class="line">    --i;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另外一种方式，这种看起来好读多了。。。</span></span><br><span class="line">Iterator&lt;String&gt; sListIterator = list.iterator();  </span><br><span class="line"><span class="keyword">while</span>(sListIterator.hasNext())&#123;  </span><br><span class="line">  String e = sListIterator.next();  <span class="comment">//注意了</span></span><br><span class="line">  <span class="keyword">if</span>(e.equals(<span class="string">"1"</span>))&#123;  </span><br><span class="line">  sListIterator.remove();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="什么是-Java-序列化？"><a href="#什么是-Java-序列化？" class="headerlink" title="什么是 Java 序列化？"></a>什么是 Java 序列化？</h3><ul><li>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。</li><li>反序列化的过程，则是和序列化相反的过程。</li><li>对于不想进行序列化的变量，使用transient关键字修饰。<ul><li>transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。transient只能修饰变量，不能修饰类和方法。</li></ul></li></ul><h3 id="介绍Java-反射"><a href="#介绍Java-反射" class="headerlink" title="介绍Java 反射"></a>介绍Java 反射</h3><ul><li><p>反射(Reflection)是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</p></li><li><p>通过反射，可以在程序运行时访问Java对象的成员变量、方法、构造方法。</p></li><li><p>反射的缺点</p><ul><li><strong>性能开销</strong> - 由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。</li><li><strong>破坏封装性</strong> - 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</li><li><strong>内部曝光</strong> - 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。</li></ul></li><li><p><strong>反射的实现方式：</strong></p></li><li><p>第一步：获取Class对象，有4中方法：</p><ul><li>1）Class.forName(“类的路径”)； </li><li>2）类名.class</li><li>3）对象名.getClass()</li><li>4）基本类型的包装类，可以调用包装类的Type属性来获得该包装类的Class对象</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本章属于持续学习、长期更修。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;String、StringBuffer、StringBuilder的区别&quot;&gt;&lt;a href=&quot;#String、StringBuffer、StringBuilder的区别&quot; class=&quot;headerlink&quot; title=&quot;String、StringBuffer、StringBuilder的区别&quot;&gt;&lt;/a&gt;String、StringBuffer、StringBuilder的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;可变性&lt;ul&gt;
&lt;li&gt;String 是不可变的，StringBuffer\StringBuilder是可变的。&lt;/li&gt;
&lt;li&gt;String 类中使用 final 关键字字符数组保存字符串，&lt;code&gt;private　final　char　value[]&lt;/code&gt;，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串&lt;code&gt;char[]value&lt;/code&gt; 但是没有用 final 关键字修饰，所以这两种对象都是可变的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线程安全方面&lt;ul&gt;
&lt;li&gt;String 中的对象是不可变的，也就可以理解为常量，线程安全。&lt;code&gt;AbstractStringBuilder&lt;/code&gt; 是 &lt;code&gt;StringBuilder&lt;/code&gt; 与 &lt;code&gt;StringBuffer&lt;/code&gt; 的公共父类，但是StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;性能&lt;ul&gt;
&lt;li&gt;操作少量的数据 = String&lt;/li&gt;
&lt;li&gt;单线程操作字符串缓冲区下操作大量数据 = StringBuilder&lt;/li&gt;
&lt;li&gt;多线程操作字符串缓冲区下操作大量数据 = StringBuffer&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;为什么-String-类型要用-final-修饰？&quot;&gt;&lt;a href=&quot;#为什么-String-类型要用-final-修饰？&quot; class=&quot;headerlink&quot; title=&quot;为什么 String 类型要用 final 修饰？&quot;&gt;&lt;/a&gt;为什么 String 类型要用 final 修饰？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt; 使用 final 修饰的第一个好处是安全；第二个好处是高效，以 JVM 中的字符串常量池来举例，如下两个变量：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      String s1 = &lt;span class=&quot;string&quot;&gt;&quot;java&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		  String s2 = &lt;span class=&quot;string&quot;&gt;&quot;java&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 以上两个局部变量都存在了常量池中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(s1 == s2); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// new出来的对象不会放到常量池中,内存地址是不同的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String s3 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String s4 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; String();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     	* 字符串的比较不可以使用双等号,这样会比较内存地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     	* 字符串比较应当用equals,可见String重写了equals&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     	*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(s3 == s4); &lt;span class=&quot;comment&quot;&gt;// false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(s3.equals(s4)); &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;只有字符串是不可变时，我们才能实现字符串常量池，字符串常量池可以为我们缓存字符串，提高程序的运行效率，如下图所示：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/String%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工作原理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　当代码中出现字面量形式创建字符串对象时，JVM首先会对这个字面量进行检查，如果字符串常量池中存在相同内容的字符串对象的引用，则将这个引用返回，否则新的字符串对象被创建，然后将这个引用放入字符串常量池，并返回该引用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://z201.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>面试题-Spring</title>
    <link href="https://z201.github.io/2020/06/30/%E9%9D%A2%E8%AF%95%E9%A2%98-Spring/"/>
    <id>https://z201.github.io/2020/06/30/%E9%9D%A2%E8%AF%95%E9%A2%98-Spring/</id>
    <published>2020-06-30T09:56:39.000Z</published>
    <updated>2020-08-02T20:04:32.134Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章属于持续学习、长期更修。</p></blockquote><h3 id="谈谈对Spring理解"><a href="#谈谈对Spring理解" class="headerlink" title="谈谈对Spring理解"></a>谈谈对Spring理解</h3><ul><li>Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。</li><li>主要由以下几个模块组成：<ul><li>Spring Core：核心类库，提供IOC服务</li><li>Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）</li><li>Spring AOP：AOP服务切面编程</li><li>Spring DAO：对JDBC的抽象，简化了数据访问异常的处理</li><li>Spring ORM：对现有的ORM框架的支持</li><li>Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传</li><li>Spring MVC：提供面向Web应用的Model-View-Controller实现</li></ul></li></ul><h3 id="谈谈对-IoC-和-DI-的理解"><a href="#谈谈对-IoC-和-DI-的理解" class="headerlink" title="谈谈对 IoC 和 DI 的理解"></a>谈谈对 IoC 和 DI 的理解</h3><ul><li>IoC（Inversion of Control，翻译为“控制反转”）不是一个具体的技术，而是一种设计思想。与传统控制流相比，IoC 会颠倒控制流，在传统的编程中需要开发者自行创建并销毁对象，而在 IoC 中会把这些操作交给框架来处理，这样开发者就不用关注具体的实现细节了，拿来直接用就可以了，这就是控制反转。</li><li>IoC 很好的体现出了面向对象的设计法则之一——好莱坞法则：“别找我们，我们找你”。即由 IoC 容器帮对象找到相应的依赖对象并注入，而不是由对象主动去找。</li><li>DI（Dependency Injection，翻译为“依赖注入”）表示组件间的依赖关系交由容器在运行期自动生成，也就是说，由容器动态的将某个依赖关系注入到组件之中，这样就能提升组件的重用频率。通过依赖注入机制，我们只需要通过简单的配置，就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心资源来自哪里、由谁实现等问题。</li><li>IoC 和 DI 其实是同一个概念从不同角度的描述的，由于控制反转这个概念比较含糊（可能只理解成了容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以 2004 年被开发者尊称为“教父”的 Martin Fowler（世界顶级专家，敏捷开发方法的创始人之一）又给出了一个新的名字“依赖注入”，相对 IoC 而言，“依赖注入”明确描述了“被注入对象依赖 IoC 容器配置依赖对象”。</li></ul><h3 id="Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="Spring 中的单例 bean 的线程安全问题了解吗？"></a>Spring 中的单例 bean 的线程安全问题了解吗？</h3><ul><li>单例 bean 存在线程问题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程安全问题。在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的⼀种⽅式）。</li></ul><h3 id="Spring框架中都用到了哪些设计模式"><a href="#Spring框架中都用到了哪些设计模式" class="headerlink" title="Spring框架中都用到了哪些设计模式"></a>Spring框架中都用到了哪些设计模式</h3><ul><li>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例</li><li>单例模式：Bean默认为单例模式</li><li>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术</li><li>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate<ul><li>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener    </li></ul></li><li>适配器模式 :Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。</li><li>观察者模式**:** Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。</li></ul><h3 id="Spring中Autowired和Resource关键字的区别？"><a href="#Spring中Autowired和Resource关键字的区别？" class="headerlink" title="Spring中Autowired和Resource关键字的区别？"></a>Spring中Autowired和Resource关键字的区别？</h3><ul><li>@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</li><li>Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualififier注解一起使用：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 下面两种@Autowired只要使用一种即可 </span></span><br><span class="line">  <span class="meta">@Autowired</span> </span><br><span class="line">  <span class="keyword">private</span> UserDao userDao; <span class="comment">// 用于字段上 </span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Autowired</span>  <span class="comment">// 用于属性的方法上</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.userDao = userDao; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允</span></span><br><span class="line"><span class="comment">// 许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结</span></span><br><span class="line"><span class="comment">// 合@Qualifier注解一起使用。如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Autowired</span> </span><br><span class="line">  <span class="meta">@Qualifier</span>(<span class="string">"userDao"</span>) <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> </span>&#123; </span><br><span class="line">  <span class="comment">// 下面两种@Resource只要使用一种即可 </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 用于字段上 </span></span><br><span class="line">  <span class="meta">@Resource</span>(name=<span class="string">"userDao"</span>) </span><br><span class="line">  <span class="keyword">private</span> UserDao userDao; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 用于属性的setter方法上 </span></span><br><span class="line">  <span class="meta">@Resource</span>(name=<span class="string">"userDao"</span>) </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bean注册方式有几种？"><a href="#Bean注册方式有几种？" class="headerlink" title="Bean注册方式有几种？"></a>Bean注册方式有几种？</h3><ul><li>XML 配置文件的注册方式</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.Person"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Java"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Java 注解的注册方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用 @Component 注解方式来注册 Bean</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Integer id;</span><br><span class="line">   <span class="keyword">private</span> String name</span><br><span class="line">   <span class="comment">// 忽略其他方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Bean 注解方式来注册 Bean</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Person  <span class="title">person</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 忽略其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Java API 的注册方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 BeanDefinitionRegistry.registerBeanDefinition() 方法的方式注册 Bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBeanDefinitionRegistry</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">RootBeanDefinition personBean = <span class="keyword">new</span> RootBeanDefinition(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">// 新增 Bean</span></span><br><span class="line">registry.registerBeanDefinition(<span class="string">"person"</span>, personBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Spring-Bean-的作用域有哪些？"><a href="#Spring-Bean-的作用域有哪些？" class="headerlink" title="Spring Bean 的作用域有哪些？"></a>Spring Bean 的作用域有哪些？</h3><ul><li>singleton <ul><li>表示在 Spring 容器中只有一个 Bean 实例，以单例的形式存在，是默认的 Bean 作用域。</li></ul></li><li>prototype<ul><li>原型作用域，每次调用 Bean 时都会创建一个新实例，也就是说每次调用 getBean() 方法时，相当于执行了 new Bean()。</li></ul></li><li>request<ul><li>每次 Http 请求时都会创建一个新的 Bean，该作用域仅适应于 WebApplicationContext 环境。</li></ul></li><li>session<ul><li>同一个 Http Session 共享一个 Bean 对象，不同的 Session 拥有不同的 Bean 对象，仅适用于 WebApplicationContext 环境。</li></ul></li><li>application<ul><li>全局的 Web 作用域，类似于 Servlet 中的 Application。</li></ul></li></ul><h3 id="Bean-生命周期"><a href="#Bean-生命周期" class="headerlink" title="Bean 生命周期"></a>Bean 生命周期</h3><ul><li>对于 Spring Bean 来说，并不是启动阶段就会触发 Bean 的实例化，只有当客户端通过显式或者隐式的方式调用 BeanFactory 的 getBean() 方法时，它才会触发该类的实例化方法。当然对于 BeanFactory 来说，也不是所有的 getBean() 方法都会实例化 Bean 对象，例如作用域为 singleton 时，只会在第一次，实例化该 Bean 对象，之后会直接返回该对象。但如果使用的是ApplicationContext 容器，则会在该容器启动的时候，立即调用注册到该容器所有 Bean 的实例化方法。getBean() 方法是属于 BeanFactory 接口的，它的真正实现是AbstractAutowireCapableBeanFactory 的 createBean() 方法，而 createBean() 是通过 doCreateBean() 来实现的，具体源码实现。</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/springBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><ul><li>实例化Bean<ul><li>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一个尚未初始化的依赖时，容器就会调用createBean进行实例化。对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefifinition对象中的信息，实例化所有的bean。</li></ul></li><li>设置对象属性（依赖注入）<ul><li>实例化后的对象被封装在BeanWrapper对象中，紧接着，Spring根据BeanDefifinition中的信息 以及 通过BeanWrapper提供的设置属性的接口完成依赖注入。     </li></ul></li><li>处理Aware接口<ul><li>接着，Spring会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给Bean。<ul><li>如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String beanId)方法，此处传递的就是Spring配置文件中Bean的id值。</li><li>如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory()方法，传递的是Spring工厂自身。</li><li>如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文。</li></ul></li></ul></li><li>BeanPostProcessor<ul><li>如果想对Bean进行一些自定义的处理，那么可以让Bean实现了BeanPostProcessor接口，那将会调用postProcessBeforeInitialization(Object obj, String s)方法。</li></ul></li><li>InitializingBean 与 init-method<ul><li>如果实现相关方法或者配置了 init-method则会自动调用其配置的初始化方法</li></ul></li><li>BeanPostProcessor<ul><li>如果这个Bean实现了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法；由于这个方法是在Bean初始化结束时调用的，所以可以被应用于内存或缓存技术。</li></ul></li><li>getBean<ul><li>可以正常使用这个bean了。</li></ul></li><li>DisposableBean<ul><li>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法。</li></ul></li><li>destroy-method<ul><li>如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。</li></ul></li></ul><h3 id="Spring中Filter和Interceptor的区别"><a href="#Spring中Filter和Interceptor的区别" class="headerlink" title="Spring中Filter和Interceptor的区别"></a>Spring中Filter和Interceptor的区别</h3><ul><li>Filter是基于函数回调（doFilter()方法）的，而Interceptor则是基于Java反射的（AOP思想）。</li><li>Filter依赖于Servlet容器，而Interceptor不依赖于Servlet容器。</li><li>Filter对几乎所有的请求起作用，而Interceptor只能对action请求起作用。</li><li>Interceptor可以访问Action的上下文，值栈里的对象，而Filter不能。</li><li>在action的生命周期里，Interceptor可以被多次调用，而Filter只能在容器初始化时调用一次。</li><li>Filter在过滤是只能对request和response进行操作，而interceptor可以对request、response、handler、modelAndView、exception进行操作。</li><li>interceptor 的执行顺序大致为：<ul><li>请求到达 DispatcherServlet</li><li>DispatcherServlet 发送至 Interceptor ，执行 preHandle</li><li>请求达到 Controller</li><li>请求结束后，postHandle 执行</li></ul></li><li>Spring 中主要通过 HandlerInterceptor 接口来实现请求的拦截，实现 HandlerInterceptor 接口需要实现下面三个方法：<ul><li><strong>preHandle()</strong> – 在handler执行之前，返回 boolean 值，true 表示继续执行，false 为停止执行并返回。</li><li><strong>postHandle()</strong> – 在handler执行之后, 可以在返回之前对返回的结果进行修改</li><li><strong>afterCompletion()</strong> – 在请求完全结束后调用，可以用来统计请求耗时等等</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.handler.HandlerInterceptorAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecuteTimeInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = Logger.getLogger(ExecuteTimeInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//before the actual handler will be executed</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">request.setAttribute(<span class="string">"startTime"</span>, startTime);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//after the handler is executed</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">Object handler, ModelAndView modelAndView)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> startTime = (Long)request.getAttribute(<span class="string">"startTime"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> executeTime = endTime - startTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">//modified the exisitng modelAndView</span></span><br><span class="line">modelAndView.addObject(<span class="string">"executeTime"</span>,executeTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//log it</span></span><br><span class="line"><span class="keyword">if</span>(logger.isDebugEnabled())&#123;</span><br><span class="line">   logger.debug(<span class="string">"["</span> + handler + <span class="string">"] executeTime : "</span> + executeTime + <span class="string">"ms"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Servlet 的 Filter 接口需要实现如下方法：<ul><li><code>void init(FilterConfig paramFilterConfig)</code> – 当容器初始化 Filter 时调用，该方法在 Filter 的生命周期只会被调用一次，一般在该方法中初始化一些资源，FilterConfig 是容器提供给 Filter 的初始化参数，在该方法中可以抛出 ServletException 。init 方法必须执行成功，否则 Filter 可能不起作用，出现以下两种情况时，web 容器中 Filter 可能无效： 1）抛出 ServletException 2）超过 web 容器定义的执行时间。</li><li><code>doFilter(ServletRequest paramServletRequest, ServletResponse paramServletResponse, FilterChain paramFilterChain)</code> – Web 容器每一次请求都会调用该方法。该方法将容器的请求和响应作为参数传递进来， FilterChain 用来调用下一个 Filter。</li><li><code>void destroy()</code> – 当容器销毁 Filter 实例时调用该方法，可以在方法中销毁资源，该方法在 Filter 的生命周期只会被调用一次。</li></ul></li></ul><h3 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h3><ul><li>编程式事务 代码中硬编码开启事物。</li><li>声明式事务<ul><li>基于注解开启事物。</li><li>基于xml配置文件开启事物。</li></ul></li></ul><h3 id="Spring-事务中的隔离级别有哪⼏种"><a href="#Spring-事务中的隔离级别有哪⼏种" class="headerlink" title="Spring 事务中的隔离级别有哪⼏种?"></a>Spring 事务中的隔离级别有哪⼏种?</h3><blockquote><p><strong>TransactionDefinition</strong> 接⼝中定义了五个表示隔离级别的常量：</p></blockquote><ul><li><p><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong> 使⽤后端数据库默认的隔离级别，Mysql 默认采⽤的 REPEATABLE_READ隔离级别 Oracle 默认采⽤的 READ_COMMITTED隔离级别。</p></li><li><p><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的阻⽌脏读，但是幻读或不可重复读仍有可能发⽣。</p></li><li><p><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣。</p></li><li><p><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。</p></li><li><p><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说，该级别可以防⽌脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会⽤到该级别。</p></li></ul><h3 id="Spring-事务中哪⼏种事务传播⾏为"><a href="#Spring-事务中哪⼏种事务传播⾏为" class="headerlink" title="Spring 事务中哪⼏种事务传播⾏为?"></a>Spring 事务中哪⼏种事务传播⾏为?</h3><ul><li>⽀持当前事务的情况：<ul><li><strong>TransactionDefinition.PROPAGATION_REQUIRED</strong>： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则创建⼀个新的事务。</li><li><strong>TransactionDefinition.PROPAGATION_SUPPORTS</strong>： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则以⾮事务的⽅式继续运⾏。</li><li><strong>TransactionDefinition.PROPAGATION_MANDATORY</strong>： 如果当前存在事务，则加⼊该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li></ul></li><li>不⽀持当前事务的情况：<ul><li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW</strong>： 创建⼀个新的事务，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</strong>： 以⾮事务⽅式运⾏，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NEVER</strong>： 以⾮事务⽅式运⾏，如果当前存在事务，则抛出异常。</li></ul></li><li>其他情况：<ul><li><strong>TransactionDefinition.PROPAGATION_NESTED</strong>： 如果当前存在事务，则创建⼀个事务作为当前事务的嵌套事务来运⾏；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li></ul></li></ul><h3 id="Spring-Boot-启动流程"><a href="#Spring-Boot-启动流程" class="headerlink" title="Spring Boot 启动流程"></a>Spring Boot 启动流程</h3><blockquote><p>Spring Boot 程序的入口是 SpringApplication.run(Application.class, args) 方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建并启动计时监控类</span></span><br><span class="line">    StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">    stopWatch.start();</span><br><span class="line">    <span class="comment">// 2.声明应用上下文对象和异常报告集合</span></span><br><span class="line">    ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">    Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">// 3.设置系统属性 headless 的值</span></span><br><span class="line">    <span class="keyword">this</span>.configureHeadlessProperty();</span><br><span class="line">    <span class="comment">// 4.创建所有 Spring 运行监听器并发布应用启动事件</span></span><br><span class="line">    SpringApplicationRunListeners listeners = <span class="keyword">this</span>.getRunListeners(args);</span><br><span class="line">    listeners.starting();</span><br><span class="line">    Collection exceptionReporters;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 5.处理 args 参数</span></span><br><span class="line">        ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(args);</span><br><span class="line">        <span class="comment">// 6.准备环境</span></span><br><span class="line">        ConfigurableEnvironment environment = <span class="keyword">this</span>.prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">        <span class="keyword">this</span>.configureIgnoreBeanInfo(environment);</span><br><span class="line">        <span class="comment">// 7.创建 Banner 的打印类</span></span><br><span class="line">        Banner printedBanner = <span class="keyword">this</span>.printBanner(environment);</span><br><span class="line">        <span class="comment">// 8.创建应用上下文</span></span><br><span class="line">        context = <span class="keyword">this</span>.createApplicationContext();</span><br><span class="line">        <span class="comment">// 9.实例化异常报告器</span></span><br><span class="line">        exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">        <span class="comment">// 10.准备应用上下文</span></span><br><span class="line">        <span class="keyword">this</span>.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">        <span class="comment">// 11.刷新应用上下文</span></span><br><span class="line">        <span class="keyword">this</span>.refreshContext(context);</span><br><span class="line">        <span class="comment">// 12.应用上下文刷新之后的事件的处理</span></span><br><span class="line">        <span class="keyword">this</span>.afterRefresh(context, applicationArguments);</span><br><span class="line">        <span class="comment">// 13.停止计时监控类</span></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="comment">// 14.输出日志记录执行主类名、时间信息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">            (<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)).logStarted(<span class="keyword">this</span>.getApplicationLog(), stopWatch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 15.发布应用上下文启动完成事件</span></span><br><span class="line">        listeners.started(context);</span><br><span class="line">        <span class="comment">// 16.执行所有 Runner 运行器</span></span><br><span class="line">        <span class="keyword">this</span>.callRunners(context, applicationArguments);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handleRunFailure(context, var10, exceptionReporters, listeners);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var10);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 17.发布应用上下文就绪事件</span></span><br><span class="line">        listeners.running(context);</span><br><span class="line">        <span class="comment">// 18.返回应用上下文对象</span></span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(var9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Spring Boot 的启动流程</p><ul><li><p>1、创建并启动计时监控类</p><ul><li>此计时器是为了监控并记录 Spring Boot 应用启动的时间的，它会记录当前任务的名称，然后开启计时器。</li></ul></li><li><p>2.声明应用上下文对象和异常报告集合</p><ul><li>此过程声明了应用上下文对象和一个异常报告的 ArrayList 集合。</li></ul></li><li><p>3.设置系统属性 headless 的值</p><ul><li>设置 Java.awt.headless = true，其中 awt（Abstract Window Toolkit）的含义是抽象窗口工具集。设置为 true 表示运行一个 headless 服务器，可以用它来作一些简单的图像处理。</li></ul></li><li><p>4.创建所有 Spring 运行监听器并发布应用启动事件</p><ul><li>此过程用于获取配置的监听器名称并实例化所有的类。</li></ul></li><li><p>5.初始化默认应用的参数类</p><ul><li>也就是说声明并创建一个应用参数对象。</li></ul></li><li><p>6.准备环境</p><ul><li>创建配置并且绑定环境（通过 property sources 和 profiles 等配置文件）。</li></ul></li><li><p>7.创建 Banner 的打印类</p><ul><li>就是出个那个logo也可以自己定义。</li></ul></li><li><p>8.创建应用上下文</p><ul><li>根据不同的应用类型来创建不同的 ApplicationContext 上下文对象。</li></ul></li><li><p>9.实例化异常报告器</p><ul><li>它调用的是 getSpringFactoriesInstances() 方法来获取配置异常类的名称，并实例化所有的异常处理类。</li></ul></li><li><p>10.准备应用上下文</p><ul><li>此方法的主要作用是把上面已经创建好的对象，传递给 prepareContext 来准备上下文，例如将环境变量 environment 对象绑定到上下文中、配置 bean 生成器以及资源加载器、记录启动日志等操作。</li></ul></li><li><p>11.刷新应用上下文</p><ul><li>此方法用于解析配置文件，加载 bean 对象，并且启动内置的 web 容器等操作。</li></ul></li><li><p>12.应用上下文刷新之后的事件处理</p><ul><li>这个方法的源码是空的，可以做一些自定义的后置处理操作。</li></ul></li><li><p>13.停止计时监控类</p><ul><li>停止此过程第一步中的程序计时器，并统计任务的执行信息。</li></ul></li><li><p>14.输出日志信息</p><ul><li>把相关的记录信息，如类名、时间等信息进行控制台输出。</li></ul></li><li><p>15.发布应用上下文启动完成事件</p><ul><li>触发所有 SpringApplicationRunListener 监听器的 started 事件方法。</li></ul></li><li><p>16.执行所有 Runner 运行器</p><ul><li>执行所有的 ApplicationRunner 和 CommandLineRunner 运行器。</li></ul></li><li><p>17.发布应用上下文就绪事件</p><ul><li>触发所有的 SpringApplicationRunListener 监听器的 running 事件。</li></ul></li><li><p>18.返回应用上下文对象</p><ul><li>到此为止 Spring Boot 的启动程序就结束了。</li></ul></li></ul></li></ul><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本章属于持续学习、长期更修。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;谈谈对Spring理解&quot;&gt;&lt;a href=&quot;#谈谈对Spring理解&quot; class=&quot;headerlink&quot; title=&quot;谈谈对Spring理解&quot;&gt;&lt;/a&gt;谈谈对Spring理解&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。&lt;/li&gt;
&lt;li&gt;主要由以下几个模块组成：&lt;ul&gt;
&lt;li&gt;Spring Core：核心类库，提供IOC服务&lt;/li&gt;
&lt;li&gt;Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）&lt;/li&gt;
&lt;li&gt;Spring AOP：AOP服务切面编程&lt;/li&gt;
&lt;li&gt;Spring DAO：对JDBC的抽象，简化了数据访问异常的处理&lt;/li&gt;
&lt;li&gt;Spring ORM：对现有的ORM框架的支持&lt;/li&gt;
&lt;li&gt;Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传&lt;/li&gt;
&lt;li&gt;Spring MVC：提供面向Web应用的Model-View-Controller实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;谈谈对-IoC-和-DI-的理解&quot;&gt;&lt;a href=&quot;#谈谈对-IoC-和-DI-的理解&quot; class=&quot;headerlink&quot; title=&quot;谈谈对 IoC 和 DI 的理解&quot;&gt;&lt;/a&gt;谈谈对 IoC 和 DI 的理解&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;IoC（Inversion of Control，翻译为“控制反转”）不是一个具体的技术，而是一种设计思想。与传统控制流相比，IoC 会颠倒控制流，在传统的编程中需要开发者自行创建并销毁对象，而在 IoC 中会把这些操作交给框架来处理，这样开发者就不用关注具体的实现细节了，拿来直接用就可以了，这就是控制反转。&lt;/li&gt;
&lt;li&gt;IoC 很好的体现出了面向对象的设计法则之一——好莱坞法则：“别找我们，我们找你”。即由 IoC 容器帮对象找到相应的依赖对象并注入，而不是由对象主动去找。&lt;/li&gt;
&lt;li&gt;DI（Dependency Injection，翻译为“依赖注入”）表示组件间的依赖关系交由容器在运行期自动生成，也就是说，由容器动态的将某个依赖关系注入到组件之中，这样就能提升组件的重用频率。通过依赖注入机制，我们只需要通过简单的配置，就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心资源来自哪里、由谁实现等问题。&lt;/li&gt;
&lt;li&gt;IoC 和 DI 其实是同一个概念从不同角度的描述的，由于控制反转这个概念比较含糊（可能只理解成了容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以 2004 年被开发者尊称为“教父”的 Martin Fowler（世界顶级专家，敏捷开发方法的创始人之一）又给出了一个新的名字“依赖注入”，相对 IoC 而言，“依赖注入”明确描述了“被注入对象依赖 IoC 容器配置依赖对象”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Spring-中的单例-bean-的线程安全问题了解吗？&quot;&gt;&lt;a href=&quot;#Spring-中的单例-bean-的线程安全问题了解吗？&quot; class=&quot;headerlink&quot; title=&quot;Spring 中的单例 bean 的线程安全问题了解吗？&quot;&gt;&lt;/a&gt;Spring 中的单例 bean 的线程安全问题了解吗？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;单例 bean 存在线程问题，主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程安全问题。在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的⼀种⽅式）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Spring框架中都用到了哪些设计模式&quot;&gt;&lt;a href=&quot;#Spring框架中都用到了哪些设计模式&quot; class=&quot;headerlink&quot; title=&quot;Spring框架中都用到了哪些设计模式&quot;&gt;&lt;/a&gt;Spring框架中都用到了哪些设计模式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例&lt;/li&gt;
&lt;li&gt;单例模式：Bean默认为单例模式&lt;/li&gt;
&lt;li&gt;代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术&lt;/li&gt;
&lt;li&gt;模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate&lt;ul&gt;
&lt;li&gt;观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener    &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;适配器模式 :Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。&lt;/li&gt;
&lt;li&gt;观察者模式**:** Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Spring中Autowired和Resource关键字的区别？&quot;&gt;&lt;a href=&quot;#Spring中Autowired和Resource关键字的区别？&quot; class=&quot;headerlink&quot; title=&quot;Spring中Autowired和Resource关键字的区别？&quot;&gt;&lt;/a&gt;Spring中Autowired和Resource关键字的区别？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。&lt;/li&gt;
&lt;li&gt;Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualififier注解一起使用：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestServiceImpl&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 下面两种@Autowired只要使用一种即可 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Autowired&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; UserDao userDao; &lt;span class=&quot;comment&quot;&gt;// 用于字段上 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Autowired&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// 用于属性的方法上&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setUserDao&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(UserDao userDao)&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;  &lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.userDao = userDao; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// @Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 合@Qualifier注解一起使用。如下：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestServiceImpl&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Autowired&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Qualifier&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;userDao&quot;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; UserDao userDao;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestServiceImpl&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 下面两种@Resource只要使用一种即可 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 用于字段上 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Resource&lt;/span&gt;(name=&lt;span class=&quot;string&quot;&gt;&quot;userDao&quot;&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; UserDao userDao; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 用于属性的setter方法上 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Resource&lt;/span&gt;(name=&lt;span class=&quot;string&quot;&gt;&quot;userDao&quot;&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setUserDao&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(UserDao userDao)&lt;/span&gt; &lt;/span&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.userDao = userDao;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;Bean注册方式有几种？&quot;&gt;&lt;a href=&quot;#Bean注册方式有几种？&quot; class=&quot;headerlink&quot; title=&quot;Bean注册方式有几种？&quot;&gt;&lt;/a&gt;Bean注册方式有几种？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;XML 配置文件的注册方式&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;person&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;org.springframework.beans.Person&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;id&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;property&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;value&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;Java&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;bean&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;Java 注解的注册方式&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 可以使用 @Component 注解方式来注册 Bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Component&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Integer id;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// 忽略其他方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// @Bean 注解方式来注册 Bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;meta&quot;&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Person  &lt;span class=&quot;title&quot;&gt;person&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;// 忽略其他方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;Java API 的注册方式&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 使用 BeanDefinitionRegistry.registerBeanDefinition() 方法的方式注册 Bean	&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CustomBeanDefinitionRegistry&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BeanDefinitionRegistryPostProcessor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;postProcessBeanFactory&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ConfigurableListableBeanFactory beanFactory)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;postProcessBeanDefinitionRegistry&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(BeanDefinitionRegistry registry)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		RootBeanDefinition personBean = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RootBeanDefinition(Person&lt;span class=&quot;class&quot;&gt;.&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// 新增 Bean&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		registry.registerBeanDefinition(&lt;span class=&quot;string&quot;&gt;&quot;person&quot;&lt;/span&gt;, personBean);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://z201.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="Spring" scheme="https://z201.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>面试题-多线程</title>
    <link href="https://z201.github.io/2020/06/30/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://z201.github.io/2020/06/30/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-06-29T16:41:13.000Z</published>
    <updated>2020-08-02T19:46:07.959Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章属于持续学习、长期更修。</p></blockquote><ul><li><a href="https://z201.cn/2019/02/27/%E5%88%9D%E6%8E%A2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">初探Java多线程</a></li></ul><h3 id="线程的状态有哪些？又如何工作的？"><a href="#线程的状态有哪些？又如何工作的？" class="headerlink" title="线程的状态有哪些？又如何工作的？"></a>线程的状态有哪些？又如何工作的？</h3><ul><li><p>线程的状态在枚举的方式被定义在 Thread 的源码中，它总共包含以下 6 个状态：</p><ul><li>NEW，新建状态，线程被创建出来，但尚未启动时的线程状态；</li><li>RUNNABLE，就绪状态，表示可以运行的线程状态，它可能正在运行，或者是在排队等待操作系统给它分配 CPU 资源；</li><li>BLOCKED，阻塞等待锁的线程状态，表示处于阻塞状态的线程正在等待监视器锁，比如等待执行 synchronized 代码块或者使用 synchronized 标记的方法；</li><li>WAITING，等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作，比如，一个线程调用了 Object.wait() 方法，那它就在等待另一个线程调用 Object.notify() 或 Object.notifyAll() 方法；</li><li>TIMED_WAITING，计时等待状态，和等待状态（WAITING）类似，它只是多了超时时间，比如调用了有超时时间设置的方法 Object.wait(long timeout) 和 Thread.join(long timeout) 等这些方法时，它才会进入此状态；</li><li>TERMINATED，终止状态，表示线程已经执行完成。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新建状态，线程被创建出来，但尚未启动时的线程状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 就绪状态，表示可以运行的线程状态，但它在排队等待来自操作系统的 CPU 资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞等待锁的线程状态，表示正在处于阻塞状态的线程</span></span><br><span class="line"><span class="comment">     * 正在等待监视器锁，比如等待执行 synchronized 代码块或者</span></span><br><span class="line"><span class="comment">     * 使用 synchronized 标记的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作。</span></span><br><span class="line"><span class="comment">     * 例如，一个线程调用了 Object.wait() 它在等待另一个线程调用</span></span><br><span class="line"><span class="comment">     * Object.notify() 或 Object.notifyAll()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计时等待状态，和等待状态 (WAITING) 类似，只是多了超时时间，比如</span></span><br><span class="line"><span class="comment">     * 调用了有超时时间设置的方法 Object.wait(long timeout) 和 </span></span><br><span class="line"><span class="comment">     * Thread.join(long timeout) 就会进入此状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 终止状态，表示线程已经执行完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BLOCKED（阻塞等待）和-WAITING（等待）有什么区别？"><a href="#BLOCKED（阻塞等待）和-WAITING（等待）有什么区别？" class="headerlink" title="BLOCKED（阻塞等待）和 WAITING（等待）有什么区别？"></a>BLOCKED（阻塞等待）和 WAITING（等待）有什么区别？</h3><ul><li>虽然 BLOCKED 和 WAITING 都有等待的含义，但二者有着本质的区别，首先它们状态形成的调用方法不同，其次 BLOCKED 可以理解为当前线程还处于活跃状态，只是在阻塞等待其他线程使用完某个锁资源；而 WAITING 则是因为自身调用了 Object.wait() 或着是 Thread.join() 又或者是 LockSupport.park() 而进入等待状态，只能等待其他线程执行某个特定的动作才能被继续唤醒，比如当线程因为调用了 Object.wait() 而进入 WAITING 状态之后，则需要等待另一个线程执行 Object.notify() 或 Object.notifyAll() 才能被唤醒。</li></ul><a id="more"></a><h3 id="start-方法和-run-方法有什么区别？"><a href="#start-方法和-run-方法有什么区别？" class="headerlink" title="start() 方法和 run() 方法有什么区别？"></a>start() 方法和 run() 方法有什么区别？</h3><blockquote><p> Thread 源码来看，start() 方法属于 Thread 自身的方法，并且使用了 synchronized 来保证线程安全，源码如下</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 状态验证，不等于 NEW 的状态会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    <span class="comment">// 通知线程组，此线程即将启动</span></span><br><span class="line"></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">// 不处理任何异常，如果 start0 抛出异常，则它将被传递到调用堆栈上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>run() 方法为 Runnable 的抽象方法，必须由调用类重写此方法，重写的 run() 方法其实就是此线程要执行的业务方法，源码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 忽略其他方法......</span></span><br><span class="line">  <span class="keyword">private</span> Runnable target;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">          target.run();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从执行的效果来说，start() 方法可以开启多线程，让线程从 NEW 状态转换成 RUNNABLE 状态，而 run() 方法只是一个普通的方法。</p><p>其次，它们可调用的次数不同，start() 方法不能被多次调用，否则会抛出 java.lang.IllegalStateException；而 run() 方法可以进行多次调用，因为它只是一个普通的方法而已。</p></blockquote><h3 id="线程的优先级有什么用？该如何设置？"><a href="#线程的优先级有什么用？该如何设置？" class="headerlink" title="线程的优先级有什么用？该如何设置？"></a>线程的优先级有什么用？该如何设置？</h3><blockquote><p>在 Thread 源码中和线程优先级相关的属性有 3 个：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程可以拥有的最小优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程可以拥有的最大优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span></span><br></pre></td></tr></table></figure><blockquote><p>线程的优先级可以理解为线程抢占 CPU 时间片的概率，优先级越高的线程优先执行的概率就越大，但并不能保证优先级高的线程一定先执行。</p><p>在程序中我们可以通过 Thread.setPriority() 来设置优先级，setPriority() 源码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="comment">// 先验证优先级的合理性</span></span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 优先级如果超过线程组的最高优先级，则把优先级设置为线程组的最高优先级</span></span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sleep-和wait-的区别"><a href="#sleep-和wait-的区别" class="headerlink" title="sleep() 和wait()的区别"></a>sleep() 和wait()的区别</h3><ul><li><p>sleep是Thread的成员方法，睡眠时保持对象锁，仍然占有该锁。</p><ul><li>sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。 </li></ul></li><li><p>wait是Object的成员方法睡眠时，释放对象锁。</p><ul><li>wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问；wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。</li></ul></li><li><p>两者最主要的区别在于：<strong>sleep</strong> ⽅法没有释放锁，⽽ <strong>wait</strong> ⽅法释放了锁 。</p></li><li><p>wait 通常被⽤于线程间交互/通信，sleep 通常被⽤于暂停执⾏。</p></li><li><p>wait() ⽅法被调⽤后，线程不会⾃动苏醒，需要别的线程调⽤同⼀个对象上的 notify() 或者notifyAll() ⽅法。sleep() ⽅法执⾏完成后，线程会⾃动苏醒。或者可以使⽤ wait(longtimeout)超时后线程会⾃动苏醒。</p></li><li><p>wait只能在synchronize代码块中，<strong>sleep</strong>不需要。</p></li></ul><h3 id="为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤run-⽅法？"><a href="#为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤run-⽅法？" class="headerlink" title="为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？"></a>为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤run() ⽅法？</h3><ul><li>new ⼀个 Thread，线程进⼊了新建状态;调⽤ start() ⽅法，会启动⼀个线程并使线程进⼊了就绪状态，当分配到时间⽚后就可以开始运⾏了。 start() 会执⾏线程的相应准备⼯作，然后⾃动执⾏run() ⽅法的内容，这是真正的多线程⼯作。 ⽽直接执⾏ run() ⽅法，会把 run ⽅法当成⼀个 main线程下的普通⽅法去执⾏，并不会在某个线程中执⾏它，所以这并不是多线程⼯作。</li><li>总结： 调⽤ <strong>start</strong> ⽅法⽅可启动线程并使线程进⼊就绪状态，⽽ <strong>run</strong> ⽅法只是 <strong>thread</strong> 的⼀个普通⽅法调⽤，还是在主线程⾥执⾏。</li></ul><h3 id="notify与notifyAll的区别"><a href="#notify与notifyAll的区别" class="headerlink" title="notify与notifyAll的区别"></a>notify与notifyAll的区别</h3><blockquote><p>尽量使用notifyAll。</p></blockquote><ul><li>调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。</li><li>notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。当然，只有获得锁的那一个线程才能进入可执行状态。</li><li>两者最⼤的区别：<ul><li><strong>notifyAll</strong>使所有原来在该对象上等待被notify的线程统统退出wait的状态，变成等待该对象上的锁，⼀旦该对象被解锁，他们就会去竞争。</li><li>notify他只是选择⼀个wait状态线程进⾏通知，并使它获得该对象上的锁，但不惊动其他同样在等待被该对象notify的线程们，当第⼀个线程运⾏完毕以后释放对象上的锁，此时如果该对象没有再次使⽤notify语句，即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，继续处在wait状态，直到这个对象发出⼀个notify或notifyAll，它们等待的是被notify或notifyAll，⽽不是锁。</li></ul></li></ul><h3 id="有三个线程T1-T2-T3-如何保证顺序执行？"><a href="#有三个线程T1-T2-T3-如何保证顺序执行？" class="headerlink" title="有三个线程T1,T2,T3,如何保证顺序执行？"></a>有三个线程T1,T2,T3,如何保证顺序执行？</h3><blockquote><p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个</p><p>线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用</p><p>T2，T2调用T1)，这样T1就会先完成而T3最后完成。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest2</span> </span>&#123; </span><br><span class="line"><span class="comment">// 1.现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"t1"</span>);</span><br><span class="line">      &#125; &#125;); </span><br><span class="line">    <span class="keyword">final</span> Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span> </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 引用t1线程，等待t1线程执行完 </span></span><br><span class="line">          t1.join(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace(); </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"t2"</span>); </span><br><span class="line">      &#125;</span><br><span class="line">      &#125;); </span><br><span class="line">    Thread t3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span> </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 引用t2线程，等待t2线程执行完 </span></span><br><span class="line">          t2.join(); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace(); </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"t3"</span>); </span><br><span class="line">      &#125;</span><br><span class="line">      &#125;); </span><br><span class="line">    t3.start();</span><br><span class="line">    <span class="comment">//这里三个线程的启动顺序可以任意，大家可以试下！ </span></span><br><span class="line">    t2.start(); </span><br><span class="line">    t1.start(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说说-synchronized-关键字和-volatile-关键字的区别"><a href="#说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="说说 synchronized 关键字和 volatile 关键字的区别"></a>说说 synchronized 关键字和 volatile 关键字的区别</h3><ul><li><p><strong>volatile</strong>关键字是线程同步的轻量级实现，所以<strong>volatile</strong>性能肯定⽐<strong>synchronized</strong>关键字要好。但是<strong>volatile</strong>关键字只能⽤于变量⽽<strong>synchronized</strong>关键字可以修饰⽅法以及代码块。synchronized关键字在JavaSE1.6之后进⾏了主要包括为了减少获得锁和释放锁带来的性能消耗⽽引⼊的偏向锁和轻量级锁以及其它各种优化之后执⾏效率有了显著提升，实际开发中使⽤<strong>synchronized</strong> 关键字的场景还是更多⼀些。</p></li><li><p>多线程访问<strong>volatile</strong>关键字不会发⽣阻塞，⽽<strong>synchronized</strong>关键字可能会发⽣阻塞。</p></li><li><p><strong>volatile</strong>关键字能保证数据的可⻅性，但不能保证数据的原⼦性。<strong>synchronized</strong>关键字两者都能保证。</p></li><li><p><strong>volatile</strong>关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ <strong>synchronized</strong>关键字解决的是多个线程之间访问资源的同步性。</p></li></ul><h3 id="在多线程中，什么是上下文切换-context-switching-？"><a href="#在多线程中，什么是上下文切换-context-switching-？" class="headerlink" title="在多线程中，什么是上下文切换(context-switching)？"></a><strong>在多线程中，什么是上下文切换(context-switching)？</strong></h3><ul><li>上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</li><li>多线程编程中⼀般线程的个数都⼤于 CPU 核⼼的个数，⽽⼀个 CPU 核⼼在任意时刻只能被⼀个线程使⽤，为了让这些线程都能得到有效执⾏，CPU 采取的策略是为每个线程分配时间⽚并轮转的形式。当⼀个线程的时间⽚⽤完的时候就会重新处于就绪状态让给其他线程使⽤，这个过程就属于⼀次上下⽂切换。</li><li>概括来说就是：当前任务在执⾏完 CPU 时间⽚切换到另⼀个任务之前会先保存⾃⼰的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是⼀次上下⽂切换。上下⽂切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒⼏⼗上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下⽂切换对系统来说意味着消耗⼤量的 CPU 时间，事实上，可能是操作系统中时间消耗最⼤的操作。</li><li>Linux 相⽐与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有⼀项就是，其上下⽂切换和模式切换的时间消耗⾮常少。</li></ul><h3 id="为什么线程通信的方法wait-notify-和notifyAll-被定义在Object类里？"><a href="#为什么线程通信的方法wait-notify-和notifyAll-被定义在Object类里？" class="headerlink" title="为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？"></a><strong>为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里</strong>？</h3><ul><li>Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法。</li></ul><h3 id="为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么wait-notify-和notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？"></a><strong>为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？</strong></h3><ul><li>当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</li></ul><h3 id="为什么Thread类的sleep-和yield-方法是静态的？"><a href="#为什么Thread类的sleep-和yield-方法是静态的？" class="headerlink" title="为什么Thread类的sleep()和yield()方法是静态的？"></a><strong>为什么Thread类的sleep()和yield()方法是静态的？</strong></h3><ul><li>Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</li></ul><h3 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal?"></a><strong>什么是ThreadLocal?</strong></h3><blockquote><p>主要解决每个线程绑定自己的值，存储每个线程的私有变量。</p></blockquote><ul><li>ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。</li><li>每个线程都会拥有他们自己的Thread变量，它们可以使用get()set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。在ThreadLocal例子这篇文章中你可以看到一个关于ThreadLocal的小程序。</li></ul><h3 id="什么是Java线程转储-Thread-Dump-，如何得到它？"><a href="#什么是Java线程转储-Thread-Dump-，如何得到它？" class="headerlink" title="什么是Java线程转储(Thread Dump)，如何得到它？"></a><strong>什么是Java线程转储(Thread Dump)，如何得到它？</strong></h3><ul><li>线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。有很多方法可以获取线程转储——使用Profiler，Kill -3命令，jstack工具等等。我更喜欢jstack工具，因为它容易使用并且是JDK自带的。由于它是一个基于终端的工具，所以我们可以编写一些脚本去定时的产生线程转储以待分析。</li></ul><h3 id="什么是死锁-Deadlock-？如何分析和避免死锁？"><a href="#什么是死锁-Deadlock-？如何分析和避免死锁？" class="headerlink" title="什么是死锁(Deadlock)？如何分析和避免死锁？"></a><strong>什么是死锁(Deadlock)？如何分析和避免死锁？</strong></h3><ul><li><p>死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。</p></li><li><p>分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。</p></li><li><p>避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。</p></li><li><p>如何避免线程死锁?</p><ul><li><p>破坏互斥条件 ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p></li><li><p>破坏请求与保持条件 ：⼀次性申请所有的资源。</p></li><li><p>破坏不剥夺条件 ：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p></li><li><p>破坏循环等待条件 ：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p></li></ul></li></ul><h3 id="谈谈-synchronized和ReentrantLock-的区别"><a href="#谈谈-synchronized和ReentrantLock-的区别" class="headerlink" title="谈谈 synchronized和ReentrantLock 的区别"></a>谈谈 synchronized和ReentrantLock 的区别</h3><ul><li><p>两者都是可重⼊锁</p><ul><li>两者都是可重⼊锁。“可重⼊锁”概念是：⾃⼰可以再次获取⾃⼰的内部锁。⽐如⼀个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重⼊的话，就会造成死锁。同⼀个线程每次获取锁，锁的计数器都⾃增1，所以要等到锁的计数器下降为0时才能释放锁。</li></ul></li><li><p><strong>synchronized</strong> 依赖于 <strong>JVM</strong> ⽽ <strong>ReentrantLock</strong> 依赖于 <strong>API</strong></p><ul><li>synchronized 是依赖于 JVM 实现的，前⾯我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进⾏了很多优化，但是这些优化都是在虚拟机层⾯实现的，并没有直接暴露给我们。ReentrantLock 是 JDK 层⾯实现的（也就是 API 层⾯，需要 lock() 和 unlock() ⽅法配合try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</li></ul></li><li><p>相⽐synchronized，ReentrantLock增加了⼀些⾼级功能</p><blockquote><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p></blockquote><ul><li><p>等待可中断</p><ul><li><strong>ReentrantLock</strong>提供了⼀种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li></ul></li><li><p>实现公平锁</p><ul><li><strong>ReentrantLock</strong>可以指定是公平锁还是⾮公平锁。⽽<strong>synchronized</strong>只能是⾮公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是⾮公平的，可以通过 ReentrantLock类的 ReentrantLock(boolean fair) 构造⽅法来制定是否是公平的。</li></ul></li><li><p>可实现选择性通知</p><ul><li>ReentrantLock类实现等待/通知机制，需要借助于Condition接⼝与newCondition() ⽅法。Condition是JDK1.5之后才有的，它具有很好的灵活性，⽐如可以实现多路通知功能也就是在⼀个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的<strong>Condition</strong>中，从⽽可以有选择性的进⾏线程通知，在调度线程上更加灵活。 在使⽤<strong>notify()/notifyAll()**⽅法进⾏通知时，被通知的线程是由 **JVM</strong> 选择的，⽤<strong>ReentrantLock</strong>类结合<strong>Condition</strong>实例可以实现<strong>“</strong>选择性通知<strong>”</strong> ，这个功能⾮常重要，⽽且是Condition接⼝默认提供的。⽽synchronized关键字就相当于整个Lock对象中只有⼀个Condition实例，所有的线程都注册在它⼀个身上。如果执⾏notifyAll()⽅法的话就会通知所有处于等待状态的线程这样会造成很⼤的效率问题，⽽Condition实例的signalAll()⽅法 只会唤醒注册在该Condition实例中的所有等待线程。</li></ul></li></ul></li></ul><h3 id="你将如何使用thread-dump？你将如何分析Thread-dump？"><a href="#你将如何使用thread-dump？你将如何分析Thread-dump？" class="headerlink" title="你将如何使用thread dump？你将如何分析Thread dump？"></a>你将如何使用thread dump？你将如何分析Thread dump？</h3><ul><li>线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。有很多方法可以获取线程转储——使用Profiler，Kill -3命令，jstack工具等等。我更喜欢jstack工具，因为它容易使用并且是JDK自带的。由于它是一个基于终端的工具，所以我们可以编写一些脚本去定时的产生线程转储以待分析。</li></ul><h3 id="Java中interrupted-和-isInterruptedd⽅法的区别"><a href="#Java中interrupted-和-isInterruptedd⽅法的区别" class="headerlink" title="Java中interrupted 和 isInterruptedd⽅法的区别?"></a><strong>Java</strong>中<strong>interrupted</strong> 和 <strong>isInterruptedd</strong>⽅法的区别?</h3><ul><li><p>interrupted() :会将中断状态清除，Java多线程的中断机制是⽤内部标识来实现的，调⽤Thread.interrupt()来中断⼀个线程就会设置中断标识为true。当中断线程调⽤静态⽅法Thread.interrupted()来检查中断状态时，中断状态会被清零。</p></li><li><p>isInterruptedd : 不会将中断状态清除，⾮静态⽅法isInterrupted()⽤来查询其它线程的中断状态且不会改变中断状态标识。</p></li><li><p>任何抛出InterruptedException异常的⽅法都会将中断状态清零。⽆论如何，⼀个线程的中断状态有有可能被其它线程调⽤中断来改变。</p></li></ul><h3 id="Java中堆和栈有什么不同"><a href="#Java中堆和栈有什么不同" class="headerlink" title="Java中堆和栈有什么不同?"></a><strong>Java</strong>中堆和栈有什么不同?</h3><ul><li>栈是⼀块和线程紧密相关的内存区域,每个线程都有⾃⼰的栈内存，⽤于存储本地变量，⽅法参数和栈调⽤，⼀个线程中存储的变量对其它线程是不可⻅的。</li><li>堆是所有线程共享的⼀⽚公⽤内存区域,对象都在堆⾥创建，为了提升效率线程会从堆中弄⼀个缓存到⾃⼰的栈，如果多个线程使⽤该变量就可能引发问题，这时volatile 变量就可以发挥作⽤了，它要求线程从主存中读取变量的值。</li></ul><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><ul><li>公平锁的含义是线程需要按照请求的顺序来获得锁；而非公平锁则允许“插队”的情况存在，所谓的“插队”指的是，线程在发送请求的同时该锁的状态恰好变成了可用，那么此线程就可以跳过队列中所有排队的线程直接拥有该锁。</li><li>而公平锁由于有挂起和恢复所以存在一定的开销，因此性能不如非公平锁，所以 ReentrantLock 和 synchronized 默认都是非公平锁的实现方式。</li></ul><h3 id="共享锁和独占锁"><a href="#共享锁和独占锁" class="headerlink" title="共享锁和独占锁"></a>共享锁和独占锁</h3><ul><li>只能被单线程持有的锁叫独占锁，可以被多线程持有的锁叫共享锁。</li><li>独占锁指的是在任何时候最多只能有一个线程持有该锁，比如 synchronized 就是独占锁，而 ReadWriteLock 读写锁允许同一时间内有多个线程进行读操作，它就属于共享锁。</li><li>独占锁可以理解为悲观锁，当每次访问资源时都要加上互斥锁，而共享锁可以理解为乐观锁，它放宽了加锁的条件，允许多线程同时访问该资源。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本章属于持续学习、长期更修。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://z201.cn/2019/02/27/%E5%88%9D%E6%8E%A2Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;初探Java多线程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;线程的状态有哪些？又如何工作的？&quot;&gt;&lt;a href=&quot;#线程的状态有哪些？又如何工作的？&quot; class=&quot;headerlink&quot; title=&quot;线程的状态有哪些？又如何工作的？&quot;&gt;&lt;/a&gt;线程的状态有哪些？又如何工作的？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;线程的状态在枚举的方式被定义在 Thread 的源码中，它总共包含以下 6 个状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NEW，新建状态，线程被创建出来，但尚未启动时的线程状态；&lt;/li&gt;
&lt;li&gt;RUNNABLE，就绪状态，表示可以运行的线程状态，它可能正在运行，或者是在排队等待操作系统给它分配 CPU 资源；&lt;/li&gt;
&lt;li&gt;BLOCKED，阻塞等待锁的线程状态，表示处于阻塞状态的线程正在等待监视器锁，比如等待执行 synchronized 代码块或者使用 synchronized 标记的方法；&lt;/li&gt;
&lt;li&gt;WAITING，等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作，比如，一个线程调用了 Object.wait() 方法，那它就在等待另一个线程调用 Object.notify() 或 Object.notifyAll() 方法；&lt;/li&gt;
&lt;li&gt;TIMED_WAITING，计时等待状态，和等待状态（WAITING）类似，它只是多了超时时间，比如调用了有超时时间设置的方法 Object.wait(long timeout) 和 Thread.join(long timeout) 等这些方法时，它才会进入此状态；&lt;/li&gt;
&lt;li&gt;TERMINATED，终止状态，表示线程已经执行完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; State &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 新建状态，线程被创建出来，但尚未启动时的线程状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NEW,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 就绪状态，表示可以运行的线程状态，但它在排队等待来自操作系统的 CPU 资源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    RUNNABLE,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 阻塞等待锁的线程状态，表示正在处于阻塞状态的线程&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 正在等待监视器锁，比如等待执行 synchronized 代码块或者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 使用 synchronized 标记的方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    BLOCKED,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 等待状态，一个处于等待状态的线程正在等待另一个线程执行某个特定的动作。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 例如，一个线程调用了 Object.wait() 它在等待另一个线程调用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * Object.notify() 或 Object.notifyAll()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WAITING,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 计时等待状态，和等待状态 (WAITING) 类似，只是多了超时时间，比如&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 调用了有超时时间设置的方法 Object.wait(long timeout) 和 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * Thread.join(long timeout) 就会进入此状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TIMED_WAITING,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * 终止状态，表示线程已经执行完成&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;BLOCKED（阻塞等待）和-WAITING（等待）有什么区别？&quot;&gt;&lt;a href=&quot;#BLOCKED（阻塞等待）和-WAITING（等待）有什么区别？&quot; class=&quot;headerlink&quot; title=&quot;BLOCKED（阻塞等待）和 WAITING（等待）有什么区别？&quot;&gt;&lt;/a&gt;BLOCKED（阻塞等待）和 WAITING（等待）有什么区别？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;虽然 BLOCKED 和 WAITING 都有等待的含义，但二者有着本质的区别，首先它们状态形成的调用方法不同，其次 BLOCKED 可以理解为当前线程还处于活跃状态，只是在阻塞等待其他线程使用完某个锁资源；而 WAITING 则是因为自身调用了 Object.wait() 或着是 Thread.join() 又或者是 LockSupport.park() 而进入等待状态，只能等待其他线程执行某个特定的动作才能被继续唤醒，比如当线程因为调用了 Object.wait() 而进入 WAITING 状态之后，则需要等待另一个线程执行 Object.notify() 或 Object.notifyAll() 才能被唤醒。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://z201.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="Java多线程" scheme="https://z201.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>面试题-Java-Collecions-Framework</title>
    <link href="https://z201.github.io/2020/06/29/%E9%9D%A2%E8%AF%95%E9%A2%98-Java-Collecions-Framework/"/>
    <id>https://z201.github.io/2020/06/29/%E9%9D%A2%E8%AF%95%E9%A2%98-Java-Collecions-Framework/</id>
    <published>2020-06-29T15:32:00.000Z</published>
    <updated>2020-08-02T20:00:40.117Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章属于持续学习、长期更修。</p></blockquote><ul><li><a href="%5Bhttps://z201.cn/2018/08/23/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAHashMap/%5D(https://z201.cn/2018/08/23/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAHashMap/)">深入浅出HashMap</a></li></ul><h3 id="对比下Vector、ArrayList、LinkedList之前有何区别。"><a href="#对比下Vector、ArrayList、LinkedList之前有何区别。" class="headerlink" title="对比下Vector、ArrayList、LinkedList之前有何区别。"></a>对比下Vector、ArrayList、LinkedList之前有何区别。</h3><p><strong>Vector</strong></p><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/JavaConcurrent/Vector.png"></p><ul><li>Vector是Java早期提供的线程安全动态数组，和ArrayList之间在扩容方面有很多的区别，Vector是扩容2倍，而ArrayList扩容1.5倍。</li></ul><p><strong>ArrayList</strong></p><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/JavaConcurrent/ArrayList.png"></p><ul><li>ArrayList平时开发过程中使用最多的，是一个线程不安全的动态数组。所以性能上相对Vector好很多。</li></ul><p><strong>LinkedList</strong></p><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/JavaConcurrent/LinkedList.png"></p><ul><li>它是一个链表，对比ArrayList和Vector不需要扩容。但没有实现<code>RandomAccess </code>接口。RandomAccess的实现，则尽量用for(int i = 0; i &lt; size; i++) 来遍历而不要用Iterator迭代器来遍历。</li></ul><h3 id="ArrayList和linkedList的区别"><a href="#ArrayList和linkedList的区别" class="headerlink" title="ArrayList和linkedList的区别"></a>ArrayList和linkedList的区别</h3><ul><li><p><strong>Array</strong> （数组）是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。</p></li><li><p>Array获取数据的时间复杂度是O(1),但是要删除数据却是开销很大，因为这需要重排数组中的所有数据, (因为删除数据以后, 需要把后面所有的数据前移)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组初始化必须指定初始化的长度, 否则报错</span></span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];<span class="comment">//推介使用int[] 这种方式初始化 </span></span><br><span class="line"><span class="keyword">int</span> c[] = &#123;<span class="number">23</span>,<span class="number">43</span>,<span class="number">56</span>,<span class="number">78</span>&#125;;<span class="comment">//长度：4，索引范围：[0,3]</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>List—**</strong>是一个有序的集合，可以包含重复的元素，提供了按索引访问的方式，它继承Collection。List有两个重要的实现类：</p></li><li><p><strong>ArrayList:</strong> <strong>可以看作是能够自动增长容量的数组</strong>。</p></li><li><p>ArrayList的toArray方法返回一个数组。</p></li><li><p><strong>ArrayList**</strong>的asList方法返回一个列表。</p></li></ul><h3 id="HashMap加载因子为什么是-0-75？"><a href="#HashMap加载因子为什么是-0-75？" class="headerlink" title="HashMap加载因子为什么是 0.75？"></a>HashMap加载因子为什么是 0.75？</h3><ul><li><p>加载因子也叫扩容因子或负载因子，用来判断什么时候进行扩容的，假如加载因子是 0.5，HashMap 的初始化容量是 16，那么当 HashMap 中有 16*0.5=8 个元素时，HashMap 就会进行扩容。</p></li><li><p>那加载因子为什么是 0.75 而不是 0.5 或者 1.0 呢？</p><ul><li><p>这其实是出于容量和性能之间平衡的结果：</p></li><li><p>当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生 Hash 冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；</p></li><li><p>而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，因此操作性能会比较高。</p></li></ul></li><li><p>所以综合了以上情况就取了一个 0.5 到 1.0 的平均数 0.75 作为加载因子。</p></li></ul><h3 id="当有哈希冲突时，HashMap-是如何查找并确认元素的？"><a href="#当有哈希冲突时，HashMap-是如何查找并确认元素的？" class="headerlink" title="当有哈希冲突时，HashMap 是如何查找并确认元素的？"></a>当有哈希冲突时，HashMap 是如何查找并确认元素的？</h3><ul><li>当哈希冲突时我们需要通过判断 key 值是否相等，才确认此元素是不是我们想要的元素。</li></ul><h3 id="HashMap-源码中有哪些重要的方法？"><a href="#HashMap-源码中有哪些重要的方法？" class="headerlink" title="HashMap 源码中有哪些重要的方法？"></a>HashMap 源码中有哪些重要的方法？</h3><ul><li>putVal()新增</li><li>resize()扩容</li><li>get()查询</li></ul><h3 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别?"></a>HashMap和HashTable的区别?</h3><ul><li><p>两者父类不同</p><ul><li>HashMap是继承自AbstractMap类，而Hashtable是继承自Dictionary类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。</li></ul></li><li><p>对外提供的接口不同</p><ul><li>Hashtable比HashMap多提供了elments() 和contains() 两个方法。elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。</li></ul></li><li><p>null支持不同</p><ul><li><p>Hashtable：key和value都不能为null。</p></li><li><p>HashMap：key可以为null，但是这样的key只能有一个，因为必须保证key的唯一性；可以有多个key</p><p>值对应的value为null。 </p></li></ul></li><li><p>线程安全不同</p><ul><li><p>HashMap是线程不安全的，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。</p></li><li><p>Hashtable是线程安全的，它的每个方法上都有synchronized 关键字，因此可直接用于多线程中。</p></li><li><p>虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本章属于持续学习、长期更修。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;%5Bhttps://z201.cn/2018/08/23/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAHashMap
      
    
    </summary>
    
    
      <category term="面试" scheme="https://z201.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="Java-Collecions-Framework" scheme="https://z201.github.io/tags/Java-Collecions-Framework/"/>
    
      <category term="HashMap" scheme="https://z201.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>redis-cli使用</title>
    <link href="https://z201.github.io/2019/12/15/redis-cli%E4%BD%BF%E7%94%A8/"/>
    <id>https://z201.github.io/2019/12/15/redis-cli%E4%BD%BF%E7%94%A8/</id>
    <published>2019-12-15T08:56:48.000Z</published>
    <updated>2020-07-18T15:27:19.713Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在mac中使用redis-cli。相比rdm我可能更喜欢这个命令行工具。</p></blockquote><h3 id="在mac中之安装redis-cli"><a href="#在mac中之安装redis-cli" class="headerlink" title="在mac中之安装redis-cli"></a>在mac中之安装redis-cli</h3><blockquote><p>按照标准的按照流程，需要先安装redis-server。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew tap ringohub/redis-cli</span><br><span class="line"></span><br><span class="line">brew update &amp;&amp; brew doctor</span><br><span class="line"></span><br><span class="line">brew install redis-cli</span><br></pre></td></tr></table></figure><ul><li>相关文档<a href="https://stackoverflow.com/questions/39704273/macos-x-is-there-a-way-to-install-only-redis-cli" target="_blank" rel="noopener">https://stackoverflow.com/questions/39704273/macos-x-is-there-a-way-to-install-only-redis-cli</a></li></ul><h3 id="根据redis常用命令来学习使用redis-cli。"><a href="#根据redis常用命令来学习使用redis-cli。" class="headerlink" title="根据redis常用命令来学习使用redis-cli。"></a>根据redis常用命令来学习使用redis-cli。</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在mac中使用redis-cli。相比rdm我可能更喜欢这个命令行工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;在mac中之安装redis-cli&quot;&gt;&lt;a href=&quot;#在mac中之安装redis-cli&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="redis" scheme="https://z201.github.io/categories/redis/"/>
    
    
      <category term="Redis" scheme="https://z201.github.io/tags/Redis/"/>
    
      <category term="Redis-cli" scheme="https://z201.github.io/tags/Redis-cli/"/>
    
  </entry>
  
  <entry>
    <title>brew个人工具清单</title>
    <link href="https://z201.github.io/2019/12/15/brew%E4%B8%AA%E4%BA%BA%E5%B7%A5%E5%85%B7%E6%B8%85%E5%8D%95/"/>
    <id>https://z201.github.io/2019/12/15/brew%E4%B8%AA%E4%BA%BA%E5%B7%A5%E5%85%B7%E6%B8%85%E5%8D%95/</id>
    <published>2019-12-15T07:00:02.000Z</published>
    <updated>2019-12-15T17:03:40.033Z</updated>
    
    <content type="html"><![CDATA[<p>#Mac下个人工具清单。</p><h2 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h2><table><thead><tr><th>Tool name</th><th>Install command</th><th>Description</th></tr></thead><tbody><tr><td>Wget</td><td>brew install  wget</td><td>下载工具</td></tr><tr><td>Curl</td><td>brew install curl</td><td>下载工具</td></tr><tr><td>Diff</td><td>brew install difftuils</td><td>Gnu 比较工具</td></tr><tr><td>Find</td><td>brew install findtuils</td><td>Gnu 查找工具</td></tr><tr><td>htop</td><td>brew install stop</td><td>代替top</td></tr><tr><td>Axel</td><td>brew install axel</td><td>多线程下载</td></tr><tr><td>Tmux</td><td>brew install tmux</td><td>终端复用</td></tr><tr><td>cloc</td><td>brew install cloc</td><td>代码统计</td></tr><tr><td>Tldr</td><td>brew install tldr</td><td>命令提示行</td></tr><tr><td>Ncdu</td><td>brew install ncdu</td><td>磁盘空间占用成分</td></tr><tr><td>ctop</td><td>brew install stop</td><td>Docker 容器监控工具</td></tr><tr><td>Pstree</td><td>brew install</td><td>进程树查看</td></tr><tr><td>Bash-completion</td><td>brew install</td><td>bash补全</td></tr><tr><td>Graphviz</td><td>brew install</td><td>拓扑图绘制工具</td></tr></tbody></table><h2 id="brew-cask"><a href="#brew-cask" class="headerlink" title="brew cask"></a>brew cask</h2><table><thead><tr><th>Tool name</th><th>Install command</th><th>Description</th></tr></thead><tbody><tr><td>cask</td><td>brew tap cask room/cask</td><td>Cask</td></tr><tr><td>Macpass</td><td>brew cask install macpass</td><td>免费密码管理</td></tr><tr><td>docker</td><td>brew cask install docker</td><td>docker 必备</td></tr><tr><td>Fonts</td><td>brew tap cask room/fonts</td><td>字体管理</td></tr><tr><td>licecap</td><td>brew cask install licecap</td><td>录屏软件</td></tr><tr><td>Kap</td><td>brew cask install kap</td><td>视频录屏</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#Mac下个人工具清单。&lt;/p&gt;
&lt;h2 id=&quot;brew&quot;&gt;&lt;a href=&quot;#brew&quot; class=&quot;headerlink&quot; title=&quot;brew&quot;&gt;&lt;/a&gt;brew&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tool name&lt;/th&gt;
&lt;th&gt;I
      
    
    </summary>
    
    
      <category term="工具" scheme="https://z201.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="mac" scheme="https://z201.github.io/tags/mac/"/>
    
      <category term="brew" scheme="https://z201.github.io/tags/brew/"/>
    
      <category term="tools" scheme="https://z201.github.io/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>学习中自我认知</title>
    <link href="https://z201.github.io/2019/11/17/%E5%AD%A6%E4%B9%A0%E4%B8%AD%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5/"/>
    <id>https://z201.github.io/2019/11/17/%E5%AD%A6%E4%B9%A0%E4%B8%AD%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5/</id>
    <published>2019-11-17T08:38:13.000Z</published>
    <updated>2020-07-27T12:55:15.703Z</updated>
    
    <content type="html"><![CDATA[<h3 id="了解真实的自己"><a href="#了解真实的自己" class="headerlink" title="了解真实的自己"></a>了解真实的自己</h3><blockquote><p>自己从小到大都不是一个学习好的孩子，但是从来不觉得自己的智商差。但是自己的学习方式或者说学习思维确实一点都没养成。</p></blockquote><ul><li><p>逐步改变自己之前，需要对自己的情况进行一个了解。近几天都在看关于学习相关的资料和视频。今天突然发现一个特别有趣的话<code>间歇性踌躇满志，持续性混吃等死</code>，感觉这就是我十多年来对学习这会事态度的完美诠释。更可怕的是这大概是我早期应对焦虑的手段之一。</p></li><li><p>根据自己当前的实际情况，分析整理专业知识。整理自己的时间，对于时间这个事情。这是世上对所有人都公平的事情，所以如何根据自己的情况合理分配时间至关重要。</p></li><li><p>整理需要掌握的知识方向，归纳需要掌握的知识点。优先改善自己的学习思维，刻意有目标的去学习。</p></li><li><p>冲动性学习很难长久，所以需要对自己更为了解才行。</p></li></ul><h3 id="通过各种途径去了解自己"><a href="#通过各种途径去了解自己" class="headerlink" title="通过各种途径去了解自己"></a>通过各种途径去了解自己</h3><blockquote><p>了解自己是一个漫长的过程，自律是漫长的。每个人的坚持的方法都不一样，自律就是对自己不满意。对现实不满意，才会让自己努力去改变自己。</p></blockquote><ul><li><a href="https://www.apesk.com/mbti/dati.asp" target="_blank" rel="noopener">mbti测试</a> 这是非常权威的心理测试。</li><li>每个人坚持的方法都不一样，比如背单词的app每天打卡，或者番茄工作法。寻找自己的坚持点非常重要，如果不能找到自己的坚持点，大多情况下都会所谓的坚持都只会仓促结束。</li></ul><h3 id="让自己更加优秀"><a href="#让自己更加优秀" class="headerlink" title="让自己更加优秀"></a>让自己更加优秀</h3><ol><li><strong>理解和接受自己会犯错误。</strong>关键是要尽早发现，在错误进入到最终产品前发现它们。幸运的是，除了我们少数几个在喷气推进实验所开发火箭导航系统的人外，在软件行业中犯错误通常不会导致灾难性事故。我们可以，也应该从错误中吸取教训，微笑，并继续前进。</li><li><strong>你不是你的代码。</strong>记住代码审查的全部目的就是去发现问题，相信问题会被我们发现。当有问题疏漏时不要自责。</li><li><strong>不管你对“空手道”有多了解，一定会有人知道的更多。</strong>如果你去问，这样的人可以告诉你一些新的招数。从别人那里寻找和接受新的知识，特别是那些你认为不需要的知识。</li><li><strong>不要在没有讨论的情况下重写代码。</strong>在“调整代码”和“重写代码”之间有一条很细致的界限，你应该在代码审查的制度下做风格上的调整，不要独断专行。</li><li><strong>对那些不如你的人要尊敬，礼遇，有耐心。</strong>经常跟开发人员打交道的非技术人士通常持有这样的观点：程序员凭借一技之长狂放不羁。不要让你的发怒和缺乏耐性让他们心中的这种形象加深。</li><li><strong>这世界上唯一不变的就是变化。</strong>开放思考，面带微笑的接受它。把需求上、平台或工具里的每个改变都视作一种新的挑战，而不是把它们当作大麻烦来抵制。</li><li><strong>真正的权威来自知识，而不是职位。</strong>知识造就权威，权威带来尊敬——所以，如果你想在一个无私的环境中获得尊敬，去培养自己的知识吧。</li><li><strong>为信仰奋斗，但我文雅的接受失败。</strong>要理解，有时候你的想法会被拒绝。即使你是对的，你也不要报复或说“I told you so.”千万不要让你心爱的被抛弃的想法变成殉道者或抱怨素材。</li><li><strong>不要成为“角落里的程序员。”</strong>不要成为隐藏在黑暗办公室里、只因为口渴才出现的人。藏在角落的里程序员短视、与世隔绝、不受控制。这样的人在公开的、合作的工作环境中发不出声音。参与到交流中，成为你的办公室团体中的一员。</li><li><strong>批评代码而不是人——对编码人友善，但不要对代码友善。</strong>尽可能的让你的批评具有积极性，以改进代码为目标。批评要联系本地标准，编程规格文档和提高后的性能等。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;了解真实的自己&quot;&gt;&lt;a href=&quot;#了解真实的自己&quot; class=&quot;headerlink&quot; title=&quot;了解真实的自己&quot;&gt;&lt;/a&gt;了解真实的自己&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;自己从小到大都不是一个学习好的孩子，但是从来不觉得自己的智商差。但是自己的
      
    
    </summary>
    
    
      <category term="改变自己" scheme="https://z201.github.io/categories/%E6%94%B9%E5%8F%98%E8%87%AA%E5%B7%B1/"/>
    
    
      <category term="自律" scheme="https://z201.github.io/tags/%E8%87%AA%E5%BE%8B/"/>
    
      <category term="计划" scheme="https://z201.github.io/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="学习" scheme="https://z201.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="人生" scheme="https://z201.github.io/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>学习自律</title>
    <link href="https://z201.github.io/2019/11/17/%E5%AD%A6%E4%B9%A0%E8%87%AA%E5%BE%8B/"/>
    <id>https://z201.github.io/2019/11/17/%E5%AD%A6%E4%B9%A0%E8%87%AA%E5%BE%8B/</id>
    <published>2019-11-17T01:12:31.000Z</published>
    <updated>2020-07-27T12:55:20.632Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面对焦虑"><a href="#面对焦虑" class="headerlink" title="面对焦虑"></a>面对焦虑</h3><blockquote><p>随着年龄不断提升,生活和未来带来的焦虑。让自己难以招架，这个年龄在来改变自己晚吗？其实不晚。</p></blockquote><ul><li><p>面对焦虑最好的办法就是改变自己，不断提升自己。让自己过的充实。</p></li><li><p>工业化的社会，拥有的自由时间应该是用来提升自己的。而不是一味的娱乐。</p></li><li><p>改变自己、提升自己。让自己的生活变得充实健康。不努力只会和那些正在努力的人差距只会只会越来越大。最终可能完全丧失竞争力。</p></li></ul><h3 id="尝试计划"><a href="#尝试计划" class="headerlink" title="尝试计划"></a>尝试计划</h3><blockquote><p>尝试和自己斗智斗勇，如果想要改变自己首先要能约束自己。让自己的行为按照自己预期的方向前进。</p></blockquote><ul><li><p>尝试对每天的事情，进行一个安排。</p></li><li><p>尝试对每天安排的事情，逐个完成。</p></li><li><p>根据自己当前的情况调整安排的计划，让计划和生活更加协调。</p></li><li><p>细化计划内容，让大脑习惯这种方式。</p></li></ul><h3 id="高效习惯"><a href="#高效习惯" class="headerlink" title="高效习惯"></a>高效习惯</h3><blockquote><p>尝试更加高效的生活，而不是让自己的生活一味的随心所欲。去思考去实践，让生活更加高效有趣。</p></blockquote><ul><li>生活的琐事上，会消耗的大量的时间。高效简洁的处理，让自己的可以掌控时间增加。</li><li>科学、健康、合理的安排的自己的时间。计划永远赶不上变化，适当调整计划，保持住一个合理的时间安排。</li></ul><h3 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h3><blockquote><p>每个人的学习方式都不一样，不断的去寻找适合自己的方式、方法。</p></blockquote><ul><li>一流的企业做标准，二流的企业做品牌，三流的企业做产品。</li><li>优秀的学生练思维，良好的学生找方法，一般的学生学知识。</li></ul><h3 id="养成习惯"><a href="#养成习惯" class="headerlink" title="养成习惯"></a>养成习惯</h3><blockquote><p>养成好的习惯终生适用。</p></blockquote><ul><li>我们的大脑是有非常强的可塑性，通过刻意的练习锻炼大脑。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面对焦虑&quot;&gt;&lt;a href=&quot;#面对焦虑&quot; class=&quot;headerlink&quot; title=&quot;面对焦虑&quot;&gt;&lt;/a&gt;面对焦虑&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;随着年龄不断提升,生活和未来带来的焦虑。让自己难以招架，这个年龄在来改变自己晚吗？其实不晚。&lt;/p
      
    
    </summary>
    
    
      <category term="改变自己" scheme="https://z201.github.io/categories/%E6%94%B9%E5%8F%98%E8%87%AA%E5%B7%B1/"/>
    
    
      <category term="自律" scheme="https://z201.github.io/tags/%E8%87%AA%E5%BE%8B/"/>
    
      <category term="计划" scheme="https://z201.github.io/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="学习" scheme="https://z201.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="人生" scheme="https://z201.github.io/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>实践nginx日志简单的统计</title>
    <link href="https://z201.github.io/2019/06/04/%E5%AE%9E%E8%B7%B5nginx%E6%97%A5%E5%BF%97%E7%AE%80%E5%8D%95%E7%9A%84%E7%BB%9F%E8%AE%A1/"/>
    <id>https://z201.github.io/2019/06/04/%E5%AE%9E%E8%B7%B5nginx%E6%97%A5%E5%BF%97%E7%AE%80%E5%8D%95%E7%9A%84%E7%BB%9F%E8%AE%A1/</id>
    <published>2019-06-04T03:21:21.000Z</published>
    <updated>2019-06-04T15:30:17.712Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>公司没有日志采集平台，又不太可能在业务系统里面搞事情。好在之前有玩过elk日志分析组合。直接从服务器上面撸出日志简单的用linux命令分析下吧。</p></blockquote><p>Nginx日志统计（简单的）</p><p>（日志文件叫access.log 在当前目录下）</p><p><strong>统计 PV，就是日志行数</strong></p><p><code>cat access.log |wc -l</code></p><p><strong>UV, 即是统计 IP 数</strong></p><p><code>cat access.log |awk &#39;{print $1}&#39; |sort |uniq -c |wc -l</code></p><p><strong>使用linux grep 进行统计</strong></p><p><code>grep -E &quot;POST|GET&quot; access.log | awk -F &#39;&quot;&#39; &#39;{print $2,$3}&#39; | awk &#39;{print $2}&#39;| sort | uniq -c | sort -k1nr | head -100</code></p><p><strong>耗时的请求发生时间、所请求的 URI 和耗时</strong></p><p><code>cat access.log | awk &#39;{print $4,$7,$10,$NF}&#39; | sort -k3 -nr | head -100</code></p><p><strong>统计</strong>nginx<strong>访问频次最高的</strong>100<strong>个</strong>Ip**</p><p><code>grep -E &quot;POST|GET&quot; access.log | awk -F &#39;&quot;&#39; &#39;{print $(NF-1)}&#39; | sort | uniq -c | sort -k1nr | head -100</code></p><p><strong>统计</strong>nginx<strong>访问不正常（状态码</strong>400+<strong>）的前</strong>100<strong>个</strong>url<strong>和频次</strong></p><p><code>grep -E &quot;POST|GET&quot; access.log | awk -F &#39;&quot;&#39; &#39;{print $2,$3}&#39; | awk &#39;{if ($4&gt;=&quot;400&quot;) {print $4,$1,$2}}&#39; | sort | uniq -c | sort -k1nr | head -100</code></p><p><strong>统计nginx访问状态码非200的前100个</strong>url<strong>和频次**</strong></p><p><code>grep -E &quot;POST|GET&quot; access.log | awk -F &#39;&quot;&#39; &#39;{print $2,$3}&#39; | awk &#39;{if ($4!=200) {print $4,$1,$2}}&#39; | sort | uniq -c | sort -k1nr | head -100</code></p><p><strong>不同 URI 的平均耗时</strong></p><p><code>grep -E &quot;POST|GET&quot; access.log  | awk &#39;{s[$10] += $NF;c[$10]++}END{for(i in s){print i,s[i]/c[i]}}&#39; |sort -k2 -nr | head</code></p><p><strong>每秒请求量统计</strong></p><p>统计每秒的请求数,top100的时间点(精确到秒)</p><p><code>grep -E &quot;POST|GET&quot; access.log |  awk &#39;{print $4}&#39; access.log |cut -c 14-21|sort|uniq -c|sort -nr|head -n 100</code></p><p><strong>每分钟请求量统计</strong></p><p>统计每分钟的请求数,top100的时间点(精确到分钟)</p><p><code>grep -E &quot;POST|GET&quot; access.log |  awk &#39;{print $4}&#39; access.log |cut -c 14-18|sort|uniq -c|sort -nr|head -n 100</code></p><p><strong>每小时请求量统计</strong></p><p>统计每小时的请求数,top100的时间点(精确到小时)</p><p><code>grep -E &quot;POST|GET&quot; access.log |  awk &#39;{print $4}&#39; access.log |cut -c 14-15|sort|uniq -c|sort -nr|head -n 100</code></p><p><strong>统计蜘蛛抓取次数</strong></p><p><code>grep &#39;Baiduspider&#39; access.log |wc -l</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;公司没有日志采集平台，又不太可能在业务系统里面搞事情。好在之前有玩过elk日志分析组合。直接从服务器上面撸出日志简单的用linux命令分析下吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Nginx日志统计（简单的）&lt;/p&gt;
&lt;p&gt;（日志文件叫ac
      
    
    </summary>
    
    
      <category term="nginx" scheme="https://z201.github.io/categories/nginx/"/>
    
    
      <category term="nginx" scheme="https://z201.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>总结代码风格</title>
    <link href="https://z201.github.io/2019/05/27/%E6%80%BB%E7%BB%93%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    <id>https://z201.github.io/2019/05/27/%E6%80%BB%E7%BB%93%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</id>
    <published>2019-05-27T12:49:08.000Z</published>
    <updated>2020-02-02T12:25:03.743Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>好久没更新博客，最近公司让我出一个代码规范，我吓了一跳。赶忙翻出阿里《 码出高效》，不敢造次，我就补充点个人的想法吧。代码是给人看的。代码风格应该遵循<code>极简主义</code>                                                                                                      </p></blockquote><h3 id="1、避免复杂、追求简单"><a href="#1、避免复杂、追求简单" class="headerlink" title="1、避免复杂、追求简单"></a>1、避免复杂、追求简单</h3><blockquote><p>日常开发中，除了解决业务问题还需要解决许多的工程问题。如何选择当下合适的方法解决问题；需要不断尝试和摸索，没有最好的方法只有更好的方法。</p></blockquote><h3 id="2、合理平滑的处理技术债务"><a href="#2、合理平滑的处理技术债务" class="headerlink" title="2、合理平滑的处理技术债务"></a>2、合理平滑的处理技术债务</h3><blockquote><p>技术的演变速度太快，如何避免长时间的技术债务是非常严重的问题，总之弊大于利。尽可能保持轻装上阵，避免拖油瓶项目。</p><p>关键字：</p><ul><li>一方库: 本工程内部子项目模块依赖的库(jar 包)。 </li><li>二方库: 公司内部发布到中央仓库，可供公司内部其它应用依赖的库(jar包)。 </li><li>三方库: 公司之外的开源库(jar 包)。 </li></ul></blockquote><h4 id="『避免过度封装』"><a href="#『避免过度封装』" class="headerlink" title="『避免过度封装』"></a>『避免过度封装』</h4><blockquote><p>特别是没有完整的技术人员编制的情况下，怎么简单怎么处理（去除中间商赚差价一个道理。）避免过度开发<code>一方库</code>；建议使用原生方式(综合评估代码量)<code>避免框架过度封装</code>。（Java的方法调用链过长是出了名的恶心）</p></blockquote><h4 id="『避免代码过度重复』"><a href="#『避免代码过度重复』" class="headerlink" title="『避免代码过度重复』"></a>『避免代码过度重复』</h4><blockquote><p>每次开发业务都会写很多的代码。定期对公司项目进行基础代码的重构。合理的拆分<code>业务无关的基础代码</code>。</p></blockquote><h4 id="『避免版本混乱』"><a href="#『避免版本混乱』" class="headerlink" title="『避免版本混乱』"></a>『避免版本混乱』</h4><p>使用统一的版本管理。约束所有的项目jar版本依赖。防止因为过度使用<code>三方库</code>出现奇怪的bug。公司<code>bom</code>需要单独处理。尽量保持与社区版本同步，比如springboot最新版是2.1.3 ，那么公司使用的版本最好是近半年的GA版本。</p><h4 id="『物极必反』"><a href="#『物极必反』" class="headerlink" title="『物极必反』"></a>『物极必反』</h4><blockquote><p>请勿过度依赖某框架栈或者解决方式，客观的对比相关解决方案优缺点。</p></blockquote><h4 id="『选择大于努力』"><a href="#『选择大于努力』" class="headerlink" title="『选择大于努力』"></a>『选择大于努力』</h4><blockquote><p>集中精力掌握核心知识。按照目前技术演变的速度，更新最快的是应用技术，其次是行业规范相关技术。最后才是革命性的技术。</p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/%E6%8A%80%E6%9C%AF%E8%B1%A1%E9%99%90%E5%9B%BE.png"></p><a id="more"></a><h3 id="3、指定一种工程结构"><a href="#3、指定一种工程结构" class="headerlink" title="3、指定一种工程结构"></a>3、指定一种工程结构</h3><blockquote><p>统一的工程结构，对开发人员来说如同指路明灯，可以快速的区分相关代码位置。</p></blockquote><h4 id="『阿里巴巴Java开发手册-应用分层』"><a href="#『阿里巴巴Java开发手册-应用分层』" class="headerlink" title="『阿里巴巴Java开发手册-应用分层』"></a>『阿里巴巴Java开发手册-应用分层』</h4><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png"></p><ul><li>开放接口层:可直接封装 Service 方法暴露成 RPC 接口;通过 Web 封装成 http 接口;进行 网关安全控制、流量控制等。 </li><li>终端显示层:各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染， JSP 渲染，移动端展示等。 </li><li>Web 层:主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。 </li><li>Service 层:相对具体的业务逻辑服务层。 </li><li>Manager 层:通用业务处理层，它有如下特征:<ol><li>对第三方平台封装的层，预处理返回结果及转化异常信息;</li><li>对Service层通用能力的下沉，如缓存方案、中间件通用处理; </li><li>与DAO层交互，对多个DAO的组合复用。 </li></ol></li><li>DAO 层:数据访问层，与底层 MySQL、Oracle、Hbase 等进行数据交互。 </li><li>外部接口或第三方平台:包括其它部门RPC开放接口，基础平台，其它公司的HTTP接口。 </li></ul><h4 id="『建议分层方式』"><a href="#『建议分层方式』" class="headerlink" title="『建议分层方式』"></a>『建议分层方式』</h4><blockquote><p>根据工作实际情况，参考阿里的应用分层后适当采纳。</p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/%E5%BB%BA%E8%AE%AE%E5%BA%94%E7%94%A8%E5%88%86%E5%B1%82.png"></p><ul><li><p>开放接口层:可直接封装 Service 方法暴露成 RPC 接口;通过 Web 封装成 http 接口;进行 网关安全控制、流量控制等。 </p></li><li><p><del>终端显示层:各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染， JSP 渲染，移动端展示等</del>  </p></li><li><p><del>Web 层:主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等</del>  </p></li><li><p>Service 层:相对具体的业务逻辑服务层。 </p></li><li><p>Manager 层:通用业务处理层，它有如下特征:</p><ol><li><p>对第三方平台封装的层，预处理返回结果及转化异常信息。</p></li><li><p>对Service层通用能力的下沉，如缓存方案、中间件通用处理。</p></li><li><p>与DAO层交互，对多个DAO的组合复用。 </p></li></ol></li><li><p>DAO 层:数据访问层，与底层 MySQL、Oracle、Hbase 等进行数据交互。 </p></li><li><p>外部接口或第三方平台:包括其它部门RPC开放接口，基础平台，其它公司的HTTP接口。</p></li></ul><blockquote><p>目前Java已经不写前端代码，所以终端显示层和Web已经没有使用的价值。这里需要额外的注意，开放接口层不需要任何的业务操作，方便做完整的单元测试。将参数校验等操作放在具体业务执行的过程中。</p></blockquote><h4 id="『建议分层异常处理方式』"><a href="#『建议分层异常处理方式』" class="headerlink" title="『建议分层异常处理方式』"></a>『建议分层异常处理方式』</h4><ul><li>(分层异常处理规约)在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行catch，使用catch(Exception e)方式，并throw new xxxException(e)，不需要打印日志，因为日志在 Manager/Service 层一定需要捕获并打印到日志文件中去，如果同台服务器再打日志，浪费性能和存储。<code>在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场</code>。如果 Manager 层与 Service 同机部署，日志方式与 DAO层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。</li></ul><h4 id="『分层领域模型规约』"><a href="#『分层领域模型规约』" class="headerlink" title="『分层领域模型规约』"></a>『分层领域模型规约』</h4><ul><li>DO(Data Object):此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。 </li><li>DTO(Data Transfer Object):数据传输对象，Service 或 Manager 向外传输的对象。 </li><li>BO(Business Object):业务对象，由 Service 层输出的封装业务逻辑的对象。 </li><li><del>AO(ApplicationObject):应用对象，在Web层与Service层之间抽象的复用对象模型， 极为贴近展示层，复用度不高</del>。</li><li><del>VO(View Object):显示层对象，通常是 Web 向模板渲染引擎层传输的对象</del>。</li><li><del>Query:数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的建议查询封装，<code>禁止使用 Map 类来传输</code>。</del> </li></ul><blockquote><p>没有必要过度设计、导致代码量增加。DTO、AO、VO Query 在实际开发过程实际上可以完全复用。Query是查询参数,通常用于用户分页查询和普通参数查询等封装体。BO需要高度抽象，属于业务模型。目前接口数据显示要求不高的情况可以适当放宽，不使用 BO层。</p></blockquote><h4 id="『分层参考』"><a href="#『分层参考』" class="headerlink" title="『分层参考』"></a>『分层参考』</h4><ul><li>推荐的参考</li></ul><blockquote><p>主目录示例:com.github.z201.pre</p><ul><li>com.github.z201   公司域名(这只是例子)</li><li>pre               项目名称</li><li>dao              模块名称</li></ul><p>模块示例:com.github.z201.pre</p><ul><li>dao     #mybaits接口映射层</li><li>entity  # mysql表映射层</li><li>dto      # 网络传输层</li><li>manger # 第三方（缓存、事务、mp、外部接口）</li><li>service  # 主要业务实现（无事务处理、简单业务）</li><li>utils       # 项目工具类（该项目独立使用的）</li></ul><p>对于该模块关键模块，建议单独区分，用于识别。按照黄金法则，一个模块中核心接口少数。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">➜  demo git:(develop) ✗ tree src/main -d -L 7</span><br><span class="line">src/main</span><br><span class="line">├── java</span><br><span class="line">│   └── com</span><br><span class="line">│       └── github</span><br><span class="line">│           └── z201</span><br><span class="line">│               └── pre</span><br><span class="line">│                   ├── annotation <span class="comment"># 关键业务（注解拦截层）</span></span><br><span class="line">│                   ├── dao        <span class="comment"># mybaits接口映射层</span></span><br><span class="line">│                   ├── entity     <span class="comment"># 实体映射层</span></span><br><span class="line">│                   ├── dto     </span><br><span class="line">│                   │   ├── cache <span class="comment"># 缓存传输层</span></span><br><span class="line">│                   │   ├── param  <span class="comment"># 请求参数封装体（Query的细化）</span></span><br><span class="line">│                   │   ├── result <span class="comment"># 响应参数封装体</span></span><br><span class="line">│                   │   └── search <span class="comment"># 查询参数封装体（Query的细化）</span></span><br><span class="line">│                   ├── <span class="built_in">limit</span>      <span class="comment"># 关键业务实现（关键业务不建议放到service层，方便快速识别。）</span></span><br><span class="line">│                   │   └── impl</span><br><span class="line">│                   ├── manger     <span class="comment"># 第三方（缓存、事务、mp、外部接口）</span></span><br><span class="line">│                   │   └── impl   <span class="comment"># 实现类</span></span><br><span class="line">│                   ├── service    <span class="comment"># 主要业务实现（无事务处理）</span></span><br><span class="line">│                   │   └── impl   <span class="comment"># 实现类</span></span><br><span class="line">│                   └── utils      <span class="comment"># 项目工具类（该项目独立使用的）</span></span><br><span class="line">│                       └── common  </span><br><span class="line">│                       </span><br><span class="line">└── resource</span><br><span class="line">    └── mapper <span class="comment"># mybatis文件。</span></span><br></pre></td></tr></table></figure><h3 id="4、保持代码的整洁"><a href="#4、保持代码的整洁" class="headerlink" title="4、保持代码的整洁"></a>4、保持代码的整洁</h3><blockquote><p>写出运行代码（bug）是简单的、写出适合阅读的代码是困难，建议阅读<code>阿里巴巴Java开发手册</code> 以及<code>码出高效Java开发手册</code>相关章节。这里做下内容补充。</p></blockquote><h4 id="『尽可能少写代码』"><a href="#『尽可能少写代码』" class="headerlink" title="『尽可能少写代码』"></a>『尽可能少写代码』</h4><blockquote><p>写的越多错的越多，错的越多修复越难。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用lombok语法糖，简化模版代码。</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmSpaceFunctionCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片主键id（使用运营后台 sm_admin_pictrue表存储图片)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer adminPictureId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 图片地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String picPath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序 默认 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer orderBy;</span><br><span class="line"><span class="comment">// 无 get 、 set 更多特性请查阅lombok使用方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="『提高代码覆盖率』"><a href="#『提高代码覆盖率』" class="headerlink" title="『提高代码覆盖率』"></a>『提高代码覆盖率』</h4><blockquote><p>（避免无调用代码，避免过度使用代码生成器）健壮的代码是干净、简洁的。避免重型项目出现（保持项目业务代码1-2W行，可以适当的模块化）</p></blockquote><h4 id="『合理拆分代码逻辑』"><a href="#『合理拆分代码逻辑』" class="headerlink" title="『合理拆分代码逻辑』"></a>『合理拆分代码逻辑』</h4><blockquote><p>（避免代码过度优化和过早优化，<code>需求一定会改、一定会改、一定会改</code>）适当调整代码，保证阅读方便即可。推荐使用阿里<code>p3c</code>代码检查工具。鬼故事：李光磊以前劝华为的同事用Eclipse，人家打死不肯用。他自己搞起来，给人家说，你看，多方便。华为的同时默默的输入了一个文件名，跳过去，Eclipse崩贵了，文件太大。</p></blockquote><h4 id="『更新注释』"><a href="#『更新注释』" class="headerlink" title="『更新注释』"></a>『更新注释』</h4><blockquote><p>代码千万行，注释第一行。注释不规范，同事两行泪。改代码不改注释非常容易误导他人。尽可能保持个人代码的注释信息合理。</p></blockquote><h4 id="『面向接口编程』"><a href="#『面向接口编程』" class="headerlink" title="『面向接口编程』"></a>『面向接口编程』</h4><blockquote><ul><li>面向接口编程和面向对象编程并不是平级的，它并不是比面向对象编程更先进的一种独立的编程思想，而是附属于面向对象思想体系，属于其一部分。或者说，它是面向对象编程体系中的思想精髓之一。</li><li>在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了；而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。</li></ul></blockquote><ul><li>降低程序的耦合性。在程序中紧密的联系并不是一件好的事情，因为两种事物之间联系越紧密，更换其中之一的难度就越大，扩展功能和debug的难度也就越大。 </li><li>易于程序的扩展。</li><li>有利于程序的维护。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 示例代码,在接口暴露层，是不建议做任何的业务操作。建议使用bean封装数据。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(FunctionController.ROUTER_INDEX)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionController</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ROUTER_INDEX = <span class="string">"/api/space"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    PackageFunctionServiceI packageFunctionService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取功能分页列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/function/list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">listSpaceFunction</span><span class="params">(@RequestBody SpacePackageFunctionSearch pageSearch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> packageFunctionService.listSpaceFunction(pageSearch);</span><br><span class="line">    &#125;</span><br><span class="line">  .....</span><br></pre></td></tr></table></figure><ul><li>if/for/while/switch/do等保留字与左右括号之间都必须加空格。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 合理的增加空格，方便阅读代码。</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == endTime || <span class="number">0L</span> == endTime) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"获取用户vip的到期时间失败了，数据出现异常。～～～"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、防御式编程"><a href="#5、防御式编程" class="headerlink" title="5、防御式编程"></a>5、防御式编程</h3><ul><li>请不要相信任何参数。尽可能保持客观的态度编写代码。参考&lt;&lt;代码大全&gt;&gt; <code>『人类都是不安全、不值得信任的，所有的人，都会犯错误，而你写的代码，应该考虑到所有可能发生的错误，让你的程序不会因为他人的错误而发生错误』</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是从内部接口调用的数据，首先不信任给的数据。避免常规错误导致自己的逻辑出现明显的bug。</span></span><br><span class="line"><span class="comment">// 获取vip的到期时间</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  endTime = spaceVipCacheService.getSpaceVipEndTimeByUserId(userId);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvalidProtocolBufferException e) &#123;</span><br><span class="line">  log.warn(<span class="string">"获取用户vip的到期时间失败了，系统出现异常。～～～ "</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"获取用户vip的到期时间失败了，系统出现异常。～～～"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == endTime || <span class="number">0L</span> == endTime) &#123;</span><br><span class="line">  log.warn(<span class="string">"获取用户vip的到期时间失败了，系统出现异常。～～～ "</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"获取用户vip的到期时间失败了，数据出现异常。～～～"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、抛异常-or-返回错误码-or-日志"><a href="#6、抛异常-or-返回错误码-or-日志" class="headerlink" title="6、抛异常 or 返回错误码 or 日志"></a>6、抛异常 or 返回错误码 or 日志</h3><blockquote><p>公司外的http/api开放接口必须使用“错误码”；应用内部推荐异常抛出(适当抛出堆栈，性能影响)。避免恶意请求接口，并通过返回消息猜出接口参数的问题。日志文件推荐至少保存15天，因为有些异常具备以“周”为频次发生的特点。</p></blockquote><ul><li>就java日志框架而言，建议使用侨接slf4j来输出日志。<ul><li>当遇到问题的时候，只能功过debug功能来确定问题。应该考虑输出日志信息，良好的系统日志信息对问题进行定位的。</li><li>项目中大量的分支判断if \else、switch 的分支时候使用日志可以定位具体是哪个业务流程。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尽可能参数化日志信息，日志是给人看的。不是为了输出而输出。关键参数可以隔离显示比如 [&#123;&#125;]</span></span><br><span class="line">logger.debug(<span class="string">"这是一条debug日志 [&#123;&#125;]"</span> , userId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于debug日志，必须判断日志的级别才能进行输出。</span></span><br><span class="line"><span class="keyword">if</span>(logger.isDebugEnabled())&#123;</span><br><span class="line">  logger.debug(<span class="string">"这是一条debug日志 [&#123;&#125;]"</span> , userId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免使用字符串拼接的方式输出日志，这样会导致生产了很多的string对象。</span></span><br><span class="line">logger.debug(<span class="string">"这是一条字符串拼接的日志输出 : ["</span>  + userId +<span class="string">"]"</span>);</span><br></pre></td></tr></table></figure><ul><li>日志级别的使用<ul><li><code>日志级别 trace, debug, info, warn, error, fatal</code></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 这里以log4j相关的日志的打印级别，OFF即不打印，其他则按照标准级别配置即可，如 debug </span><br><span class="line">       关闭：OFF(0)</span><br><span class="line">致命：FATAL(100)，对应Logger.fatal方法</span><br><span class="line">错误：ERROR(200)，对应Logger.error方法</span><br><span class="line">警告：WARN(300)，对应Logger.warn方法</span><br><span class="line">信息：INFO(400)，对应Logger.info方法</span><br><span class="line">调试：DEBUG(500)，对应Logger.debug方法</span><br><span class="line">跟踪：TRACE(600)，对应Logger.trace方法</span><br><span class="line">全部：ALL(Integer.MAX_VALUE)</span><br><span class="line">当指定某一个级别时，比如DEBUG，那么所有低于这个级别的其它级别日志，都会被打印。</span><br><span class="line">当指定级别为DEBUG时，Logger.debug、Logger.info、Logger.warn、Logger.error以及Logger.fatal等方法</span><br><span class="line">都能输出日志，但Logger.trace无法输出日志。</span><br></pre></td></tr></table></figure><ul><li>error：对于影响到程序正常运行的信息，需要及时补货并输出，适用范围<code>配置文件读取失败、第三方调用失败、数据库连接失败、缓存等关键组件失败异常</code></li></ul><h3 id="7、方法命名、变量命名"><a href="#7、方法命名、变量命名" class="headerlink" title="7、方法命名、变量命名"></a>7、方法命名、变量命名</h3><blockquote><p>建议阅读<code>阿里巴巴Java开发手册</code> 以及<code>码出高效Java开发手册</code>相关章节。这里做下内容补充。</p></blockquote><ul><li><p>变量命名</p><blockquote><p>如果想不到合适的变量名字，麻烦把注释写清楚。如果连思考的时间都没有请使用TODO标记。</p></blockquote></li><li><p>service层</p><blockquote><p>如果想不到合适的方法名字，麻烦把注释写全。如果连思考的时间都没有请使用TODO标记。</p></blockquote></li><li><p>Dao层</p><blockquote><p>如果是批量建议加上Batch。</p></blockquote></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">获取单个对象 &#96;getXxx&#96;</span><br><span class="line">获取多个对象&#96;listXxx&#96;</span><br><span class="line">通过复杂的查询&#96;listXxxBySearch&#96;这里的&#96;search&#96;就是参数封装体</span><br><span class="line">获取统计值 &#96;countXxx&#96;</span><br><span class="line">插入&#96;saveXxx&#96; &#x2F; &#96;insertXxx&#96;</span><br><span class="line">删除 &#96;removeXxx&#96; &#x2F; &#96;deleteXxx&#96;</span><br><span class="line">修改 &#96;updateXxx&#96;</span><br></pre></td></tr></table></figure><h3 id="8、Redis"><a href="#8、Redis" class="headerlink" title="8、Redis"></a>8、Redis</h3><ul><li>key名设计</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#建议：可读性和可管理性（redis作为标准缓存时推荐）</span><br><span class="line">#以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</span><br><span class="line">ugc:video:1</span><br><span class="line"></span><br><span class="line">#简洁性</span><br><span class="line">#建议：保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</span><br><span class="line">user:&#123;uid&#125;:friends:messages:&#123;mid&#125;简化为u:&#123;uid&#125;:fr:m:&#123;mid&#125;。</span><br><span class="line"></span><br><span class="line">#强制：不要包含特殊字符</span><br><span class="line">反例：包含空格、换行、单双引号以及其他转义字符</span><br></pre></td></tr></table></figure><ul><li>value设计</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 强制：拒绝bigkey(防止网卡流量、慢查询)</span><br><span class="line">string类型控制在20KB以内，hash、list、set、zset元素个数不要超过5000，这里指的是field(不是key)。</span><br><span class="line"># 反例：一个包含200万个元素的list。</span><br><span class="line">非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查))。</span><br><span class="line"></span><br><span class="line"># 建议- 选择适合的数据类型。</span><br><span class="line">例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如ziplist，但也要注意节省内存和性能之间的平衡)</span><br><span class="line"></span><br><span class="line"># 反例</span><br><span class="line">set user:1:name tom</span><br><span class="line">set user:1:age 19</span><br><span class="line">set user:1:favor football</span><br><span class="line"></span><br><span class="line">改进</span><br><span class="line">hmset user:1 name tom age 19 favor football</span><br></pre></td></tr></table></figure><ul><li>控制key的生命周期，redis不是垃圾桶。</li></ul><p><code>建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime。</code></p><ul><li>【建议】：禁用命令</li></ul><p>禁止线上（正式环境）使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。</p><ul><li>【建议】使用批量操作提高效率</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原生命令：例如mget、mset。</span><br><span class="line">非原生命令：可以使用pipeline提高效率。</span><br><span class="line">但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。</span><br><span class="line">注意两者不同：</span><br><span class="line">1. 原生是原子操作，pipeline是非原子操作。</span><br><span class="line">2. pipeline可以打包不同的命令，原生做不到。</span><br><span class="line">3. pipeline需要客户端和服务端同时支持。</span><br></pre></td></tr></table></figure><ul><li>【建议】Redis（伪）事务功能较弱，不建议过多使用</li></ul><p>Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot上(可以使用hashtag功能解决)。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;好久没更新博客，最近公司让我出一个代码规范，我吓了一跳。赶忙翻出阿里《 码出高效》，不敢造次，我就补充点个人的想法吧。代码是给人看的。代码风格应该遵循&lt;code&gt;极简主义&lt;/code&gt;                                                                                                      &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1、避免复杂、追求简单&quot;&gt;&lt;a href=&quot;#1、避免复杂、追求简单&quot; class=&quot;headerlink&quot; title=&quot;1、避免复杂、追求简单&quot;&gt;&lt;/a&gt;1、避免复杂、追求简单&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;日常开发中，除了解决业务问题还需要解决许多的工程问题。如何选择当下合适的方法解决问题；需要不断尝试和摸索，没有最好的方法只有更好的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2、合理平滑的处理技术债务&quot;&gt;&lt;a href=&quot;#2、合理平滑的处理技术债务&quot; class=&quot;headerlink&quot; title=&quot;2、合理平滑的处理技术债务&quot;&gt;&lt;/a&gt;2、合理平滑的处理技术债务&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;技术的演变速度太快，如何避免长时间的技术债务是非常严重的问题，总之弊大于利。尽可能保持轻装上阵，避免拖油瓶项目。&lt;/p&gt;
&lt;p&gt;关键字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一方库: 本工程内部子项目模块依赖的库(jar 包)。 &lt;/li&gt;
&lt;li&gt;二方库: 公司内部发布到中央仓库，可供公司内部其它应用依赖的库(jar包)。 &lt;/li&gt;
&lt;li&gt;三方库: 公司之外的开源库(jar 包)。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;『避免过度封装』&quot;&gt;&lt;a href=&quot;#『避免过度封装』&quot; class=&quot;headerlink&quot; title=&quot;『避免过度封装』&quot;&gt;&lt;/a&gt;『避免过度封装』&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;特别是没有完整的技术人员编制的情况下，怎么简单怎么处理（去除中间商赚差价一个道理。）避免过度开发&lt;code&gt;一方库&lt;/code&gt;；建议使用原生方式(综合评估代码量)&lt;code&gt;避免框架过度封装&lt;/code&gt;。（Java的方法调用链过长是出了名的恶心）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;『避免代码过度重复』&quot;&gt;&lt;a href=&quot;#『避免代码过度重复』&quot; class=&quot;headerlink&quot; title=&quot;『避免代码过度重复』&quot;&gt;&lt;/a&gt;『避免代码过度重复』&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;每次开发业务都会写很多的代码。定期对公司项目进行基础代码的重构。合理的拆分&lt;code&gt;业务无关的基础代码&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;『避免版本混乱』&quot;&gt;&lt;a href=&quot;#『避免版本混乱』&quot; class=&quot;headerlink&quot; title=&quot;『避免版本混乱』&quot;&gt;&lt;/a&gt;『避免版本混乱』&lt;/h4&gt;&lt;p&gt;使用统一的版本管理。约束所有的项目jar版本依赖。防止因为过度使用&lt;code&gt;三方库&lt;/code&gt;出现奇怪的bug。公司&lt;code&gt;bom&lt;/code&gt;需要单独处理。尽量保持与社区版本同步，比如springboot最新版是2.1.3 ，那么公司使用的版本最好是近半年的GA版本。&lt;/p&gt;
&lt;h4 id=&quot;『物极必反』&quot;&gt;&lt;a href=&quot;#『物极必反』&quot; class=&quot;headerlink&quot; title=&quot;『物极必反』&quot;&gt;&lt;/a&gt;『物极必反』&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;请勿过度依赖某框架栈或者解决方式，客观的对比相关解决方案优缺点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;『选择大于努力』&quot;&gt;&lt;a href=&quot;#『选择大于努力』&quot; class=&quot;headerlink&quot; title=&quot;『选择大于努力』&quot;&gt;&lt;/a&gt;『选择大于努力』&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;集中精力掌握核心知识。按照目前技术演变的速度，更新最快的是应用技术，其次是行业规范相关技术。最后才是革命性的技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93/%E6%8A%80%E6%9C%AF%E8%B1%A1%E9%99%90%E5%9B%BE.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件工程" scheme="https://z201.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>idea常用插件</title>
    <link href="https://z201.github.io/2019/05/08/idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    <id>https://z201.github.io/2019/05/08/idea%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/</id>
    <published>2019-05-08T08:35:04.000Z</published>
    <updated>2019-05-08T15:56:05.247Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有必要记录下自己常用的插件，避免特殊事件的发生。</p></blockquote><h4 id="Free-Mybatis-plugin"><a href="#Free-Mybatis-plugin" class="headerlink" title="Free Mybatis plugin"></a>Free Mybatis plugin</h4><blockquote><p>Mybatis 插件，可以定位java和xml关系。通过java接口快速生成相关xml文件或者方法。</p></blockquote><h4 id="Mybaits-Log-plugin"><a href="#Mybaits-Log-plugin" class="headerlink" title="Mybaits Log plugin"></a>Mybaits Log plugin</h4><blockquote><p>使用插件将mybaits默认的日志输出转换成可以运行的sql日志。</p></blockquote><h4 id="Alibaba-java-coding-guidelines"><a href="#Alibaba-java-coding-guidelines" class="headerlink" title="Alibaba-java-coding-guidelines"></a>Alibaba-java-coding-guidelines</h4><blockquote><p>阿里巴巴java代码检查工具</p></blockquote><h4 id="json2pojo"><a href="#json2pojo" class="headerlink" title="json2pojo"></a>json2pojo</h4><blockquote><p>json转bean的工具</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有必要记录下自己常用的插件，避免特殊事件的发生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;Free-Mybatis-plugin&quot;&gt;&lt;a href=&quot;#Free-Mybatis-plugin&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Idea" scheme="https://z201.github.io/tags/Idea/"/>
    
  </entry>
  
  <entry>
    <title>idea快捷键练习</title>
    <link href="https://z201.github.io/2019/05/06/idea%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%BB%83%E4%B9%A0/"/>
    <id>https://z201.github.io/2019/05/06/idea%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%BB%83%E4%B9%A0/</id>
    <published>2019-05-06T01:37:48.000Z</published>
    <updated>2019-05-27T07:11:51.270Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>每次都需要重新去查阅文档，不如整理一下idea常用的快捷键</p></blockquote><h4 id="查看某个方法被调用的地方。-鼠标选中方法名称"><a href="#查看某个方法被调用的地方。-鼠标选中方法名称" class="headerlink" title="查看某个方法被调用的地方。(鼠标选中方法名称)"></a>查看某个方法被调用的地方。(鼠标选中方法名称)</h4><p><code>Navigate | Call Hierarchy </code> 快捷键<code>control + option + h</code></p><h4 id="Genterate-代码生成"><a href="#Genterate-代码生成" class="headerlink" title="Genterate 代码生成"></a>Genterate 代码生成</h4><p><code>Code | Genterate</code> #快捷键 <code>command + n</code></p><h4 id="Copyright-模版"><a href="#Copyright-模版" class="headerlink" title="Copyright 模版"></a>Copyright 模版</h4><p><code>Edit | Copyright | Copyright profiles </code></p><ul><li>样板</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Copyright (c) $today.year  </span><br><span class="line">@Author:z201.coding@gamil.com</span><br><span class="line">@LastModified:$today.format(&quot;yyyy-MM-dd&quot;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="快捷搜索"><a href="#快捷搜索" class="headerlink" title="快捷搜索"></a>快捷搜索</h4><p><code>shift 两次</code></p><h4 id="全文搜索"><a href="#全文搜索" class="headerlink" title="全文搜索"></a>全文搜索</h4><p><code>command + shift + f</code></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;每次都需要重新去查阅文档，不如整理一下idea常用的快捷键&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;查看某个方法被调用的地方。-鼠标选中方法名称&quot;&gt;&lt;a href=&quot;#查看某个方法被调用的地方。-鼠标选中方法名称&quot; class=&quot;headerlink&quot; title=&quot;查看某个方法被调用的地方。(鼠标选中方法名称)&quot;&gt;&lt;/a&gt;查看某个方法被调用的地方。(鼠标选中方法名称)&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Navigate | Call Hierarchy &lt;/code&gt; 快捷键&lt;code&gt;control + option + h&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;Genterate-代码生成&quot;&gt;&lt;a href=&quot;#Genterate-代码生成&quot; class=&quot;headerlink&quot; title=&quot;Genterate 代码生成&quot;&gt;&lt;/a&gt;Genterate 代码生成&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Code | Genterate&lt;/code&gt; #快捷键 &lt;code&gt;command + n&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;Copyright-模版&quot;&gt;&lt;a href=&quot;#Copyright-模版&quot; class=&quot;headerlink&quot; title=&quot;Copyright 模版&quot;&gt;&lt;/a&gt;Copyright 模版&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Edit | Copyright | Copyright profiles &lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;样板&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Copyright (c) $today.year  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@Author:z201.coding@gamil.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@LastModified:$today.format(&amp;quot;yyyy-MM-dd&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Idea" scheme="https://z201.github.io/tags/Idea/"/>
    
  </entry>
  
  <entry>
    <title>源码分析-skywalking源码环境搭建</title>
    <link href="https://z201.github.io/2019/04/21/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-skywalking%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://z201.github.io/2019/04/21/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-skywalking%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2019-04-21T10:40:55.000Z</published>
    <updated>2019-04-22T16:03:29.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-阅读源代码"><a href="#0x00-阅读源代码" class="headerlink" title="0x00 阅读源代码"></a>0x00 阅读源代码</h2><blockquote><p>长达9天的断网终于结束了。</p></blockquote><h3 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h3><ul><li>代码仓库地址 <a href="https://gitee.com/Z201/skywalking.git" target="_blank" rel="noopener">https://gitee.com/Z201/skywalking.git</a></li><li>阅读版本号 <code>v6.0.0-GA</code></li><li>下载版本<code>git clone -b v6.0.0-GA https://github.com/apache/skywalking.git</code><ul><li>由于github下载速度是在太慢了，这里用gitee克隆一个镜像。</li><li>下载版本<code>git clone -b v6.0.0-GA https://gitee.com/Z201/skywalking.git</code></li></ul></li></ul><h3 id="查看源代码结构"><a href="#查看源代码结构" class="headerlink" title="查看源代码结构"></a>查看源代码结构</h3><blockquote><p>源码设计子项目过多，这里简单暂时2级目录。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tree -d L 2</span><br><span class="line">.</span><br><span class="line">├── src  </span><br><span class="line">│   ├── main # 源代码</span><br><span class="line">│   ├── site # 站点稳当</span><br><span class="line">│   └── test # 单元测试</span><br><span class="line">└── travis   # 官方的ci集成</span><br></pre></td></tr></table></figure><ul><li>查看项目源码主目录</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  skywalking git:(8b638258b) tree -d -L 1</span><br><span class="line">.</span><br><span class="line">├── apm-application-toolkit</span><br><span class="line">├── apm-checkstyle</span><br><span class="line">├── apm-commons</span><br><span class="line">├── apm-dist</span><br><span class="line">├── apm-protocol <span class="comment"># pd文件</span></span><br><span class="line">├── apm-sniffer <span class="comment"># 插件</span></span><br><span class="line">├── apm-webapp  </span><br><span class="line">├── docker</span><br><span class="line">├── docs</span><br><span class="line">├── licenses</span><br><span class="line">├── oap-server <span class="comment"># 这里和5.x 有很大的不同改动了很多东西。</span></span><br><span class="line">├── skywalking-ui </span><br><span class="line">└── tools</span><br></pre></td></tr></table></figure><ul><li>将项目导入idea中。</li></ul><p>官方文档:<a href="https://github.com/apache/skywalking/blob/master/docs/en/guides/How-to-build.md" target="_blank" rel="noopener">如何构建</a></p><p><code>git submodule init</code></p><p><code>git submodule update</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  skywalking git:(8b638258b) git submodule init</span><br><span class="line">Submodule <span class="string">'apm-protocol/apm-network/src/main/proto'</span> (https://github.com/apache/incubator-skywalking-data-collect-protocol.git) registered <span class="keyword">for</span> path <span class="string">'apm-protocol/apm-network/src/main/proto'</span></span><br><span class="line">Submodule <span class="string">'oap-server/server-query-plugin/query-graphql-plugin/src/main/resources/query-protocol'</span> (https://github.com/apache/incubator-skywalking-query-protocol.git) registered <span class="keyword">for</span> path <span class="string">'oap-server/server-query-plugin/query-graphql-plugin/src/main/resources/query-protocol'</span></span><br><span class="line">Submodule <span class="string">'skywalking-ui'</span> (https://github.com/apache/incubator-skywalking-ui) registered <span class="keyword">for</span> path <span class="string">'skywalking-ui'</span></span><br><span class="line">➜  skywalking git:(8b638258b) git submodule update</span><br><span class="line">Cloning into <span class="string">'/Users/zengqingfeng/word/source-code/skywalking/apm-protocol/apm-network/src/main/proto'</span>...</span><br><span class="line">Cloning into <span class="string">'/Users/zengqingfeng/word/source-code/skywalking/oap-server/server-query-plugin/query-graphql-plugin/src/main/resources/query-protocol'</span>...</span><br><span class="line">Cloning into <span class="string">'/Users/zengqingfeng/word/source-code/skywalking/skywalking-ui'</span>...</span><br><span class="line">Submodule path <span class="string">'apm-protocol/apm-network/src/main/proto'</span>: checked out <span class="string">'b66fa070fd647662f06497e4ed3657eb258cb6e9'</span></span><br><span class="line">Submodule path <span class="string">'oap-server/server-query-plugin/query-graphql-plugin/src/main/resources/query-protocol'</span>: checked out <span class="string">'c65a23bd6b9bba8d1df30d4de261624952df2b7b'</span></span><br><span class="line">Submodule path <span class="string">'skywalking-ui'</span>: checked out <span class="string">'c44642f73b9f73a54b0d716cade5094304e1a67b'</span></span><br></pre></td></tr></table></figure><p><code>clean package -DskipTests</code></p><blockquote><p>这个时候慢慢等吧v6.0.0-GA有120个子项目。更新完之后导入IDEA就好了。</p></blockquote><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-阅读源代码&quot;&gt;&lt;a href=&quot;#0x00-阅读源代码&quot; class=&quot;headerlink&quot; title=&quot;0x00 阅读源代码&quot;&gt;&lt;/a&gt;0x00 阅读源代码&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;长达9天的断网终于结束了。&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
    
      <category term="源码分析" scheme="https://z201.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
</feed>
