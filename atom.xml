<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫叶的小博客</title>
  
  <subtitle>先完成、在完美。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://z201.github.io/"/>
  <updated>2021-09-20T13:40:28.701Z</updated>
  <id>https://z201.github.io/</id>
  
  <author>
    <name>小峰同学</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>permission-design</title>
    <link href="https://z201.github.io/2021/09/20/Permission-design/"/>
    <id>https://z201.github.io/2021/09/20/Permission-design/</id>
    <published>2021-09-20T13:38:35.000Z</published>
    <updated>2021-09-20T13:40:28.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>权限管理是一个几乎所有大中型 B 端系统都会涉及的重要组成部分，其目的是对整个系统进行权限控制，避免造成误操作及数据泄露等风险问题。</p></blockquote><h2 id="权限与权限管理"><a href="#权限与权限管理" class="headerlink" title="权限与权限管理"></a>权限与权限管理</h2><h3 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h3><blockquote><p>在讲述有赞使用的权限模型之前，先介绍一下权限相关的基本概念：</p></blockquote><ul><li>权限：用户可操作行为的最小单位。</li><li>用户：每个用户都有唯一标识，并被授予一个或多个角色。</li><li>角色：由不同的权限组合而成，最终分配给具体用户。</li><li>权限管理：控制用户的权限，只能访问授权内容。</li></ul><h3 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h3><ul><li>ACL（Access Control List）：基于用户级别的权限控制。<ul><li>将系统的各种权限直接授予具体的用户。抽象来说，为每个用户维护了单独的权限列表，当需要分配权限、收回权限时，需要修改对应用户的权限信息。</li></ul></li><li>RBAC（Role Base Access Control）：基于角色级别的权限控制。<ul><li>与 ACL 对比，RBAC不用给用户单个分配权限，权限与用户之前通过角色关联。通过给不同的角色分配不同的权限，只需要将用户指向对应的角色就会有对应的权限。分配权限、收回权限只需要通过修改用户的角色即可。</li></ul></li><li>ABAC（Attribute Base Access Control）：基于属性级别的权限控制。<ul><li>不同于常见的将用户通过某种方式直接关联到权限的方式，ABAC 是通过动态计算一个或一组属性来是否满足某种条件来进行权限判断。属性一般分为四类：用户属性（自然人属性，如年龄、性别等），环境属性（物理环境，如时间、地点、气候），操作属性（读、写）和对象属性（操作对象，如资金、某张图片、某个特定的页面，又称资源属性）。</li></ul></li><li>因此理论上能够实现灵活的权限控制、将在权限与用户之前通过一组或多组属性实现关联，几乎能满足所有类型的需求。</li></ul><h3 id="权限管控"><a href="#权限管控" class="headerlink" title="权限管控"></a>权限管控</h3><blockquote><p>抽象来看权限体系可以分为如下两类：功能权限 与 数据权限 两部分。</p></blockquote><ul><li>功能权限指的是在系统中的功能可否使用，通常我们将功能权限分为查看、编辑、删除等，同时编辑、删除权限又包含了查看。通过小的权限点拆分更精细的赋予了员工能否进入某个页面查看信息、编辑信息的能力。</li><li>数据权限指数据中存在的数据是否能查看，是一个更细粒度的权限。比如一个页面，不同角色查看不同的数据就需要通过数据权限控制。<br>从管理对象维度又可以分为：企业能力 与 员工能力。</li><li>企业能力店铺维度的权限，比如开通某服务，可以通过企业能力去体现。</li><li>企业能力赋予用户的权限，比如收电子发票、资金管理等。</li><li>企业能力优先级绝对高于员工能力，所有场景的权限判断，店铺能力必须先于员工能力。简单地说，企业能力决定了“企业能做什么”，员工能力决定了“用户能做什么”。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;权限管理是一个几乎所有大中型 B 端系统都会涉及的重要组成部分，其目的是对整个系统进行权限控制，避免造成误操作及数
      
    
    </summary>
    
    
      <category term="系统设计" scheme="https://z201.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="系统设计" scheme="https://z201.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="权限设计" scheme="https://z201.github.io/tags/%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>git-develop-branch</title>
    <link href="https://z201.github.io/2021/09/20/Git-Develop-Branch/"/>
    <id>https://z201.github.io/2021/09/20/Git-Develop-Branch/</id>
    <published>2021-09-20T13:34:52.000Z</published>
    <updated>2021-09-20T13:39:54.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="规范代码开发流程"><a href="#规范代码开发流程" class="headerlink" title="规范代码开发流程"></a>规范代码开发流程</h2><blockquote><p>git 分支分为集成分支、功能分支和修复分支，分别命名为 develop、feature 和 hotfix，均为单数。不可使用 features、future、hotfixes、hotfixs 等错误名称。</p></blockquote><p>1.git主分支(master)。它是自动建立，用于发布重大版本更新（github 现在默认是是main 因种族歧视问题）<br>2.git开发主分支(develop)。日常开发在此分支上进行<br>3.git临时性分支：用于应对一些特定目的的版本开发(验证OK后，应该删除此分支)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 功能（feature）分支：它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。可以采用feature-的形式命名。</span><br><span class="line">- 预发布（release）分支：指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从Develop分支上面分出来的，预发布结束以后，</span><br><span class="line">必须合并进Develop和Master分支。它的命名，可以采用release-的形式。</span><br><span class="line">- 修补bug（hotfix）分支：软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。修补bug分支是从Master或Develop分支上面分出来的。修补结束以后，</span><br><span class="line">再合并进Master和Develop分支。它的命名，可以采用hotfix-***的形式。</span><br></pre></td></tr></table></figure><p>开发流程</p><blockquote><p>暂定临时分支feature、hotfix两种启用。暂不启用RP、code review。</p></blockquote><p>1.基于develop生成新临时开发分支。<br>2.测试、正式环境上线通过。<br>3.合并至develop分支，并生成对应的tag版本。<br>4.完成特定功能开发后(验证OK后，应该删除此分支)。<br>5.README.md文档中记录tag版本生成时间以及具体的功能名称。</p><p>修复bug流程</p><blockquote><p>根据最新已经上线的分支代码创建hotfix分支。</p></blockquote><p>1.基于develop或者上个tag版本(根据实际情况而定)生成新临时开发分支。<br>2.测试、正式环境上线通过。<br>3.合并至develop分支，并生成对应的tag版本。<br>4.<code>若存在临时开发分支</code>-完成特定功能开发后(验证OK后，应该删除此分支)。<br>5.<code>若存在临时开发分支</code>-临时开发分支合并已经修复bug的develop代码。<br>6.<code>若存在临时开发分支</code>-临时开发分支完成特定功能开发后(验证OK后，应该删除此分支)。<br>7.README.md文档中记录tag版本生成时间以及具体的功能名称。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="开发尺码"><a href="#开发尺码" class="headerlink" title="开发尺码"></a>开发尺码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop &#x2F;&#x2F; 切换开发分支，git pull origin develop 并同步最新的develop分支代码。（强制）</span><br><span class="line">git checkout -b feature-sizeGroup &#x2F;&#x2F;基于develop分支创建新的开发分支（强制）</span><br><span class="line">git checkout develop &#x2F;&#x2F; feature-sizeGroup完成上线后develop分支准备合并分支（强制）</span><br><span class="line">git merge feature-sizeGroup &#x2F;&#x2F; 合并开发功能分支（强制）</span><br><span class="line">git tag -a v1.4 -m &quot;my version 1.4&quot; &#x2F;&#x2F; 合并完成创建标签备注中简单说明开发功能（强制）</span><br><span class="line">git push origin v1.4 &#x2F;&#x2F; 推送tag标签到远程仓库（强制）</span><br><span class="line">git branch -d feature-sizeGroup &#x2F;&#x2F;删除本地的临时开发分支(非强制)</span><br><span class="line">git push origin --delete feature-sizeGroup &#x2F;&#x2F; 删除远程的临时开发分支（强制）</span><br><span class="line">vim README.md &#x2F;&#x2F; 保存新增tag版本记录（强制）</span><br><span class="line">git add README.md &#x2F;&#x2F; 追踪README.md文件。（强制）</span><br><span class="line">git commit -m &quot;发布新的tag&quot; &#x2F;&#x2F; 将暂存区里的改动给提交到本地的版本库（强制）</span><br><span class="line">git push origin develop &#x2F;&#x2F; 推送改动后的develop（强制）</span><br></pre></td></tr></table></figure><h3 id="master-合并周期"><a href="#master-合并周期" class="headerlink" title="master 合并周期"></a>master 合并周期</h3><blockquote><p>每月月底最后几个工作日完成对master 对develop分支的合并。</p></blockquote><h3 id="tag-版本命名"><a href="#tag-版本命名" class="headerlink" title="tag 版本命名"></a>tag 版本命名</h3><blockquote><p>版本命名规范</p></blockquote><ul><li>版本: v1.1.1 ( Build 101001 )</li><li>版本格式 bigVersion.middleVersion.smallVersion</li><li>bigVersion 大版本(年度或者重大更新（强制更新，老版本存在不兼容等情况）) 取值范围 1-99</li><li>middleVersion 迭代版本 取值范围 1-99</li><li>smallVersion bug修复增强发布。 取值范围 1-999</li><li>Build为版本纯数字格式化。</li></ul><h3 id="git帮助文档"><a href="#git帮助文档" class="headerlink" title="git帮助文档"></a>git帮助文档</h3><p><a href="https://gitee.com/all-about-git" target="_blank" rel="noopener">git 大全</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;规范代码开发流程&quot;&gt;&lt;a href=&quot;#规范代码开发流程&quot; class=&quot;headerlink&quot; title=&quot;规范代码开发流程&quot;&gt;&lt;/a&gt;规范代码开发流程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;git 分支分为集成分支、功能分支和修复分支，分别命名为 deve
      
    
    </summary>
    
    
      <category term="Git" scheme="https://z201.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://z201.github.io/tags/Git/"/>
    
      <category term="Develop" scheme="https://z201.github.io/tags/Develop/"/>
    
      <category term="Branch" scheme="https://z201.github.io/tags/Branch/"/>
    
  </entry>
  
  <entry>
    <title>Jvm-optimization</title>
    <link href="https://z201.github.io/2021/08/19/Jvm-optimization/"/>
    <id>https://z201.github.io/2021/08/19/Jvm-optimization/</id>
    <published>2021-08-19T06:09:45.000Z</published>
    <updated>2021-08-19T08:36:55.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jvm调优是日常工作中经常会使用的技巧，整理下。</p></blockquote><h3 id="项目启动的时候加上的参数都是些啥意思？"><a href="#项目启动的时候加上的参数都是些啥意思？" class="headerlink" title="项目启动的时候加上的参数都是些啥意思？"></a>项目启动的时候加上的参数都是些啥意思？</h3><blockquote><p>刚开始工作的时候发现同事会在jar启动的命令上增加很多参数,很长一段时间都不清楚是干啥的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=<span class="number">128</span>m -XX:MaxMetaspaceSize=<span class="number">128</span>m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=<span class="number">8</span> -XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure><ul><li>简单介绍下参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=<span class="number">128</span>m （元空间默认大小）</span><br><span class="line">-XX:MaxMetaspaceSize=<span class="number">128</span>m （元空间最大大小）</span><br><span class="line">-Xms1024m （堆最大大小）</span><br><span class="line">-Xmx1024m （堆默认大小）</span><br><span class="line">-Xmn256m （新生代大小）</span><br><span class="line">-Xss256k （棧最大深度大小）</span><br><span class="line">-XX:SurvivorRatio=<span class="number">8</span> （新生代分区比例 <span class="number">8</span>:<span class="number">2</span>）</span><br><span class="line">-XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器）</span><br><span class="line">-XX:+PrintGCDetails （打印详细的GC日志）</span><br></pre></td></tr></table></figure><ul><li>虽然有了介绍但是依然不清楚具体是干啥的。并且Java虚拟机提供了非常多的参数命令。下面代码可以输出支持的参数数量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -XX:+UnlockDiagnosticVMOptions -version | wc -l</span><br><span class="line">openjdk version <span class="string">"1.8.0_275"</span></span><br><span class="line"><span class="function">OpenJDK Runtime <span class="title">Environment</span> <span class="params">(AdoptOpenJDK)</span><span class="params">(build <span class="number">1.8</span><span class="number">.0</span>_275-b01)</span></span></span><br><span class="line"><span class="function">OpenJDK 64-Bit Server <span class="title">VM</span> <span class="params">(AdoptOpenJDK)</span><span class="params">(build <span class="number">25.275</span>-b01, mixed mode)</span></span></span><br><span class="line"><span class="function">     838</span></span><br></pre></td></tr></table></figure><h3 id="如何理解这些参数的含义？"><a href="#如何理解这些参数的含义？" class="headerlink" title="如何理解这些参数的含义？"></a>如何理解这些参数的含义？</h3><blockquote><p>首先我们需要理解java是如何运行的，为什么需要java虚拟机？    </p><p>我们常用方式一般是安装java运行环境(jre)用命令行的方式启动或者直接双击jar运行。jre包含的java运行的必要环境。</p><p>Java 作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。编译出来的也不是机器可以直接直接运行代码。所以使用面向Java语言的虚拟机运行Java编译以后的特定代码。这里的特定代码指的是Java字节指令码。</p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;jvm调优是日常工作中经常会使用的技巧，整理下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;项目启动的时候加上的参数都是些啥意思？&quot;&gt;&lt;a href=&quot;#项目启动的时候加上的参数都是些啥意思？&quot; class=&quot;headerlink&quot; title=&quot;项目启动的时候加上的参数都是些啥意思？&quot;&gt;&lt;/a&gt;项目启动的时候加上的参数都是些啥意思？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;刚开始工作的时候发现同事会在jar启动的命令上增加很多参数,很长一段时间都不清楚是干啥的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-XX:MetaspaceSize=&lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;m -XX:MaxMetaspaceSize=&lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; -XX:+UseConcMarkSweepGC&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;简单介绍下参数&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-XX:MetaspaceSize=&lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;m （元空间默认大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-XX:MaxMetaspaceSize=&lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;m （元空间最大大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-Xms1024m （堆最大大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-Xmx1024m （堆默认大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-Xmn256m （新生代大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-Xss256k （棧最大深度大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-XX:SurvivorRatio=&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; （新生代分区比例 &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-XX:+PrintGCDetails （打印详细的GC日志）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;虽然有了介绍但是依然不清楚具体是干啥的。并且Java虚拟机提供了非常多的参数命令。下面代码可以输出支持的参数数量&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java -XX:+PrintFlagsFinal -XX:+UnlockDiagnosticVMOptions -version | wc -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;openjdk version &lt;span class=&quot;string&quot;&gt;&quot;1.8.0_275&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;OpenJDK Runtime &lt;span class=&quot;title&quot;&gt;Environment&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(AdoptOpenJDK)&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(build &lt;span class=&quot;number&quot;&gt;1.8&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;_275-b01)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;OpenJDK 64-Bit Server &lt;span class=&quot;title&quot;&gt;VM&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(AdoptOpenJDK)&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(build &lt;span class=&quot;number&quot;&gt;25.275&lt;/span&gt;-b01, mixed mode)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;     838&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;如何理解这些参数的含义？&quot;&gt;&lt;a href=&quot;#如何理解这些参数的含义？&quot; class=&quot;headerlink&quot; title=&quot;如何理解这些参数的含义？&quot;&gt;&lt;/a&gt;如何理解这些参数的含义？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;首先我们需要理解java是如何运行的，为什么需要java虚拟机？    &lt;/p&gt;
&lt;p&gt;我们常用方式一般是安装java运行环境(jre)用命令行的方式启动或者直接双击jar运行。jre包含的java运行的必要环境。&lt;/p&gt;
&lt;p&gt;Java 作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。编译出来的也不是机器可以直接直接运行代码。所以使用面向Java语言的虚拟机运行Java编译以后的特定代码。这里的特定代码指的是Java字节指令码。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Jvm" scheme="https://z201.github.io/categories/Jvm/"/>
    
    
      <category term="Jvm" scheme="https://z201.github.io/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>Nginx-log-format</title>
    <link href="https://z201.github.io/2021/08/18/Nginx-log-format/"/>
    <id>https://z201.github.io/2021/08/18/Nginx-log-format/</id>
    <published>2021-08-18T10:11:55.000Z</published>
    <updated>2021-08-19T06:07:24.818Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Ngxin 日志格式化</p></blockquote><ul><li>Nginx提供的访问日志里就蕴藏着大量有用信息。今天这篇要说的就是如果修改Nginx默认日志格式，以便于我们更好的挖掘有效指标。</li></ul><p>编辑<code>/etc/nginx.conf</code>配置文件，在日志部分添加下面两段代码，编辑完成后重启Nginx服务即可。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> main <span class="string">'<span class="variable">$host</span> - <span class="variable">$remote_addr</span> - [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                <span class="string">'<span class="variable">$status</span> <span class="variable">$upstream_response_time</span> <span class="variable">$request_time</span> "<span class="variable">$http_referer</span>"'</span></span><br><span class="line">                <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>" <span class="variable">$body_bytes_sent</span> '</span>;</span><br><span class="line"><span class="attribute">access_log</span> /var/log/nginx/access.log main;</span><br></pre></td></tr></table></figure><blockquote><p>简单罗列一下变量的含义:</p></blockquote><ul><li><code>$host</code> 访问域名</li><li><code>$remote_addr</code> 客户端IP地址</li><li><code>$time_local</code> 访问时间</li><li><code>$status</code> 访问状态码</li><li><code>$upstream_response_time</code> 应用返回到Nginx的时间</li><li><code>$request_time</code> 请求时间</li><li><code>$http_referer</code> 请求来源</li><li><code>$http_user_agent</code> 访问客户端</li><li><code>$http_x_forwarded_for</code> 客户端IP地址</li><li><code>$body_bytes_sent</code> 返回给客户端大小</li></ul><blockquote><p>在server中不生效的问题</p></blockquote><ul><li>在server中增加 <code>access_log /var/log/nginx/access.log main;</code></li></ul><blockquote><p>日期显示问题</p></blockquote><ul><li><p><code>[01/Jul/2020:03:25:17 +0800]  </code>官方默认是这种</p></li><li><p>修改默认格式</p></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> main <span class="string">'<span class="variable">$host</span> - <span class="variable">$remote_addr</span> - [<span class="variable">$time_iso8601</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                <span class="string">'<span class="variable">$status</span> <span class="variable">$upstream_response_time</span> <span class="variable">$request_time</span> "<span class="variable">$http_referer</span>"'</span></span><br><span class="line">                <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>" <span class="variable">$body_bytes_sent</span> '</span>;</span><br><span class="line"><span class="attribute">access_log</span> /var/log/nginx/access.log main;</span><br></pre></td></tr></table></figure><ul><li>在server中增加下面代码</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"></span><br><span class="line">if ($time_iso8601 ~ "^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;) (\d&#123;2&#125;):(\d&#123;2&#125;):(\d&#123;2&#125;)") &#123;</span><br><span class="line"><span class="attribute">set</span> <span class="variable">$year</span> <span class="variable">$1</span>;</span><br><span class="line"><span class="attribute">set</span> <span class="variable">$month</span> <span class="variable">$2</span>;</span><br><span class="line"><span class="attribute">set</span> <span class="variable">$day</span> <span class="variable">$3</span>;</span><br><span class="line"><span class="attribute">set</span> <span class="variable">$hour</span> <span class="variable">$4</span>;</span><br><span class="line"><span class="attribute">set</span> <span class="variable">$minutes</span> <span class="variable">$5</span>;</span><br><span class="line"><span class="attribute">set</span> <span class="variable">$seconds</span> <span class="variable">$6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Ngxin 日志格式化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Nginx提供的访问日志里就蕴藏着大量有用信息。今天这篇要说的就是如果修改Nginx默认日志格式，以便于我们更好的挖掘有效指标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编辑&lt;cod
      
    
    </summary>
    
    
      <category term="Nginx" scheme="https://z201.github.io/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://z201.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Centos7_jenkins部署</title>
    <link href="https://z201.github.io/2021/05/25/Centos7-jenkins%E9%83%A8%E7%BD%B2/"/>
    <id>https://z201.github.io/2021/05/25/Centos7-jenkins%E9%83%A8%E7%BD%B2/</id>
    <published>2021-05-25T13:20:35.000Z</published>
    <updated>2021-07-21T07:12:16.898Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录最近在Centos7上面部署jenkens。安装的方法有很多，下面采用最简单的方式安装。</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>一台服务器，安装好jdk。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk java-1.8.0-openjdk-devel</span><br></pre></td></tr></table></figure><h3 id="安装jenkens"><a href="#安装jenkens" class="headerlink" title="安装jenkens"></a>安装jenkens</h3><blockquote><p>这里采用yum源安装</p></blockquote><h4 id="更新安装jenkens源"><a href="#更新安装jenkens源" class="headerlink" title="更新安装jenkens源"></a>更新安装jenkens源</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum 源导入</span></span><br><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入密钥</span></span><br><span class="line">sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">sudo yum install jenkins</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动下载安装包安装</span></span><br><span class="line">https://pkg.jenkins.io/redhat-stable/ <span class="comment"># 这里面找</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#检查安装</span></span><br><span class="line">whereis jenkins</span><br><span class="line">&gt; jenkins: /usr/lib/jenkins</span><br><span class="line"><span class="comment"># 提示以上内容说明安装成功</span></span><br></pre></td></tr></table></figure><h3 id="修改jenkens配置信息"><a href="#修改jenkens配置信息" class="headerlink" title="修改jenkens配置信息"></a>修改jenkens配置信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑jenkins配置文件</span></span><br><span class="line">vim /etc/sysconfig/jenkins</span><br><span class="line"><span class="comment"># 这里主要编辑两个参数 JENKINS_USER JENKINS_JAVA_OPTIONS</span></span><br><span class="line"><span class="comment"># JENKINS_USER jenkens权限用户</span></span><br><span class="line"><span class="comment"># JENKINS_JAVA_OPTIONS jenkens启动参数，这里主要设置启动内存。</span></span><br><span class="line">JENKINS_USER=<span class="string">"root"</span></span><br><span class="line">JENKINS_JAVA_OPTIONS=<span class="string">"-server -Xms512m -Xmx1024m -XX:PermSize=256m -XX:MaxPermSize=512m  -Djava.awt.headless=true"</span></span><br><span class="line"><span class="comment"># 修改目录权限 如果你不是使用root账号,我偷下懒。</span></span><br><span class="line">chown -R root:root /var/lib/jenkins</span><br><span class="line">chown -R root:root /var/cache/jenkins</span><br><span class="line">chown -R root:root /var/<span class="built_in">log</span>/jenkins</span><br></pre></td></tr></table></figure><h3 id="启动junkets检查"><a href="#启动junkets检查" class="headerlink" title="启动junkets检查"></a>启动junkets检查</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#重载所有修改过的配置文件</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动Jenkins服务</span></span><br><span class="line">sudo systemctl start jenkins</span><br><span class="line"></span><br><span class="line"><span class="comment">#由于Jenkins不是Native Service，所以需要用chkconfig命令而不是systemctl命令</span></span><br><span class="line">sudo /sbin/chkconfig jenkins on</span><br></pre></td></tr></table></figure><h3 id="第一次启动配置"><a href="#第一次启动配置" class="headerlink" title="第一次启动配置"></a>第一次启动配置</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看密码</span></span><br><span class="line">cat /var/lib/jenkins/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure><h3 id="配置jenkens-jdk-maven环境"><a href="#配置jenkens-jdk-maven环境" class="headerlink" title="配置jenkens jdk maven环境"></a>配置jenkens jdk maven环境</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在系统环境中增加</span></span><br><span class="line"><span class="comment"># JAVA_HOME</span></span><br><span class="line"><span class="comment"># MAVEN_HOME </span></span><br><span class="line"><span class="comment"># 如果jdk是通过yum 安装需要通过ll找到jvm的安装地址</span></span><br><span class="line"><span class="comment"># ll /usr/bin/javac -&gt; /etc/alternatives/javac</span></span><br><span class="line"><span class="comment"># ll /etc/alternatives/javac -&gt; /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.292.b10-1.el7_9.x86_64/bin/javac</span></span><br><span class="line"><span class="comment">#举例子</span></span><br><span class="line">JAVA_HOME</span><br><span class="line">/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.292.b10-1.el7_9.x86_64</span><br><span class="line">MAVEN_HOME</span><br><span class="line">/opt/libhome/apache-maven-3.8.1</span><br><span class="line">PATH</span><br><span class="line"><span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$MAVEN_HOME</span>/bin</span><br></pre></td></tr></table></figure><h2 id="配置企业微信通知"><a href="#配置企业微信通知" class="headerlink" title="配置企业微信通知"></a>配置企业微信通知</h2><blockquote><p>安装插件 <a href="https://plugins.jenkins.io/qy-wechat-notification" target="_blank" rel="noopener">Qy Wechat Notification Plugin</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果无法发送通知提示javax.net.ssl.SSLHandshakeException: No appropriate protocol (protocol is disabled or cipher suites are inappropriate</span><br><span class="line">需要修改$JRE&#x2F;lib&#x2F;security&#x2F;java.security</span><br></pre></td></tr></table></figure><ul><li>去掉两个配置信息 <code>TLSv1 TLSv1.1</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdk.tls.disabledAlgorithms&#x3D;SSLv3, TLSv1, RC4, DES, MD5withRSA, DH keySize &lt; 1024, \</span><br><span class="line">EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL</span><br></pre></td></tr></table></figure><h4 id="友情提示"><a href="#友情提示" class="headerlink" title="友情提示"></a>友情提示</h4><blockquote><p>不要选择社区推荐插件安装</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;记录最近在Centos7上面部署jenkens。安装的方法有很多，下面采用最简单的方式安装。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工
      
    
    </summary>
    
    
      <category term="Linux运维" scheme="https://z201.github.io/categories/Linux%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Centos7" scheme="https://z201.github.io/tags/Centos7/"/>
    
      <category term="Jenkins" scheme="https://z201.github.io/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Mysql小炒</title>
    <link href="https://z201.github.io/2021/04/06/Mysql%E5%B0%8F%E7%82%92/"/>
    <id>https://z201.github.io/2021/04/06/Mysql%E5%B0%8F%E7%82%92/</id>
    <published>2021-04-06T01:05:03.000Z</published>
    <updated>2021-04-07T05:40:36.806Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>mysql小炒，记录日常的积累。</p></blockquote><h3 id="Mysql-大小写问题"><a href="#Mysql-大小写问题" class="headerlink" title="Mysql 大小写问题"></a>Mysql 大小写问题</h3><ul><li>表名、表别名、字段名、字段别名都小写。SQL保留字段、函数名、绑定变量名都大写。</li></ul><h3 id="Exists与in"><a href="#Exists与in" class="headerlink" title="Exists与in"></a>Exists与in</h3><ul><li>将设A、B两表，走索引的情况下。根据A、B表的大小比较，如果A表大于B表那么IN的查询效率比EXISTS高。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A WHERE cc IN (SELECT cc FROM B)</span><br><span class="line"></span><br><span class="line">SELECT * FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc&#x3D;A.cc)</span><br></pre></td></tr></table></figure><h3 id="测试环境打开profiling"><a href="#测试环境打开profiling" class="headerlink" title="测试环境打开profiling"></a>测试环境打开profiling</h3><ul><li>首先我们需要看下 profiling 是否开启，开启它可以让 MySQL 收集在 SQL 执行时所使用的资源情况，命令如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@profiling;</span><br><span class="line"># profiling&#x3D;0 代表关闭，我们需要把 profiling 打开，即设置为 1：</span><br><span class="line">mysql&gt; set profiling&#x3D;1;</span><br><span class="line"># 然后我们执行一个 SQL 查询（你可以执行任何一个 SQL 查询）：</span><br><span class="line">mysql&gt; select * from wucai.heros;</span><br></pre></td></tr></table></figure><h3 id="DDL设计数据表的原则"><a href="#DDL设计数据表的原则" class="headerlink" title="DDL设计数据表的原则"></a>DDL设计数据表的原则</h3><ol><li>数据表越少越好</li><li>数据表中的字段越少越好</li><li>数据表中联合主键的字段越少越好</li><li>使用主键和外键越多越好</li></ol><h3 id="去除重复行"><a href="#去除重复行" class="headerlink" title="去除重复行"></a>去除重复行</h3><ol><li>DISTINCT 需要放到所有列名的前面</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这么写会报错</span><br><span class="line">SELECT name, DISTINCT age FROM us</span><br></pre></td></tr></table></figure><ol start="2"><li>DISTINCT 其实是对后面所有列名的组合进行去重。</li></ol><h3 id="ORDER-BY-子句有以下几个点需要掌握"><a href="#ORDER-BY-子句有以下几个点需要掌握" class="headerlink" title="ORDER BY 子句有以下几个点需要掌握"></a>ORDER BY 子句有以下几个点需要掌握</h3><ol><li>排序的列名：ORDER BY 后面可以有一个或多个列名，如果是多个列名进行排序，会按照后面第一个列先进行排序，当第一列的值相同的时候，再按照第二列进行排序，以此类推。</li><li>排序的顺序：ORDER BY 后面可以注明排序规则，ASC 代表递增排序，DESC 代表递减排序。如果没有注明排序规则，默认情况下是按照 ASC 递增排序。我们很容易理解 ORDER BY 对数值类型字段的排序规则，但如果排序字段类型为文本数据，就需要参考数据库的设置方式了，这样才能判断 A 是在 B 之前，还是在 B 之后。比如使用 MySQL 在创建字段的时候设置为 BINARY 属性，就代表区分大小写。</li><li>非选择列排序：ORDER BY 可以使用非选择列进行排序，所以即使在 SELECT 后面没有这个列名，你同样可以放到 ORDER BY 后面进行排序。</li><li>ORDER BY 的位置：ORDER BY 通常位于 SELECT 语句的最后一条子句，否则会报错。</li></ol><h3 id="SELECT-的执行顺序"><a href="#SELECT-的执行顺序" class="headerlink" title="SELECT 的执行顺序"></a>SELECT 的执行顺序</h3><ol><li>关键字的顺序</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ...</span><br></pre></td></tr></table></figure><ol start="2"><li>.SELECT 语句的执行顺序（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &gt; WHERE &gt; GROUP BY &gt; HAVING &gt; SELECT的字段 &gt; DISTINCT &gt; ORDER BY &gt; LIMIT</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="Too-many-connections"><a href="#Too-many-connections" class="headerlink" title="Too many connections"></a>Too many connections</h3><blockquote><p>连接数超出 Mysql 的最大连接限制</p></blockquote><ul><li><p>解决方法：</p></li><li><ul><li>1、在 my.cnf 配置文件里面增加连接数，然后重启 MySQL 服务。max_connections = 10000</li><li>2、临时修改最大连接数，重启后不生效。需要在 my.cnf 里面修改配置文件，下次重启生效。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;mysql小炒，记录日常的积累。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Mysql-大小写问题&quot;&gt;&lt;a href=&quot;#Mysql-大小写问题&quot; class=&quot;headerlink&quot; title=&quot;Mysql 大小写问题&quot;&gt;&lt;/a&gt;Mysql 大小写问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;表名、表别名、字段名、字段别名都小写。SQL保留字段、函数名、绑定变量名都大写。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Exists与in&quot;&gt;&lt;a href=&quot;#Exists与in&quot; class=&quot;headerlink&quot; title=&quot;Exists与in&quot;&gt;&lt;/a&gt;Exists与in&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;将设A、B两表，走索引的情况下。根据A、B表的大小比较，如果A表大于B表那么IN的查询效率比EXISTS高。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SELECT * FROM A WHERE cc IN (SELECT cc FROM B)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SELECT * FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc&amp;#x3D;A.cc)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;测试环境打开profiling&quot;&gt;&lt;a href=&quot;#测试环境打开profiling&quot; class=&quot;headerlink&quot; title=&quot;测试环境打开profiling&quot;&gt;&lt;/a&gt;测试环境打开profiling&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;首先我们需要看下 profiling 是否开启，开启它可以让 MySQL 收集在 SQL 执行时所使用的资源情况，命令如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mysql&amp;gt; select @@profiling;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# profiling&amp;#x3D;0 代表关闭，我们需要把 profiling 打开，即设置为 1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql&amp;gt; set profiling&amp;#x3D;1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 然后我们执行一个 SQL 查询（你可以执行任何一个 SQL 查询）：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mysql&amp;gt; select * from wucai.heros;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;DDL设计数据表的原则&quot;&gt;&lt;a href=&quot;#DDL设计数据表的原则&quot; class=&quot;headerlink&quot; title=&quot;DDL设计数据表的原则&quot;&gt;&lt;/a&gt;DDL设计数据表的原则&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;数据表越少越好&lt;/li&gt;
&lt;li&gt;数据表中的字段越少越好&lt;/li&gt;
&lt;li&gt;数据表中联合主键的字段越少越好&lt;/li&gt;
&lt;li&gt;使用主键和外键越多越好&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;去除重复行&quot;&gt;&lt;a href=&quot;#去除重复行&quot; class=&quot;headerlink&quot; title=&quot;去除重复行&quot;&gt;&lt;/a&gt;去除重复行&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;DISTINCT 需要放到所有列名的前面&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# 这么写会报错&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SELECT name, DISTINCT age FROM us&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;DISTINCT 其实是对后面所有列名的组合进行去重。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;ORDER-BY-子句有以下几个点需要掌握&quot;&gt;&lt;a href=&quot;#ORDER-BY-子句有以下几个点需要掌握&quot; class=&quot;headerlink&quot; title=&quot;ORDER BY 子句有以下几个点需要掌握&quot;&gt;&lt;/a&gt;ORDER BY 子句有以下几个点需要掌握&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;排序的列名：ORDER BY 后面可以有一个或多个列名，如果是多个列名进行排序，会按照后面第一个列先进行排序，当第一列的值相同的时候，再按照第二列进行排序，以此类推。&lt;/li&gt;
&lt;li&gt;排序的顺序：ORDER BY 后面可以注明排序规则，ASC 代表递增排序，DESC 代表递减排序。如果没有注明排序规则，默认情况下是按照 ASC 递增排序。我们很容易理解 ORDER BY 对数值类型字段的排序规则，但如果排序字段类型为文本数据，就需要参考数据库的设置方式了，这样才能判断 A 是在 B 之前，还是在 B 之后。比如使用 MySQL 在创建字段的时候设置为 BINARY 属性，就代表区分大小写。&lt;/li&gt;
&lt;li&gt;非选择列排序：ORDER BY 可以使用非选择列进行排序，所以即使在 SELECT 后面没有这个列名，你同样可以放到 ORDER BY 后面进行排序。&lt;/li&gt;
&lt;li&gt;ORDER BY 的位置：ORDER BY 通常位于 SELECT 语句的最后一条子句，否则会报错。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;SELECT-的执行顺序&quot;&gt;&lt;a href=&quot;#SELECT-的执行顺序&quot; class=&quot;headerlink&quot; title=&quot;SELECT 的执行顺序&quot;&gt;&lt;/a&gt;SELECT 的执行顺序&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;关键字的顺序&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;.SELECT 语句的执行顺序（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FROM &amp;gt; WHERE &amp;gt; GROUP BY &amp;gt; HAVING &amp;gt; SELECT的字段 &amp;gt; DISTINCT &amp;gt; ORDER BY &amp;gt; LIMIT&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Mysql" scheme="https://z201.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mac安装neo4j和jupyter</title>
    <link href="https://z201.github.io/2021/02/19/Mac%E5%AE%89%E8%A3%85neo4j%E5%92%8Cjupyter/"/>
    <id>https://z201.github.io/2021/02/19/Mac%E5%AE%89%E8%A3%85neo4j%E5%92%8Cjupyter/</id>
    <published>2021-02-18T16:39:21.000Z</published>
    <updated>2021-02-18T16:45:34.018Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>准备学习下neo4j记录在mac下安装neo4j的坑。</p></blockquote><h2 id="neo4j官网网站下载失败"><a href="#neo4j官网网站下载失败" class="headerlink" title="neo4j官网网站下载失败"></a>neo4j官网网站下载失败</h2><blockquote><p>国内只能从镜像地址下载</p></blockquote><p><a href="http://doc.we-yun.com:1008/" target="_blank" rel="noopener">http://doc.we-yun.com:1008/</a> </p><h2 id="配置jdk11"><a href="#配置jdk11" class="headerlink" title="配置jdk11"></a>配置jdk11</h2><blockquote><p>可以查看我上面内容实用Jenv管理多个版本。</p></blockquote><h2 id="启动neo4j"><a href="#启动neo4j" class="headerlink" title="启动neo4j"></a>启动neo4j</h2><blockquote><p>下载完成后解压</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">./neo4j  start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭</span></span><br><span class="line">./neo4j  stop</span><br></pre></td></tr></table></figure><h2 id="neo4j界面"><a href="#neo4j界面" class="headerlink" title="neo4j界面"></a>neo4j界面</h2><ul><li>在浏览器中输入localhost:7474</li><li>初始用户名、密码均为neo4j， 第一次登录需要修改密码</li></ul><h2 id="安装jupyter"><a href="#安装jupyter" class="headerlink" title="安装jupyter"></a>安装jupyter</h2><blockquote><p>注意提前安装python环境</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter notebook -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host=mirrors.aliyun.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查版本</span></span><br><span class="line">jupyter --version</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;准备学习下neo4j记录在mac下安装neo4j的坑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;neo4j官网网站下载失败&quot;&gt;&lt;a href=&quot;#neo4j官网网站下载失败&quot; class=&quot;headerlink&quot; title=&quot;neo4
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Neo4j" scheme="https://z201.github.io/tags/Neo4j/"/>
    
      <category term="Jupiter" scheme="https://z201.github.io/tags/Jupiter/"/>
    
  </entry>
  
  <entry>
    <title>Mac下OpenJdk11-JavaFx开发环境配置</title>
    <link href="https://z201.github.io/2021/02/15/Mac%E4%B8%8BOpenJdk11-JavaFx%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://z201.github.io/2021/02/15/Mac%E4%B8%8BOpenJdk11-JavaFx%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2021-02-14T19:12:07.000Z</published>
    <updated>2021-09-19T12:29:55.906Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>OpenJdk 11 环境下JavaFx开发环境设置</p></blockquote><ul><li><a href="https://www.coder.work/article/884639" target="_blank" rel="noopener">https://www.coder.work/article/884639</a></li><li><a href="https://stackoverflow.com/questions/54291958/javafx-11-illegalaccesserror-when-creating-label" target="_blank" rel="noopener">https://stackoverflow.com/questions/54291958/javafx-11-illegalaccesserror-when-creating-label</a></li><li><a href="https://gluonhq.com/products/javafx/" target="_blank" rel="noopener">https://gluonhq.com/products/javafx/</a></li></ul><h2 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjfx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javafx-controls<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjfx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javafx-fxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="idea设置"><a href="#idea设置" class="headerlink" title="idea设置"></a>idea设置</h3><blockquote><p>下载javafx版本，然后引入依赖。项目lib中引入。启动的时候在vm中添加启动参数</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--module-path</span><br><span class="line"><span class="meta">/Users/$</span><span class="bash">USER/word/libhome/javafx-sdk-11.0.2/lib</span></span><br><span class="line">--add-modules</span><br><span class="line">javafx.controls</span><br><span class="line">--add-modules</span><br><span class="line">javafx.base</span><br><span class="line">--add-modules</span><br><span class="line">javafx.graphics</span><br><span class="line">--add-modules</span><br><span class="line">javafx.fxml</span><br><span class="line">--add-modules</span><br><span class="line">javafx.media</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;OpenJdk 11 环境下JavaFx开发环境设置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.coder.work/article/884639&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="openJdk11" scheme="https://z201.github.io/tags/openJdk11/"/>
    
  </entry>
  
  <entry>
    <title>Mac使用Jenv管理多版本Jdk</title>
    <link href="https://z201.github.io/2021/02/15/Mac%E4%BD%BF%E7%94%A8Jenv%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%ACJdk/"/>
    <id>https://z201.github.io/2021/02/15/Mac%E4%BD%BF%E7%94%A8Jenv%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%ACJdk/</id>
    <published>2021-02-14T17:09:36.000Z</published>
    <updated>2021-09-19T12:29:50.971Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单记录下mac下多版本jdk管理 </p></blockquote><ul><li><a href="https://adoptopenjdk.net/" target="_blank" rel="noopener">https://adoptopenjdk.net/</a></li><li><a href="https://www.jianshu.com/p/1a147d5515f0" target="_blank" rel="noopener">https://www.jianshu.com/p/1a147d5515f0</a></li></ul><h2 id="检查环境"><a href="#检查环境" class="headerlink" title="检查环境"></a>检查环境</h2><h3 id="查看当前安装的jdk版本"><a href="#查看当前安装的jdk版本" class="headerlink" title="查看当前安装的jdk版本"></a>查看当前安装的jdk版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/java_home -V</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果有安装过jdk版本这里会输出信息</span></span><br></pre></td></tr></table></figure><h3 id="使用brew-安装jenv"><a href="#使用brew-安装jenv" class="headerlink" title="使用brew 安装jenv"></a>使用brew 安装jenv</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew install jenv</span><br><span class="line"><span class="meta">#</span><span class="bash">检查</span></span><br><span class="line">jenv doctor </span><br><span class="line"><span class="meta">#</span><span class="bash"> 刚安装会提示很多信息</span></span><br></pre></td></tr></table></figure><h3 id="初始化jenv"><a href="#初始化jenv" class="headerlink" title="初始化jenv"></a>初始化jenv</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install jenv</span><br><span class="line">jenv init -</span><br><span class="line">echo 'eval "$(jenv init -)"' &gt;&gt; ~/.bash_profile</span><br><span class="line">echo 'eval "$(jenv init -)"' &gt;&gt; ~/.zprofile</span><br><span class="line">jenv add &lt;path-to-java8-Home-Dir&gt; # 这里从/usr/libexec/java_home -V 获取javaHome</span><br></pre></td></tr></table></figure><h3 id="切换jdk"><a href="#切换jdk" class="headerlink" title="切换jdk"></a>切换jdk</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ jenv versions</span><br><span class="line">* system (set by /Users/zengqingfeng/.jenv/version)</span><br><span class="line">  1.8</span><br><span class="line">  1.8.0.275</span><br><span class="line">  openjdk64-1.8.0.275</span><br><span class="line">  </span><br><span class="line">➜  ~ jenv local system # 切换版本</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;简单记录下mac下多版本jdk管理 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://adoptopenjdk.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ado
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="openJdk11" scheme="https://z201.github.io/tags/openJdk11/"/>
    
      <category term="jenv" scheme="https://z201.github.io/tags/jenv/"/>
    
  </entry>
  
  <entry>
    <title>Docker-Compose-Redis5.0+Mysql5.7</title>
    <link href="https://z201.github.io/2020/11/20/Docker-Compose-Redis5-0-Mysql5-7/"/>
    <id>https://z201.github.io/2020/11/20/Docker-Compose-Redis5-0-Mysql5-7/</id>
    <published>2020-11-20T07:58:13.000Z</published>
    <updated>2021-01-13T06:46:29.352Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录下使用docker-compose构建管理Redis、mysql。</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>创建工作目录</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p docker docker/mysql docker/mysql/data docker/redis docker/redis/data</span><br><span class="line"><span class="comment"># 使用 tree docker 查看目录结构 yum -y install tree 安装</span></span><br><span class="line">$ tree docker</span><br><span class="line">docker</span><br><span class="line">├── mysql</span><br><span class="line">│   └── data</span><br><span class="line">└── redis</span><br><span class="line">    └── data</span><br><span class="line">$ touch docker/mysql/my.cnf docker/redis/redis.conf </span><br><span class="line">$ tree docker</span><br><span class="line">docker</span><br><span class="line">├── mysql</span><br><span class="line">│   ├── data</span><br><span class="line">│   └── my.cnf</span><br><span class="line">└── redis</span><br><span class="line">    ├── data</span><br><span class="line">    └── redis.conf</span><br></pre></td></tr></table></figure><ol start="2"><li>准备my.conf 、redis.conf<ol><li>my.conf</li></ol></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line"> port = 3306</span><br><span class="line"> socket = /var/lib/mysql/data/mysql.sock</span><br><span class="line">[mysqld]</span><br><span class="line"> <span class="comment"># 针对5.7版本执行group by字句出错问题解决</span></span><br><span class="line">sql_mode=<span class="string">'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'</span></span><br><span class="line"> <span class="comment"># 一般配置选项</span></span><br><span class="line"> basedir = /var/lib/mysql</span><br><span class="line"> datadir = /var/lib/mysql/data</span><br><span class="line"> port = 3306</span><br><span class="line"> socket = /var/lib/mysql/data/mysql.sock</span><br><span class="line"> lc-messages-dir = /usr/share/mysql <span class="comment"># 务必配置此项，否则执行sql出错时，只能显示错误代码而不显示具体错误消息</span></span><br><span class="line"> character-set-server=utf8</span><br><span class="line"> back_log = 300</span><br><span class="line"> max_connections = 3000</span><br><span class="line"> max_connect_errors = 50</span><br><span class="line"> table_open_cache = 4096</span><br><span class="line"> max_allowed_packet = 32M</span><br><span class="line"> <span class="comment">#binlog_cache_size = 4M</span></span><br><span class="line"> max_heap_table_size = 128M</span><br><span class="line"> read_rnd_buffer_size = 16M</span><br><span class="line"> sort_buffer_size = 16M</span><br><span class="line"> join_buffer_size = 16M</span><br><span class="line"> thread_cache_size = 16</span><br><span class="line"> query_cache_size = 64M</span><br><span class="line"> query_cache_limit = 4M</span><br><span class="line"> ft_min_word_len = 8</span><br><span class="line"> thread_stack = 512K</span><br><span class="line"> transaction_isolation = REPEATABLE-READ</span><br><span class="line"> tmp_table_size = 64M</span><br><span class="line"> <span class="comment">#log-bin=mysql-bin</span></span><br><span class="line"> long_query_time = 6</span><br><span class="line"> server_id=1</span><br><span class="line"> innodb_buffer_pool_size = 256M</span><br><span class="line"> innodb_thread_concurrency = 16</span><br><span class="line"> innodb_log_buffer_size = 16M</span><br></pre></td></tr></table></figure><ol start="2"><li>redis.conf 可以去这里下载 <a href="https://redis.io/topics/config" target="_blank" rel="noopener">官网</a></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/redis/redis/5.0/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改内容</span></span><br><span class="line">daemonize no     <span class="comment">## 若使用开机启动，生成pid，该项必须设置为诶yes，否则redis将不能够正常执行开机启动(systemctl start redis,执行后一直卡着，直到超时)</span></span><br><span class="line"><span class="comment">#bind 127.0.0.1  ##注释掉，允许所有其他ip访问，真实使用最好坐下限制，只允许某些主机访问</span></span><br><span class="line">protected-mode no  <span class="comment">## 允许其他机器上的客户端连接当前redis，配置文件设置该项，则开机启动处就可以去掉--protected no </span></span><br><span class="line">requirepass root  <span class="comment">##设置密码</span></span><br><span class="line"><span class="comment"># daemonize yes，他的作用是开启守护进程模式，在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。但是在后面的命令中“-d”选项也是开启daemonize，这是docker自家的方式。</span></span><br></pre></td></tr></table></figure><h2 id="编写Docker-Compose文件"><a href="#编写Docker-Compose文件" class="headerlink" title="编写Docker-Compose文件"></a>编写Docker-Compose文件</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">version : <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql/mysql-server:<span class="number">5.7</span>.<span class="number">18</span></span><br><span class="line">    container_name: mysql5.<span class="number">7.18</span>-dev</span><br><span class="line">    networks:</span><br><span class="line">      - net-shop-db</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"3306:3306"</span></span><br><span class="line">    volumes:</span><br><span class="line">      - /opt/docker/mysql/my.cnf:/etc/my.cnf <span class="comment"># 映射数据库配置文件</span></span><br><span class="line">      - /opt/docker/mysql/data:/var/lib/mysql/data  <span class="comment"># 映射数据库保存目录到宿主机，防止数据丢失</span></span><br><span class="line">      - /opt/docker/mysql/log:/var/log/mysql <span class="comment"># 日志文件</span></span><br><span class="line">      - /etc/localtime:/etc/localtime:ro <span class="comment"># 设置容器时区与宿主机保持一致</span></span><br><span class="line">    restart: always <span class="comment"># 设置容器自启模式</span></span><br><span class="line">    command: [</span><br><span class="line">      <span class="string">'--character-set-server=utf8mb4'</span>,</span><br><span class="line">      <span class="string">'--collation-server=utf8mb4_unicode_ci'</span>,</span><br><span class="line">      <span class="string">'--lower_case_table_names=1'</span>,</span><br><span class="line">      <span class="string">'--default-time-zone=+8:00'</span>]</span><br><span class="line">    environment:</span><br><span class="line">      - TZ=Asia/Shanghai <span class="comment"># 设置容器时区与宿主机保持一致</span></span><br><span class="line">      - MYSQL_ROOT_PASSWORD=root <span class="comment"># 设置root密码</span></span><br><span class="line">  redis:</span><br><span class="line">    image: redis:<span class="number">5.0</span>.<span class="number">5</span></span><br><span class="line">    container_name: redis5.<span class="number">0.6</span>-dev</span><br><span class="line">    networks:</span><br><span class="line">      - net-shop-db</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"6379:6379"</span></span><br><span class="line">    volumes:</span><br><span class="line">      - /etc/localtime:/etc/localtime:ro <span class="comment"># 设置容器时区与宿主机保持一致</span></span><br><span class="line">      - /opt/docker/redis/data:/data</span><br><span class="line">      - /opt/docker/redis/redis.conf:/etc/redis.conf</span><br><span class="line">    command: redis-server /etc/redis.conf <span class="comment"># 启动redis命令</span></span><br><span class="line">    environment:</span><br><span class="line">      - TZ=Asia/Shanghai <span class="comment"># 设置容器时区与宿主机保持一致</span></span><br><span class="line">    restart: always <span class="comment"># 设置容器自启模式</span></span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  net-shop-db:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><blockquote><p>注意需要提前启动docker</p></blockquote><ol><li>创建并启动容器 <code>docker-compose -f docker-compose.yml up -d</code></li><li>批量停止容器并清除容器 <code>docker-compose -f docker-compose.yml down</code></li><li>重新构建容器 <code>docker-compose -f docker-compose.yml up --build -d</code></li><li>启动失败，可以查看容器日志信息获取帮助 <code>docker logs 容器名词或容器ID # 既docker-compose.yml文件参数container_name指定的值</code></li></ol><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ol><li>docker-compose 命令不存在、未找到命令。直接从github上下载，国内下载巨慢。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意查看docker 版本 和 docker-compose 的版本</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"></span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.27.4/docker-compose-`uname -s`-`uname -m` -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment">#。直接用国内的镜像</span></span><br><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.27.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yefeihonours.github.io/post/docker/docker_compose/" target="_blank" rel="noopener">docker-compose 命令不存在、未找到命令</a></p><p><a href="https://zhuanlan.zhihu.com/p/43654441" target="_blank" rel="noopener">使用 docker-compose 在 Docker 中启动有密码的 Redis 容器</a></p><p><a href="https://cloud.tencent.com/developer/article/1678769" target="_blank" rel="noopener">Docker-Compose搭建mysql、redis、zookeeper、rabbitmq、consul、elasticsearch环境</a></p><p><a href="https://juejin.cn/post/6844903655389265927" target="_blank" rel="noopener">Docker Compose多容器部署</a></p><p><a href="https://colobu.com/2018/05/15/Stop-and-remove-all-docker-containers-and-images/" target="_blank" rel="noopener">停止、删除所有的docker容器和镜像</a></p><p><a href="https://my.oschina.net/u/4362704/blog/3308004" target="_blank" rel="noopener">宿主机连接docker中的mysql</a></p><p><a href="https://developer.aliyun.com/article/618035" target="_blank" rel="noopener">Docker Compose 安装 on centos7</a></p><p><a href="https://cloud.tencent.com/developer/article/1678769" target="_blank" rel="noopener">Docker-Compose搭建mysql、redis、zookeeper、rabbitmq、consul、elasticsearch环境</a></p><p><a href="https://zhuanlan.zhihu.com/p/140732202" target="_blank" rel="noopener">docker-compose一键安装redis+mysql+rabbitmq</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;记录下使用docker-compose构建管理Redis、mysql。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://z201.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://z201.github.io/tags/Docker/"/>
    
      <category term="Redis" scheme="https://z201.github.io/tags/Redis/"/>
    
      <category term="Mysql" scheme="https://z201.github.io/tags/Mysql/"/>
    
      <category term="Docker-Compose" scheme="https://z201.github.io/tags/Docker-Compose/"/>
    
  </entry>
  
  <entry>
    <title>Centos7.*-Docker部署</title>
    <link href="https://z201.github.io/2020/11/20/Centos7-Docker%E9%83%A8%E7%BD%B2/"/>
    <id>https://z201.github.io/2020/11/20/Centos7-Docker%E9%83%A8%E7%BD%B2/</id>
    <published>2020-11-20T06:26:04.000Z</published>
    <updated>2021-01-12T07:16:48.615Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录下自己在阿里云部署docker记录。</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>准备一台ESC服务器，并可以使用控制台登录。</li><li>检查ESC是否安装了docker，可以选择是否卸载重装。<ol><li>检查docker是否安装,<code>docker 显示相关信息则表示安装</code></li><li>卸载docker，若不重装直接忽略，<code>yum list installed | grep docker</code>查看安装内容</li></ol></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ yum list installed | grep docker</span><br><span class="line">containerd.io.x86_64                1.3.7-3.1.el7                   @docker-ce-stable</span><br><span class="line">docker-ce.x86_64                    3:19.03.13-3.el7                @docker-ce-stable</span><br><span class="line">docker-ce-cli.x86_64                1:19.03.13-3.el7                @docker-ce-stable</span><br><span class="line"><span class="comment"># 依次卸载</span></span><br><span class="line">$ yum -y remove docker-ce.x86_64</span><br><span class="line">$ yum -y remove docker-ce-cli.x86_64</span><br><span class="line">$ yum -y remove containerd.io.x86_64</span><br><span class="line"><span class="comment"># 检查卸载结果</span></span><br><span class="line">$ yum list installed | grep docker</span><br><span class="line"><span class="comment"># 无输出内容</span></span><br><span class="line">$ docker </span><br><span class="line"><span class="comment"># -bash: docekr: 未找到命令 则表示卸载干净了</span></span><br></pre></td></tr></table></figure><ol start="3"><li>安装docker<ol><li>更新yum <code>yum update</code></li><li>获取官方源<code>wget -P /etc/yum.repos.d/ https://download.docker.com/linux/centos/docker-ce.repo</code></li><li>查看可以安装的版本<code>yum list docker-ce --showduplicates | sort -r</code></li><li>选择安装 <code>yum install -y docker-ce-18.03.0.ce-1.el7.centos</code></li><li>安装docker <code>yum install docker -y</code><ol><li>检查<code>docker -v</code>输出版本信息</li></ol></li></ol></li></ol><h2 id="设置docker相关信息"><a href="#设置docker相关信息" class="headerlink" title="设置docker相关信息"></a>设置docker相关信息</h2><ol><li>设置docker开机启动项<code>systemctl enable docker.service</code></li><li>关闭docker开机启动项 <code>systemctl stop docker.service</code></li><li>检查docker当前运行情况 <code>systemctl status docker</code></li><li>若未启动则启动docker <code>systemctl start docker</code> ,若启动了可以重启<code>systemctl restart docker</code></li><li>检查docker运行情况<code>service docker status</code></li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.aliyun.com/article/336442" target="_blank" rel="noopener">阿里云CentOS 7上安装配置Docker</a></p><p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-compose-on-centos-7" target="_blank" rel="noopener">How To Install and Use Docker Compose on CentOS 7</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;记录下自己在阿里云部署docker记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;准
      
    
    </summary>
    
    
      <category term="Linux运维" scheme="https://z201.github.io/categories/Linux%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Centos7" scheme="https://z201.github.io/tags/Centos7/"/>
    
      <category term="Linux" scheme="https://z201.github.io/tags/Linux/"/>
    
      <category term="Docker" scheme="https://z201.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>实践-centos7搭建selenium-java运行环境</title>
    <link href="https://z201.github.io/2020/08/31/%E5%AE%9E%E8%B7%B5-centos7%E6%90%AD%E5%BB%BAselenium-java%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
    <id>https://z201.github.io/2020/08/31/%E5%AE%9E%E8%B7%B5-centos7%E6%90%AD%E5%BB%BAselenium-java%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</id>
    <published>2020-08-31T01:45:59.000Z</published>
    <updated>2020-10-27T08:31:58.324Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在编写爬虫程序，这里简单的做下笔记。</p></blockquote><h3 id="阅读注意事项"><a href="#阅读注意事项" class="headerlink" title="阅读注意事项"></a>阅读注意事项</h3><ol><li>需要一台服务器(阿里ESC)这种，分配的公网ip。</li><li>这里使用的yum安装，所以环境配置都创建好了，不需要在手动修改。</li></ol><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><blockquote><p>安装Java、maven、git、selenium运行环境</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用的机器是centos7.4</span></span><br><span class="line"><span class="comment"># 系统环境一个一个来安装。</span></span><br><span class="line"><span class="comment"># 1.检查是否安装jdk</span></span><br><span class="line">-&gt; yum install java-1.8.0-openjdk-devel.x86_64</span><br><span class="line">-&gt; java -version</span><br><span class="line">openjdk version <span class="string">"1.8.0_262"</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_262-b10)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.262-b10, mixed mode)</span><br><span class="line">-&gt; yum install maven</span><br><span class="line">-&gt; mvn -version</span><br><span class="line">Java version: 1.8.0_262, vendor: Oracle Corporation</span><br><span class="line">Java home: /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.262.b10-0.el7_8.x86_64/jre</span><br><span class="line">Default locale: zh_CN, platform encoding: UTF-8</span><br><span class="line">OS name: <span class="string">"linux"</span>, version: <span class="string">"3.10.0-862.el7.x86_64"</span>, arch: <span class="string">"amd64"</span>, family: <span class="string">"unix"</span></span><br><span class="line">-&gt; yum install git</span><br><span class="line">git version 1.8.3.1</span><br><span class="line"><span class="comment"># 查看是否生成过证书</span></span><br><span class="line">-&gt; ls -al ~/.ssh</span><br><span class="line"><span class="comment"># 这里配置下ssh公钥方便git拉去代码</span></span><br><span class="line">-&gt; ssh-keygen -t rsa -C “you email@gamil.com”</span><br><span class="line"><span class="comment"># 查看证书</span></span><br><span class="line">-&gt; cat ~/.ssh/id_rsa.pub</span><br><span class="line"><span class="comment"># 开始配置 selenium 运行环境</span></span><br><span class="line">-&gt; wget https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm</span><br><span class="line">-&gt; yum localinstall google-chrome-stable_current_x86_64.rpm</span><br><span class="line"><span class="comment"># 检查版本 </span></span><br><span class="line">-&gt; google-chrome --version </span><br><span class="line">Google Chrome 85.0.4183.83 </span><br><span class="line"><span class="comment"># 安装 chromedriver</span></span><br><span class="line">-&gt; yum install chromedriver</span><br><span class="line">-&gt; chromedriver -version</span><br><span class="line">ChromeDriver 84.0.4147.89 </span><br><span class="line"><span class="comment"># 这里注意 chromedriver 可能与chrome的版本不一致，去官方网站下载后解压复制到/usr/bin中</span></span><br><span class="line"><span class="comment"># 下载地址 https://chromedriver.chromium.org/</span></span><br></pre></td></tr></table></figure><ul><li>注意 google-chrome 和 chromedriver版本是需要对应的具体可以到官方查看。</li><li>在centos上运行需要配置下关键参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ChromeOptions chromeOptions = <span class="keyword">new</span> ChromeOptions();</span><br><span class="line">   chromeOptions.addArguments(<span class="string">"--headless"</span>);</span><br><span class="line">   chromeOptions.addArguments(<span class="string">"--disable-gpu"</span>); <span class="comment">// 不配置一定报错</span></span><br><span class="line">   chromeOptions.addArguments(<span class="string">"--no-sandbox"</span>);</span><br><span class="line">   <span class="comment">// 创建无界面浏览器对象</span></span><br><span class="line">   chromeOptions.setHeadless(<span class="keyword">true</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ChromeDriver(chromeOptions);</span><br></pre></td></tr></table></figure><ul><li>启动代码的需要指定环境变量</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">"webdriver.chrome.chromedriver"</span>, <span class="string">"/usr/bin/chromedriver"</span>);</span><br><span class="line"># 具体可以通过 whereis chromedriver查看。</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://segmentfault.com/a/1190000015389941" target="_blank" rel="noopener">CentOS使用yum安装jdk</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在编写爬虫程序，这里简单的做下笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;阅读注意事项&quot;&gt;&lt;a href=&quot;#阅读注意事项&quot; class=&quot;headerlink&quot; title=&quot;阅读注意事项&quot;&gt;&lt;/a&gt;阅读注意事项&lt;/h3&gt;&lt;o
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="selenium" scheme="https://z201.github.io/tags/selenium/"/>
    
      <category term="爬虫" scheme="https://z201.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>实践-nginx配置https</title>
    <link href="https://z201.github.io/2020/08/26/%E5%AE%9E%E8%B7%B5-nginx%E9%85%8D%E7%BD%AEhttps/"/>
    <id>https://z201.github.io/2020/08/26/%E5%AE%9E%E8%B7%B5-nginx%E9%85%8D%E7%BD%AEhttps/</id>
    <published>2020-08-26T13:42:22.000Z</published>
    <updated>2020-11-23T07:32:24.462Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在搭建测试环境，很久没接触nginx了。</p></blockquote><h3 id="阅读注意事项"><a href="#阅读注意事项" class="headerlink" title="阅读注意事项"></a>阅读注意事项</h3><ol><li>需要一个域名，并且在国内备案过。</li><li>需要一台服务器(阿里ESC)这种，分配的公网ip。</li><li>申请或者购买一张证书。和域名做关联，域名解析到服务器的公网ip。注意开放服务区的80、443端口。<ol><li>证书有两个文件<ol><li><code>domian.name.key domain.name.pem</code></li></ol></li><li>吧证书上传到目标nginx服务器中。</li><li>检查服务器防火墙</li></ol></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --zone=public --add-service=http</span><br><span class="line">sudo firewall-cmd --permanent --zone=public --add-service=https</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="开始步骤"><a href="#开始步骤" class="headerlink" title="开始步骤"></a>开始步骤</h3><h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><blockquote><p>服务器使用的Centos服务器 使用yum安装nginx。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-&gt; yum install -y nginx</span><br><span class="line"><span class="comment">#检查nginx安装位置信息</span></span><br><span class="line">-&gt; whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib64/nginx /etc/nginx /usr/share/nginx /usr/share/man/man3/nginx.3pm.gz /usr/share/man/man8/nginx.8.gz</span><br><span class="line"><span class="comment"># 实际上是安装到/etc/nginx里面了</span></span><br><span class="line"><span class="comment"># 设置开机自动启动nginx</span></span><br><span class="line">-&gt; sudo systemctl <span class="built_in">enable</span> nginx</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/nginx.service to /usr/lib/systemd/system/nginx.service.</span><br><span class="line"><span class="comment"># 切换到nginx安装目录</span></span><br><span class="line">-&gt; <span class="built_in">cd</span> /etc/nginx</span><br><span class="line"><span class="comment"># 启动nginx</span></span><br><span class="line">-&gt; nginx</span><br><span class="line"><span class="comment"># 测试nginx 在浏览器里面请求http://ip 就可以了看到nginx页面就算安装成功</span></span><br></pre></td></tr></table></figure><h4 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建证书文件并且将证书复制近文件中</span></span><br><span class="line">-&gt; <span class="built_in">cd</span> /etc/nginx</span><br><span class="line">-&gt; mkdir cert</span><br><span class="line">-&gt; mv domian.name.key /etc/nginx/cert/</span><br><span class="line">-&gt; mv domian.name.pem /etc/nginx/cert/</span><br><span class="line"><span class="comment"># 配置nginx.conf文件使证书生效，并将80端口转发到443端口上。</span></span><br><span class="line">-&gt; vim nginx.conf</span><br><span class="line"><span class="comment">#以下属性中以ssl开头的属性代表与证书配置有关，其他属性请根据自己的需要进行配置。</span></span><br><span class="line">server &#123;</span><br><span class="line">         listen 443; <span class="comment">#配置HTTPS的默认访问端口号为443。此处如果未配置HTTPS的默认访问端口，可能会造成Nginx无法启动。Nginx 1.15.0以上版本请使用listen 443 ssl代替listen 443和ssl on。</span></span><br><span class="line">         server_name www.certificatestests.com; <span class="comment">#将www.certificatestests.com修改为您证书绑定的域名，例如：www.example.com。如果您购买的是通配符域名证书，要修改为通配符域名，例如：*.aliyun.com。</span></span><br><span class="line">         root html;</span><br><span class="line">         index index.html index.htm;</span><br><span class="line">         ssl_certificate cert/domain name.pem;  <span class="comment">#将domain name.pem替换成您证书的文件名称。</span></span><br><span class="line">         ssl_certificate_key cert/domain name.key; <span class="comment">#将domain name.key替换成您证书的密钥文件名称。</span></span><br><span class="line">         ssl_session_timeout 5m;</span><br><span class="line">         ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; <span class="comment">#使用此加密套件。</span></span><br><span class="line">         ssl_protocols TLSv1 TLSv1.1 TLSv1.2; <span class="comment">#使用该协议进行配置。</span></span><br><span class="line">         ssl_prefer_server_ciphers on;</span><br><span class="line">         location / &#123;</span><br><span class="line">         root html;  <span class="comment">#站点目录。</span></span><br><span class="line">         index index.html index.htm;</span><br><span class="line">                    &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"><span class="comment">#        listen       80 default_server;</span></span><br><span class="line"><span class="comment">#        listen       [::]:80 default_server;</span></span><br><span class="line"><span class="comment">#        server_name  _;</span></span><br><span class="line">        listen 80;</span><br><span class="line">        listen [::]:80;</span><br><span class="line">        server_name www.certificatestests.com;</span><br><span class="line">        <span class="built_in">return</span> 301 https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment"># 保存并推出、检查配置nginx配置文件是否合法、并重启nginx</span></span><br><span class="line">-&gt; nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf <span class="built_in">test</span> is successful</span><br><span class="line">-&gt; nginx -s reload</span><br></pre></td></tr></table></figure><h4 id="测试域名证书是否生效"><a href="#测试域名证书是否生效" class="headerlink" title="测试域名证书是否生效"></a>测试域名证书是否生效</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;domian</span><br><span class="line">http:&#x2F;&#x2F;domian 检查是否安全链接即可。一般浏览器上面会出现一个安全的标志</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://help.aliyun.com/document_detail/98728.html?spm=5176.2020520163.0.dexternal.3e4756a7jNJMZQ" target="_blank" rel="noopener">阿里云帮助文档-在Nginx上配置证书</a></p><p><a href="https://segmentfault.com/a/1190000018109309" target="_blank" rel="noopener">CentOS 7 上安装最新版 Nginx</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在搭建测试环境，很久没接触nginx了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;阅读注意事项&quot;&gt;&lt;a href=&quot;#阅读注意事项&quot; class=&quot;headerlink&quot; title=&quot;阅读注意事项&quot;&gt;&lt;/a&gt;阅读注意事项&lt;/h3&gt;
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Nginx" scheme="https://z201.github.io/tags/Nginx/"/>
    
      <category term="Https" scheme="https://z201.github.io/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>实践-spring-boot替换内置tomcat版本</title>
    <link href="https://z201.github.io/2020/07/23/%E5%AE%9E%E8%B7%B5-spring-boot%E6%9B%BF%E6%8D%A2%E5%86%85%E7%BD%AEtomcat%E7%89%88%E6%9C%AC/"/>
    <id>https://z201.github.io/2020/07/23/%E5%AE%9E%E8%B7%B5-spring-boot%E6%9B%BF%E6%8D%A2%E5%86%85%E7%BD%AEtomcat%E7%89%88%E6%9C%AC/</id>
    <published>2020-07-23T09:03:27.000Z</published>
    <updated>2020-07-23T09:35:21.482Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章只是回顾一次eureka版本升级后tomcat资源占用过高的问题，临时解决。</p></blockquote><h3 id="升级springBoot、SpringCloud版本"><a href="#升级springBoot、SpringCloud版本" class="headerlink" title="升级springBoot、SpringCloud版本"></a>升级springBoot、SpringCloud版本</h3><ul><li>升级完成后直接在测试环境测试部署，结果发现eureka的cpu资源占用过高，导致假死。通过arthas发现是tomcat线程阻塞。通过dependepency看了下springboot中内嵌tomcat的版本是9了。之前是8，测试环境一大堆人等着测试接口。首先想着降低tomcat版本。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查看依赖</span><br><span class="line">gradle dependencies</span><br><span class="line">mvn dependency:tree &gt; output.txt   # 输出到文件里</span><br></pre></td></tr></table></figure><h3 id="排除SpringBoot的Tomcat，指定Tomcat版本"><a href="#排除SpringBoot的Tomcat，指定Tomcat版本" class="headerlink" title="排除SpringBoot的Tomcat，指定Tomcat版本"></a>排除SpringBoot的Tomcat，指定Tomcat版本</h3><p>有时候我们需要在特定情况下使用特定的Tomcat版本，这时候总不能因为Tomcat就改变SpringBoot的版本，所以可以采用排除SpringBoot中的Tomcat包，然后手动指定Tomcat的版本，当然还要引入Tomcat相关的包。</p><h5 id="Gradle的配置"><a href="#Gradle的配置" class="headerlink" title="Gradle的配置"></a>Gradle的配置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>) &#123;</span><br><span class="line">  exclude <span class="keyword">module</span>: <span class="string">"spring-boot-starter-tomcat"</span></span><br><span class="line">&#125;</span><br><span class="line">compile <span class="string">'org.apache.tomcat.embed:tomcat-embed-core:8.5.37'</span></span><br><span class="line">compile <span class="string">'org.apache.tomcat.embed:tomcat-embed-el:8.5.37'</span></span><br><span class="line">compile <span class="string">'org.apache.tomcat.embed:tomcat-embed-logging-juli:8.5.2'</span></span><br><span class="line">compile <span class="string">'org.apache.tomcat.embed:tomcat-embed-websocket:8.5.37'</span></span><br></pre></td></tr></table></figure><p>如果不指定版本，则会使用最新的Tomcat版本, 否则直接指定对应的版本号。</p><h5 id="Maven的配置"><a href="#Maven的配置" class="headerlink" title="Maven的配置"></a>Maven的配置</h5><ol><li>在 pom.xml文件里面添加一个标签<properties>，添加期望的版本。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tomcat.version</span>&gt;</span>8.5.37<span class="tag">&lt;/<span class="name">tomcat.version</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>添加必要的Jar包：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-juli<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;tomcat.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-logging-juli<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;tomcat.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重新部署eureka后一切正常。处理时间短暂，没有影响大家工作。时间过了大半年了，也忘记具体是啥原因了。有机会本地复现试试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本章只是回顾一次eureka版本升级后tomcat资源占用过高的问题，临时解决。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;升级springBoot、SpringCloud版本&quot;&gt;&lt;a href=&quot;#升级springBoot、Spring
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Eureka" scheme="https://z201.github.io/tags/Eureka/"/>
    
      <category term="Tomcat" scheme="https://z201.github.io/tags/Tomcat/"/>
    
      <category term="SpringBoot" scheme="https://z201.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>实践-eureka钉钉告警通知</title>
    <link href="https://z201.github.io/2020/07/16/%E5%AE%9E%E8%B7%B5-eureka%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6%E9%80%9A%E7%9F%A5/"/>
    <id>https://z201.github.io/2020/07/16/%E5%AE%9E%E8%B7%B5-eureka%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6%E9%80%9A%E7%9F%A5/</id>
    <published>2020-07-16T09:04:36.000Z</published>
    <updated>2020-08-26T14:24:02.063Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇幅只是回顾使用eureka的时候如何钉钉告警。</p></blockquote><h3 id="eureka如何快速实现钉钉告警"><a href="#eureka如何快速实现钉钉告警" class="headerlink" title="eureka如何快速实现钉钉告警"></a>eureka如何快速实现钉钉告警</h3><p><a href="https://z201.cn/2020/07/15/%E5%AE%9E%E8%B7%B5-spring-boot%E5%BC%82%E5%B8%B8%E9%92%89%E9%92%89%E9%80%9A%E7%9F%A5/" target="_blank" rel="noopener">实践-spring-boot异常钉钉通知</a></p><p>​        上面实践了springboot全局异常钉钉告警机制。这篇主要回顾eureka监听机制钉钉告警。在日常维护工作中，如果出现网络抖动或者其它问题导致应用不可用，需要第一件发出告警提醒相关人员尽快处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">eureka -&gt;&gt; eventListener : event</span><br><span class="line">eventListener -&gt;&gt;  钉钉 : alarmNoticeSend</span><br><span class="line">钉钉 -&gt;&gt; 开发人员  : eurekaInstanceInfo</span><br></pre></td></tr></table></figure><ul><li>实例图</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/eureka%E5%AE%9E%E4%BE%8B%E9%92%89%E9%92%89%E5%91%8A%E8%AD%A6.png"></p><p>​        关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(EurekaInstanceCanceledEvent event)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"告警通知 [&#123;&#125;] 服务注销 timestamp [&#123;&#125;] serverId [&#123;&#125;]"</span>,</span><br><span class="line">                event.getAppName(),</span><br><span class="line">                event.getTimestamp(),</span><br><span class="line">                event.getServerId());</span><br><span class="line">        <span class="keyword">if</span> (!event.isReplication()) &#123;</span><br><span class="line">            ServiceNotice serviceNotice = <span class="keyword">new</span> ServiceNotice();</span><br><span class="line">            serviceNotice.setTitle(<span class="string">"告警通知 服务下线"</span>);</span><br><span class="line">            serviceNotice.setAppName(event.getAppName());</span><br><span class="line">            serviceNotice.setTimestamp(event.getTimestamp());</span><br><span class="line">            serviceNotice.setServerId(event.getServerId());</span><br><span class="line">            serviceNotice.setProfiles(active);</span><br><span class="line">            alarmNoticeManage.createNotice(serviceNotice, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(EurekaInstanceRegisteredEvent event)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"告警通知 [&#123;&#125;] 服务注册 timestamp [&#123;&#125;] id [&#123;&#125;] ipAddr [&#123;&#125;] "</span>,</span><br><span class="line">                event.getInstanceInfo().getAppName(),</span><br><span class="line">                event.getTimestamp(),</span><br><span class="line">                event.getInstanceInfo().getId(),</span><br><span class="line">                event.getInstanceInfo().getIPAddr()</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (!event.isReplication()) &#123;</span><br><span class="line">            ServiceNotice serviceNotice = <span class="keyword">new</span> ServiceNotice();</span><br><span class="line">            serviceNotice.setTitle(<span class="string">"告警通知 服务上线"</span>);</span><br><span class="line">            serviceNotice.setAppName(event.getInstanceInfo().getAppName());</span><br><span class="line">            serviceNotice.setTimestamp(event.getTimestamp());</span><br><span class="line">            serviceNotice.setServerId(event.getInstanceInfo().getId());</span><br><span class="line">            serviceNotice.setProfiles(active);</span><br><span class="line">            alarmNoticeManage.createNotice(serviceNotice, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>效果如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">告警通知 服务下线</span><br><span class="line">2020-07-16 16:03:20 Z-GATEWAY 192.168.31.7:z-gateway:9000 profiles dev1</span><br><span class="line">@xxx</span><br></pre></td></tr></table></figure><ul><li>eureka查看源码得知有五个事件。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EurekaServerStartedEvent - Eureka服务端启动事件</span><br><span class="line">EurekaRegistryAvailableEvent - Eureka服务端可用事件</span><br><span class="line">EurekaInstanceRegisteredEvent - Eureka客户端服务注册事件</span><br><span class="line">EurekaInstanceRenewedEvent - Eureka客户端续约事件</span><br><span class="line">EurekaInstanceCanceledEvent - Eureka客户端下线事件</span><br></pre></td></tr></table></figure><p>这里就比较简单了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇幅只是回顾使用eureka的时候如何钉钉告警。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;eureka如何快速实现钉钉告警&quot;&gt;&lt;a href=&quot;#eureka如何快速实现钉钉告警&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="微服务" scheme="https://z201.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Eureka" scheme="https://z201.github.io/tags/Eureka/"/>
    
      <category term="钉钉" scheme="https://z201.github.io/tags/%E9%92%89%E9%92%89/"/>
    
  </entry>
  
  <entry>
    <title>实践-SpringBoot异常钉钉通知</title>
    <link href="https://z201.github.io/2020/07/15/%E5%AE%9E%E8%B7%B5-spring-boot%E5%BC%82%E5%B8%B8%E9%92%89%E9%92%89%E9%80%9A%E7%9F%A5/"/>
    <id>https://z201.github.io/2020/07/15/%E5%AE%9E%E8%B7%B5-spring-boot%E5%BC%82%E5%B8%B8%E9%92%89%E9%92%89%E9%80%9A%E7%9F%A5/</id>
    <published>2020-07-15T07:23:20.000Z</published>
    <updated>2020-08-15T01:20:15.232Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇幅只是回顾使用钉钉做异常告警需要那些关键业务信息。</p></blockquote><h3 id="为什么要做钉钉通知？"><a href="#为什么要做钉钉通知？" class="headerlink" title="为什么要做钉钉通知？"></a>为什么要做钉钉通知？</h3><p>​        事情要从我入职上家公司说起，进入公司后把线上项目clone下来大致看了下。代码风格过于滞后、编码风格混乱。进入公司第一周就出现了线上故障，嗯。我去线上检查日志，emmmm竟然没有日志输出。这次故障是由客户反馈来的。当时我非常吃惊，大伙好像很淡定的样子，习以为常了？</p><p>​        想到当初面试的时候和总监的谈话，主要是带领团队落地微服务架构，看来必须大刀阔斧了。</p><p>​        首先想到的时候改进日志输出、定义全局异常级别，根据异常级别输出日志。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">Java应用 -&gt;&gt; SpringAop全局异常拦截 : runtimeException</span><br><span class="line">SpringAop全局异常拦截 -&gt;&gt;  钉钉 : alarmNoticeSend</span><br><span class="line">钉钉 -&gt;&gt; 开发人员  : exceptionInfo</span><br></pre></td></tr></table></figure><ul><li>效果图</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/springboot%E9%92%89%E9%92%89%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA.png"></p><p>​        我们需要从钉钉里面看到那些异常信息呢？这是当时输出到钉钉的信息。通过编写全局拦截器，在公共基础项目里面添加了aop全局拦截。刚开始上线的时候钉钉一天动不动就几千个异常告警。刚开始大伙都很紧张，过了个把月大伙已经又麻木了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">告警信息</span><br><span class="line">工程名：z201-gateway</span><br><span class="line">类路径：cn.z201.cloud.gateway.VlinkFrameworkGatewayApplicationTest</span><br><span class="line">方法名：alarm</span><br><span class="line">异常信息：java.lang.IllegalAccessException</span><br><span class="line">异常追踪：</span><br><span class="line">cn.z201.cloud.gateway.VlinkFrameworkGatewayApplicationTest.alarm(VlinkFrameworkGatewayApplicationTest.java:<span class="number">64</span>)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">org.junit.runners.model.FrameworkMethod$<span class="number">1</span>.runReflectiveCall(FrameworkMethod.java:<span class="number">50</span>)</span><br><span class="line">org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:<span class="number">12</span>)</span><br><span class="line">org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:<span class="number">47</span>)</span><br><span class="line">org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:<span class="number">17</span>)</span><br><span class="line">org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:<span class="number">74</span>)</span><br></pre></td></tr></table></figure><h3 id="这样的告警信息就够了吗？"><a href="#这样的告警信息就够了吗？" class="headerlink" title="这样的告警信息就够了吗？"></a>这样的告警信息就够了吗？</h3><p>​        明显这样是不够够的，前端有安卓、ios、微信小程序、web、快应用。太多前端项目了，后端需要识别出是哪里的项目出的问题。于是又改进了一次。邀请前端开发人员在HttpHeader里面增加额外参数。为了做流量区分也增加了一些参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  <span class="string">"Content-Type"</span>:<span class="string">"application/json"</span> </span><br><span class="line">  "Authorization":"Bearer xxxxxxxxxx"  ## jwt</span><br><span class="line">  "Client-Business-Group-Source": "1", ##  业务组来源唯一标号</span><br><span class="line">  "Client-Business-Source": "1000", ## 业务来源唯一标号</span><br><span class="line">  "Client-Business-Activity-Source": "1", ## 查看介绍、更多 针对特殊业务流量识别</span><br><span class="line">  "Client-Env-Source": "1", ##客户端环境来源  1 ios  2 android  3 windows</span><br><span class="line">  "Client-Platform-Source": "xxx", ##客户端平台 xxx手机型号、浏览器</span><br><span class="line">  "Client-Start-Time": "1",        ##请求时间戳</span><br><span class="line">  "Client-Version-Source": "1.0.0" ##客户端版本号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        通过上面的改进告警信息完善很多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">告警信息</span><br><span class="line">工程名：z201-gateway</span><br><span class="line">类路径：cn.z201.cloud.gateway.VlinkFrameworkGatewayApplicationTest</span><br><span class="line">方法名：alarm</span><br><span class="line">异常信息：java.lang.IllegalAccessException</span><br><span class="line">异常扩展信息： &#123;</span><br><span class="line">  &quot;Client-Business-Source&quot;: &quot;1000&quot;, </span><br><span class="line">  &quot;Client-Business-Activity-Source&quot;: &quot;1&quot;, </span><br><span class="line">  &quot;Client-Env-Source&quot;: &quot;1&quot;, </span><br><span class="line">  &quot;Client-Platform-Source&quot;: &quot;xxx&quot;,   </span><br><span class="line">  &quot;Client-Version-Source&quot;: &quot;1.0.0&quot; </span><br><span class="line">&#125; </span><br><span class="line">异常追踪：</span><br><span class="line">cn.z201.cloud.gateway.VlinkFrameworkGatewayApplicationTest.alarm(VlinkFrameworkGatewayApplicationTest.java:64)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)</span><br><span class="line">org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)</span><br><span class="line">org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)</span><br><span class="line">org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)</span><br><span class="line">org.springframework.test.context.junit4.statements.RunBeforeTestExecutionCallbacks.evaluate(RunBeforeTestExecutionCallbacks.java:74)</span><br></pre></td></tr></table></figure><h3 id="分布式下面临的问题！"><a href="#分布式下面临的问题！" class="headerlink" title="分布式下面临的问题！"></a>分布式下面临的问题！</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">gateway -&gt;&gt; 应用A : httpRequest</span><br><span class="line">应用A -&gt;&gt;  应用B : httpRequest</span><br><span class="line">应用B --&gt;&gt; 应用A : httpResponse</span><br><span class="line">应用A --&gt;&gt; gateway : httpResponse</span><br></pre></td></tr></table></figure><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E5%A4%9A%E5%BA%94%E7%94%A8%E9%93%BE%E8%B7%AF%E8%AF%B7%E6%B1%82.png"></p><p>​        当调用链多的时候定位问题就有点麻烦，比如应用a调用应用b。应用b执行了异常信息直接抛出了告警信息。但是spring cloud http rpc默认是不会吧请求参数传递到后面的服务中，需要我们做下简单的扩展。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> z201.coding@gmail.com</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpApiConstant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String X_REAL_IP = <span class="string">"x-real-ip"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求头跟踪id名。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String HTTP_HEADER_TRACE_ID = <span class="string">"AppTraceId"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String HTTP_TOKEN_HEADER = <span class="string">"Authorization"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * app租户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String APP_TENANT = <span class="string">"Tenant"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_BUSINESS_GROUP_SOURCE = <span class="string">"Client-Business-Group-Source"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_BUSINESS_SOURCE = <span class="string">"Client-Business-Source"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_BUSINESS_ACTIVITY_SOURCE = <span class="string">"Client-Business-Activity-Source"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_EVN_SOURCE = <span class="string">"Client-Env-Source"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_PLATFORM_SOURCE = <span class="string">"Client-Platform-Source"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_START_TIME = <span class="string">"Client-Start-Time"</span>;</span><br><span class="line"></span><br><span class="line">    String CLIENT_VERSION_SOURCE = <span class="string">"Client-Version-Source"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> z201.coding@gmail.com</span></span><br><span class="line"><span class="comment"> * 自定义restTemplate拦截器</span></span><br><span class="line"><span class="comment"> * 这里可以把一些参数从应用层传到内部服务</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(WebMvcConfigurer<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MdcFeignInterceptorConfig</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span>, <span class="title">HttpApiConstant</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MdcFeignInterceptorConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Loaded Z-REST-INTERCEPTOR [V1.0.0]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes())</span><br><span class="line">                    .getRequest();</span><br><span class="line">            String xRealIp = request.getHeader(X_REAL_IP);</span><br><span class="line">            String authentication = request.getHeader(HTTP_TOKEN_HEADER);</span><br><span class="line">            String appTraceId = request.getHeader(HTTP_HEADER_TRACE_ID);</span><br><span class="line">            String businessGroupSource = request.getHeader(CLIENT_BUSINESS_GROUP_SOURCE);</span><br><span class="line">            String clientBusinessSource = request.getHeader(CLIENT_BUSINESS_SOURCE);</span><br><span class="line">            String clientBusinessActivitySource = request.getHeader(CLIENT_BUSINESS_ACTIVITY_SOURCE);</span><br><span class="line">            String clientEnvSource = request.getHeader(CLIENT_EVN_SOURCE);</span><br><span class="line">            String clientPlatformSource = request.getHeader(CLIENT_PLATFORM_SOURCE);</span><br><span class="line">            String clientStartTime = request.getHeader(CLIENT_START_TIME);</span><br><span class="line">            String clientVersionSource = request.getHeader(CLIENT_VERSION_SOURCE);</span><br><span class="line">            template.header(HttpHeaders.ACCEPT_ENCODING, <span class="string">"gzip"</span>);</span><br><span class="line">            template.header(X_REAL_IP, xRealIp);</span><br><span class="line">            template.header(HTTP_TOKEN_HEADER, authentication);</span><br><span class="line">            template.header(CLIENT_BUSINESS_GROUP_SOURCE, businessGroupSource);</span><br><span class="line">            template.header(CLIENT_BUSINESS_SOURCE, clientBusinessSource);</span><br><span class="line">            template.header(CLIENT_BUSINESS_ACTIVITY_SOURCE, clientBusinessActivitySource);</span><br><span class="line">            template.header(CLIENT_EVN_SOURCE, clientEnvSource);</span><br><span class="line">            template.header(CLIENT_PLATFORM_SOURCE, clientPlatformSource);</span><br><span class="line">            template.header(CLIENT_START_TIME, clientStartTime);</span><br><span class="line">            template.header(CLIENT_VERSION_SOURCE, clientVersionSource);</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                Enumeration&lt;String&gt; headerNames = request.getHeaderNames();</span><br><span class="line">                <span class="keyword">while</span> (headerNames.hasMoreElements()) &#123;</span><br><span class="line">                    String name = headerNames.nextElement();</span><br><span class="line">                    String value = request.getHeader(name);</span><br><span class="line">                    log.debug(<span class="string">"header &#123;&#125; - &#123;&#125;"</span>, name, value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"template exception &#123;&#125;"</span>,e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的异常钉钉告警就到这里结束了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本篇幅只是回顾使用钉钉做异常告警需要那些关键业务信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;为什么要做钉钉通知？&quot;&gt;&lt;a href=&quot;#为什么要做钉钉通知？&quot; class=&quot;headerlink&quot; title=&quot;为什么要做钉钉通知？
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.github.io/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="微服务" scheme="https://z201.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Spring" scheme="https://z201.github.io/tags/Spring/"/>
    
      <category term="钉钉" scheme="https://z201.github.io/tags/%E9%92%89%E9%92%89/"/>
    
  </entry>
  
  <entry>
    <title>面试题-交换两个变量的值</title>
    <link href="https://z201.github.io/2020/07/12/%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/"/>
    <id>https://z201.github.io/2020/07/12/%E9%9D%A2%E8%AF%95%E9%A2%98-%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/</id>
    <published>2020-07-12T00:02:14.000Z</published>
    <updated>2020-08-12T00:10:29.339Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>刚去杭州面试的第二家公司，做笔试的时候的时候遇到的。最近几天在整理以前的笔记发现了。简单记录下。</p></blockquote><h3 id="互换两个变量的值"><a href="#互换两个变量的值" class="headerlink" title="互换两个变量的值"></a>互换两个变量的值</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">12</span>;</span><br><span class="line"><span class="comment">// 通过两个变量之间的运算输出结果 a = 12 b = 10</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swapTest1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">12</span>;</span><br><span class="line">a=a^b; <span class="comment">//a=1010^b=1100;</span></span><br><span class="line">b=a^b; <span class="comment">//a=0110^b=1100;</span></span><br><span class="line">a=a^b; <span class="comment">//a=0110^b=1010;</span></span><br><span class="line"><span class="comment">//a=1100=12;b=1010;</span></span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swapTest2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">12</span>;</span><br><span class="line">a = a + b; <span class="comment">// 22 = 10 + 12</span></span><br><span class="line">b = a - b; <span class="comment">// 10 = 22 - 12</span></span><br><span class="line">a = a - b; <span class="comment">// 12 = 22 - 10</span></span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;刚去杭州面试的第二家公司，做笔试的时候的时候遇到的。最近几天在整理以前的笔记发现了。简单记录下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;互换两个变量的值&quot;&gt;&lt;a href=&quot;#互换两个变量的值&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="面试" scheme="https://z201.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>面试题-Redis</title>
    <link href="https://z201.github.io/2020/07/03/%E9%9D%A2%E8%AF%95%E9%A2%98-Redis/"/>
    <id>https://z201.github.io/2020/07/03/%E9%9D%A2%E8%AF%95%E9%A2%98-Redis/</id>
    <published>2020-07-02T20:39:42.000Z</published>
    <updated>2020-08-14T20:36:37.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章属于持续学习、长期更修。</p></blockquote><h3 id="缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题"><a href="#缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题" class="headerlink" title="缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题"></a>缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</h3><ol><li><p>缓存雪崩</p><ul><li>我们可以简单的理解为：由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</li><li><strong>解决办法：</strong><ul><li>大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。</li></ul></li></ul></li><li><p>缓存穿透</p><ul><li><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p></li><li><p>解决办法</p><ul><li>最常见的则是采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</li><li>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。</li><li><strong>布隆过滤器（推荐）</strong><ul><li>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</li></ul></li></ul></li></ul></li><li><p>缓存预热</p><ul><li>缓存预热这个应该是一个比较常见的概念，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</li></ul></li><li><p>缓存更新</p><ul><li>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：<ul><li>定时去清理过期的缓存；</li><li>当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</li></ul></li><li>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</li></ul></li><li><p>缓存降级</p><ul><li>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。<ul><li>以参考日志级别设置预案：<ul><li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li><li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li><li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li><li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li></ul></li></ul></li><li>服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。</li></ul></li></ol><h3 id="Redis-的线程模型"><a href="#Redis-的线程模型" class="headerlink" title="Redis 的线程模型"></a>Redis 的线程模型</h3><ul><li>redis 内部使⽤⽂件事件处理器<code>file event handler</code>，这个⽂件事件处理器是单线程的，所以redis 才叫做单线程的模型。它采⽤ IO 多路复⽤机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进⾏处理。</li></ul><h3 id="单线程的Redis为什么这么快"><a href="#单线程的Redis为什么这么快" class="headerlink" title="单线程的Redis为什么这么快"></a>单线程的Redis为什么这么快</h3><ul><li>存内存操作。</li><li>单线程操作，避免平凡的上下文切换。</li><li>采用了非阻塞I/O多路复用操作。（这里的I/O是指网络I/O）</li></ul><h3 id="Redis的过期策略以及内存淘汰机制"><a href="#Redis的过期策略以及内存淘汰机制" class="headerlink" title="Redis的过期策略以及内存淘汰机制"></a>Redis的过期策略以及内存淘汰机制</h3><ul><li><p>redis采用的是定期删除+惰性删除策略。</p><ul><li>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</li></ul></li><li><p>配内存淘汰策略</p><ul><li><p><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p></li><li><p><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p></li><li><p><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p></li><li><p><strong>allkeys-lru</strong>：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p></li><li><p><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</p></li><li><p><strong>no-enviction</strong>（驱逐）：禁止驱逐数据，新写入操作会报错</p></li><li><p>如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和</p><p>volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</p></li></ul></li></ul><a id="more"></a><h3 id="为什么Redis的操作是原子性的，怎么保证原子性的？"><a href="#为什么Redis的操作是原子性的，怎么保证原子性的？" class="headerlink" title="为什么Redis的操作是原子性的，怎么保证原子性的？"></a>为什么Redis的操作是原子性的，怎么保证原子性的？</h3><ul><li>对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。Redis的操作之所以是原子性的，是因为Redis是单线程的。</li><li>Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。多个命令在并发中也是原子性的吗？</li><li>不一定， 将get和set改成单命令操作，incr 。使用Redis的事务，或者使用Redis+Lua的方式实现。</li></ul><h3 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h3><blockquote><p>严格上来说redis是伪事物，</p></blockquote><ul><li>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的。Redis会将一个事务中的所有命令序列化，然后按顺序执行。<ol><li>redis 不支持回滚“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。</li><li>如果在一个事务中的命令出现错误，那么所有的命令都不会执行；</li><li>如果在一个事务中出现运行错误，那么正确的命令会被执行。</li></ol></li><li>MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li><li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。</li><li>通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</li><li>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本章属于持续学习、长期更修。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题&quot;&gt;&lt;a href=&quot;#缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题&quot; class=&quot;headerlink&quot; title=&quot;缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题&quot;&gt;&lt;/a&gt;缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;缓存雪崩&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们可以简单的理解为：由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决办法：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缓存穿透&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解决办法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最常见的则是采用&lt;strong&gt;布隆过滤器&lt;/strong&gt;，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。&lt;/li&gt;
&lt;li&gt;如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;布隆过滤器（推荐）&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;就是引入了k(k&amp;gt;1)k(k&amp;gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缓存预热&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存预热这个应该是一个比较常见的概念，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缓存更新&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：&lt;ul&gt;
&lt;li&gt;定时去清理过期的缓存；&lt;/li&gt;
&lt;li&gt;当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;缓存降级&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。&lt;ul&gt;
&lt;li&gt;以参考日志级别设置预案：&lt;ul&gt;
&lt;li&gt;一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；&lt;/li&gt;
&lt;li&gt;警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；&lt;/li&gt;
&lt;li&gt;错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；&lt;/li&gt;
&lt;li&gt;严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务降级的目的，是为了防止Redis服务故障，导致数据库跟着一起发生雪崩问题。因此，对于不重要的缓存数据，可以采取服务降级策略，例如一个比较常见的做法就是，Redis出现问题，不去数据库查询，而是直接返回默认值给用户。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Redis-的线程模型&quot;&gt;&lt;a href=&quot;#Redis-的线程模型&quot; class=&quot;headerlink&quot; title=&quot;Redis 的线程模型&quot;&gt;&lt;/a&gt;Redis 的线程模型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;redis 内部使⽤⽂件事件处理器&lt;code&gt;file event handler&lt;/code&gt;，这个⽂件事件处理器是单线程的，所以redis 才叫做单线程的模型。它采⽤ IO 多路复⽤机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进⾏处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;单线程的Redis为什么这么快&quot;&gt;&lt;a href=&quot;#单线程的Redis为什么这么快&quot; class=&quot;headerlink&quot; title=&quot;单线程的Redis为什么这么快&quot;&gt;&lt;/a&gt;单线程的Redis为什么这么快&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;存内存操作。&lt;/li&gt;
&lt;li&gt;单线程操作，避免平凡的上下文切换。&lt;/li&gt;
&lt;li&gt;采用了非阻塞I/O多路复用操作。（这里的I/O是指网络I/O）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Redis的过期策略以及内存淘汰机制&quot;&gt;&lt;a href=&quot;#Redis的过期策略以及内存淘汰机制&quot; class=&quot;headerlink&quot; title=&quot;Redis的过期策略以及内存淘汰机制&quot;&gt;&lt;/a&gt;Redis的过期策略以及内存淘汰机制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;redis采用的是定期删除+惰性删除策略。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配内存淘汰策略&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;volatile-lru&lt;/strong&gt;：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;volatile-ttl&lt;/strong&gt;：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;volatile-random&lt;/strong&gt;：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;allkeys-lru&lt;/strong&gt;：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;allkeys-random&lt;/strong&gt;：从数据集（server.db[i].dict）中任意选择数据淘汰&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;no-enviction&lt;/strong&gt;（驱逐）：禁止驱逐数据，新写入操作会报错&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和&lt;/p&gt;
&lt;p&gt;volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://z201.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Redis" scheme="https://z201.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>面试题-Mysql</title>
    <link href="https://z201.github.io/2020/07/03/%E9%9D%A2%E8%AF%95%E9%A2%98-Mysql/"/>
    <id>https://z201.github.io/2020/07/03/%E9%9D%A2%E8%AF%95%E9%A2%98-Mysql/</id>
    <published>2020-07-02T20:33:01.000Z</published>
    <updated>2021-04-06T15:34:02.124Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章属于持续学习、长期更修。</p></blockquote><h3 id="数据库的三范式是什么"><a href="#数据库的三范式是什么" class="headerlink" title="数据库的三范式是什么"></a>数据库的三范式是什么</h3><ul><li>第一范式：列不可再分</li><li>第二范式：行可以唯一区分，主键约束</li><li>第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束</li><li>且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上。</li><li>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</li><li>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</li><li>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y</li></ul><h3 id="说下mysql有几种数据库引擎"><a href="#说下mysql有几种数据库引擎" class="headerlink" title="说下mysql有几种数据库引擎"></a>说下mysql有几种数据库引擎</h3><blockquote><p>不清楚，因为每个版本发布都会新增一些。但是我最熟悉是的innodb。</p></blockquote><h3 id="说下mysql-Master-slave-的原理"><a href="#说下mysql-Master-slave-的原理" class="headerlink" title="说下mysql Master slave 的原理"></a>说下mysql Master slave 的原理</h3><ul><li><p><strong>主</strong>：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</p></li><li><p><strong>从</strong>：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；</p></li><li><p><strong>从</strong>：sql执行线程——执行relay log中的语句；</p></li></ul><h3 id="MySQL中myisam与innodb的区别"><a href="#MySQL中myisam与innodb的区别" class="headerlink" title="MySQL中myisam与innodb的区别"></a>MySQL中myisam与innodb的区别</h3><ul><li>InnoDB支持事物，而MyISAM不支持事物</li><li>InnoDB支持行级锁，而MyISAM支持表级锁</li><li>InnoDB支持MVCC, 而MyISAM不支持</li><li>InnoDB支持外键，而MyISAM不支持</li><li>InnoDB不支持全文索引，而MyISAM支持。</li></ul><h3 id="innodb引擎的4大特性"><a href="#innodb引擎的4大特性" class="headerlink" title="innodb引擎的4大特性"></a>innodb引擎的4大特性</h3><ul><li>插入缓冲（insert buffer),</li><li>二次写(double write),</li><li>自适应哈希索引(ahi),</li><li>预读(read ahead)</li><li>支持事务操作，具有事务 ACID 隔离特性，默认的隔离级别是<code>可重复读(repetable-read)</code>、通过MVCC（并发版本控制）来实现的。能够解决<code>脏读</code>和<code>不可重复读</code>的问题。</li><li>InnoDB 支持外键操作。</li><li>InnoDB 默认的锁粒度<code>行级锁</code>，并发性能比较好，会发生死锁的情况。</li><li>和 MyISAM 一样的是，InnoDB 存储引擎也有 <code>.frm文件存储表结构</code> 定义，但是不同的是，InnoDB 的表数据与索引数据是存储在一起的，都位于 B+ 数的叶子节点上，而 MyISAM 的表数据和索引数据是分开的。</li><li>InnoDB 有安全的日志文件，这个日志文件用于恢复因数据库崩溃或其他情况导致的数据丢失问题，保证数据的一致性。</li><li>InnoDB 和 MyISAM 支持的索引类型相同，但具体实现因为文件结构的不同有很大差异。</li><li>增删改查性能方面，如果执行大量的增删改操作，推荐使用 InnoDB 存储引擎，它在删除操作时是对行删除，不会重建表。</li></ul><h3 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h3><ul><li>事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</li></ul><h3 id="覆盖索引和回表"><a href="#覆盖索引和回表" class="headerlink" title="覆盖索引和回表"></a>覆盖索引和回表</h3><ul><li>覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。而要确定一个查询是否是覆盖索引，我们只需要explain sql语句看Extra的结果是否是“Using index”即可。</li></ul><h3 id="MySQL-事务四大特性"><a href="#MySQL-事务四大特性" class="headerlink" title="MySQL 事务四大特性"></a>MySQL 事务四大特性</h3><blockquote><p>一说到 MySQL 事务，你肯定能想起来四大特性：<code>原子性</code>、<code>一致性</code>、<code>隔离性</code>、<code>持久性</code>。什么是 MySQL 中的事务？</p><p>事务是一组操作，组成这组操作的各个单元，要不全都成功要不全都失败，这个特性就是事务。</p><p>在 MySQL 中，事务是在引擎层实现的，只有使用 <code>innodb</code> 引擎的数据库或表才支持事务。</p></blockquote><ul><li><code>原子性(Atomicity)</code>: 原子性指的就是 MySQL 中的包含事务的操作要么<code>全部成功</code>、要么全部<code>失败回滚</code>，因此事务的操作如果成功就必须要全部应用到数据库，如果操作失败则不能对数据库有任何影响。</li><li><code>一致性(Consistency)</code>：一致性指的是一个事务在执行前后其状态一致。比如 A 和 B 加起来的钱一共是 1000 元，那么不管 A 和 B 之间如何转账，转多少次，事务结束后两个用户的钱加起来还得是 1000，这就是事务的一致性。</li><li><code>持久性(Durability)</code>: 持久性指的是一旦事务提交，那么发生的改变就是永久性的，即使数据库遇到特殊情况比如故障的时候也不会产生干扰。</li><li><code>隔离性(Isolation)</code>：当多个事务同时进行时，就有可能出现<code>脏读(dirty read)</code>、<code>不可重复读(non-repeatable read)</code>、<code>幻读(phantom read)</code> 的情况，为了解决这些并发问题，提出了隔离性的概念。<ul><li>重点说下隔离性它们分别是<code>读未提交(read uncommitted)</code>、<code>读已提交(read committed)</code>、<code>可重复读(repetable read)</code> 和 <code>串行化(serializable)</code>。下面分别来解释一下。</li><li><code>读未提交</code>：读未提交指的是一个事务在提交之前，它所做的修改就能够被其他事务所看到。</li><li><code>读已提交</code>：读已提交指的是一个事务在提交之后，它所做的变更才能够让其他事务看到。</li><li><code>可重复读</code>：可重复读指的是一个事务在执行的过程中，看到的数据是和启动时看到的数据是一致的。未提交的变更对其他事务不可见。</li><li><code>串行化</code>：顾名思义是对于同一行记录，<code>写</code>会加<code>写锁</code>，<code>读</code>会加<code>读锁</code>。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul></li></ul><h3 id="SQL语句的执行顺序"><a href="#SQL语句的执行顺序" class="headerlink" title="SQL语句的执行顺序"></a>SQL语句的执行顺序</h3><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png"></p><blockquote><p>我们在编写一个查询语句的时候</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">    &lt; select_list &gt;</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    &lt; left_table &gt; &lt; join_type &gt;</span><br><span class="line"><span class="keyword">JOIN</span> &lt; right_table &gt; <span class="keyword">ON</span> &lt; join_condition &gt;</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    &lt; where_condition &gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">    &lt; group_by_list &gt;</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">    &lt; having_condition &gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    &lt; order_by_condition &gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt; limit_number &gt;</span><br></pre></td></tr></table></figure><ol><li>FROM 连接</li></ol><ul><li>首先，对 SELECT 语句执行查询时，对<code>FROM</code> 关键字两边的表执行连接，会形成<code>笛卡尔积</code>，这时候会产生一个<code>虚表VT1(virtual table)</code></li></ul><blockquote><p>首先先来解释一下什么是<code>笛卡尔积</code></p><p>现在我们有两个集合 A = {0,1} , B = {2,3,4}</p><p>那么，集合 A * B 得到的结果就是</p><p>A * B = {(0,2)、(1,2)、(0,3)、(1,3)、(0,4)、(1,4)};</p><p>B * A = {(2,0)、{2,1}、{3,0}、{3,1}、{4,0}、(4,1)};</p><p>上面 A * B 和 B * A 的结果就可以称为两个集合相乘的 <code>笛卡尔积</code></p><p>我们可以得出结论，A 集合和 B 集合相乘，包含了集合 A 中的元素和集合 B 中元素之和，也就是 A 元素的个数 * B 元素的个数</p></blockquote><ol start="2"><li>ON 过滤</li></ol><ul><li>然后对 FROM 连接的结果进行 ON 筛选，创建 VT2，把符合记录的条件存在 VT2 中。</li></ul><ol start="3"><li>JOIN 连接</li></ol><p>第三步，如果是 <code>OUTER JOIN(left join、right join)</code> ，那么这一步就将添加外部行，如果是 left join 就把 ON 过滤条件的左表添加进来，如果是 right join ，就把右表添加进来，从而生成新的虚拟表 VT3。</p><ol start="4"><li>WHERE 过滤</li></ol><ul><li><p>第四步，是执行 WHERE 过滤器，对上一步生产的虚拟表引用 WHERE 筛选，生成虚拟表 VT4。</p></li><li><p>WHERE 和 ON 的区别</p><ul><li>如果有外部列，ON 针对过滤的是关联表，主表(保留表)会返回所有的列;</li><li>如果没有添加外部列，两者的效果是一样的;</li></ul></li><li><p>应用</p><ul><li>对主表的过滤应该使用 WHERE;</li><li>对于关联表，先条件查询后连接则用 ON，先连接后条件查询则用 WHERE;</li></ul></li></ul><ol start="5"><li>GROUP BY</li></ol><ul><li>根据 group by 字句中的列，会对 VT4 中的记录进行分组操作，产生虚拟机表 VT5。果应用了group by，那么后面的所有步骤都只能得到的 VT5 的列或者是聚合函数（count、sum、avg等）。</li></ul><ol start="6"><li>HAVING</li></ol><ul><li>紧跟着 GROUP BY 字句后面的是 HAVING，使用 HAVING 过滤，会把符合条件的放在 VT6</li></ul><ol start="7"><li>SELECT</li></ol><ul><li>第七步才会执行 SELECT 语句，将 VT6 中的结果按照 SELECT 进行刷选，生成 VT7</li></ul><ol start="8"><li>DISTINCT</li></ol><ul><li>在第八步中，会对 TV7 生成的记录进行去重操作，生成 VT8。事实上如果应用了 group by 子句那么 distinct 是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。</li></ul><ol start="9"><li>ORDER BY</li></ol><ul><li>应用 order by 子句。按照 order_by_condition 排序 VT8，此时返回的一个游标，而不是虚拟表。sql 是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。</li></ul><h3 id="什么是临时表，何时删除临时表"><a href="#什么是临时表，何时删除临时表" class="headerlink" title="什么是临时表，何时删除临时表"></a>什么是临时表，何时删除临时表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在 MySQL 中，有三种类型的表</span><br><span class="line">一种是&#96;永久表&#96;，永久表就是创建以后用来长期保存数据的表</span><br><span class="line">一种是&#96;临时表&#96;，临时表也有两类，一种是和永久表一样，只保存临时数据，但是能够长久存在的；还有一种是临时创建的，SQL 语句执行完成就会删除。</span><br><span class="line">一种是&#96;虚表&#96;，虚表其实就是&#96;视图&#96;，数据可能会来自多张表的执行结果。</span><br></pre></td></tr></table></figure><ul><li>MySQL 会在下面这几种情况产生临时表<ul><li>使用 UNION 查询：UNION 有两种，一种是<code>UNION</code> ，一种是 <code>UNION ALL</code> ，它们都用于联合查询；区别是 使用 UNION 会去掉两个表中的重复数据，相当于对结果集做了一下<code>去重(distinct)</code>。使用 UNION ALL，则不会排重，返回所有的行。使用 UNION 查询会产生临时表。</li><li>使用 <code>TEMPTABLE 算法</code>或者是 UNION 查询中的视图。TEMPTABLE 算法是一种创建临时表的算法，它是将结果放置到临时表中，意味这要 MySQL 要先创建好一个临时表，然后将结果放到临时表中去，然后再使用这个临时表进行相应的查询。</li><li>ORDER BY 和 GROUP BY 的子句不一样时也会产生临时表。</li><li>DISTINCT 查询并且加上 ORDER BY 时；</li><li>SQL 用到 SQL_SMALL_RESULT 选项时；如果查询结果比较小的时候，可以加上 SQL_SMALL_RESULT 来优化，产生临时表</li><li>FROM 中的子查询；</li><li>EXPLAIN 查看执行计划结果的 Extra 列中，如果使用 <code>Using Temporary</code> 就表示会用到临时表。</li></ul></li></ul><h3 id="介绍下InnoDB存储引擎的B-树索引"><a href="#介绍下InnoDB存储引擎的B-树索引" class="headerlink" title="介绍下InnoDB存储引擎的B+树索引"></a>介绍下InnoDB存储引擎的B+树索引</h3><ul><li>每个索引都对应一棵B+树，B+树分为好多层，最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+树的叶子节点，所有目录项记录都存储在内节点。</li><li>InnoDB存储引擎会自动为主键（如果没有它会自动帮我们添加）建立聚簇索引，聚簇索引的叶子节点包含完整的用户记录。</li><li>我们可以为自己感兴趣的列建立二级索引，二级索引的叶子节点包含的用户记录由索引列 + 主键组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。</li><li>B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。</li><li>通过索引查找记录是从B+树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory（页目录），所以在这些页面中的查找非常快。</li><li>二者SELECT COUNT(*)哪个更快，为什么<ul><li>myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</li></ul></li></ul><a id="more"></a><h3 id="MySQL-常见索引类型"><a href="#MySQL-常见索引类型" class="headerlink" title="MySQL 常见索引类型"></a>MySQL 常见索引类型</h3><blockquote><p>索引是存储在一张表中特定列上的<code>数据结构</code>，索引是在列上创建的。并且，索引是一种数据结构。</p></blockquote><ul><li>在 MySQL 中，主要有下面这几种索引<ul><li><code>全局索引(FULLTEXT)</code>：全局索引，目前只有 MyISAM 引擎支持全局索引，它的出现是为了解决针对文本的模糊查询效率较低的问题。</li><li><code>哈希索引(HASH)</code>：哈希索引是 MySQL 中用到的唯一 key-value 键值对的数据结构，很适合作为索引。HASH 索引具有一次定位的好处，不需要像树那样逐个节点查找，但是这种查找适合应用于查找单个键的情况，对于范围查找，HASH 索引的性能就会很低。</li><li><code>B-Tree 索引</code>：B 就是 Balance 的意思，BTree 是一种平衡树，它有很多变种，最常见的就是 B+ Tree，它被 MySQL 广泛使用。</li><li><code>R-Tree 索引</code>：R-Tree 在 MySQL 很少使用，仅支持 geometry 数据类型，支持该类型的存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种，相对于 B-Tree 来说，R-Tree 的优势在于范围查找。</li></ul></li></ul><h3 id="主键和候选键有什么区别？"><a href="#主键和候选键有什么区别？" class="headerlink" title="主键和候选键有什么区别？"></a>主键和候选键有什么区别？</h3><ul><li>表格的每一行都由主键唯一标识,一个表只有一个主键。</li><li>主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。</li></ul><h3 id="超键、候选键、主键、外键分别是什么？"><a href="#超键、候选键、主键、外键分别是什么？" class="headerlink" title="超键、候选键、主键、外键分别是什么？"></a>超键、候选键、主键、外键分别是什么？</h3><ul><li>1、超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>2、候选键：是最小超键，即没有冗余元素的超键。</li><li>3、主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>4、外键：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h3 id="MySQL中varchar与char的区别以及varchar-50-中的50代表的涵义"><a href="#MySQL中varchar与char的区别以及varchar-50-中的50代表的涵义" class="headerlink" title="MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义"></a>MySQL中varchar与char的区别以及varchar(50)中的50代表的涵义</h3><ul><li>varchar与char的区别<ul><li>CHAR和VARCHAR类型在存储和检索方面有所不同，CHAR是一种固定长度的类型，VARCHAR则是一种可变长度的类型。</li><li>CHAR列长度固定为创建表时声明的长度，长度值范围是1到255当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格。</li></ul></li><li>varchar(50)中50的涵义<ul><li>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)</li></ul></li><li>int（20）中20的涵义<ul><li>是指显示字符的长度但要加参数的，最大为255，比如它是记录行数的id,插入10笔资料，它就显示00000000001 <del>~</del>00000000010，当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，它不会在前面加0</li><li>20表示最大显示宽度为20，但仍占4字节存储，存储范围不变。</li></ul></li><li>mysql为什么这么设计<ul><li>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样。</li></ul></li></ul><h3 id="问了innodb的事务与日志的实现方式"><a href="#问了innodb的事务与日志的实现方式" class="headerlink" title="问了innodb的事务与日志的实现方式"></a>问了innodb的事务与日志的实现方式</h3><ol><li>有多少种日志？<ol><li><strong>错误日志</strong>：记录出错信息，也记录一些警告信息或者正确的信息。</li><li><strong>查询日志</strong>：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。</li><li><strong>慢查询日志</strong>：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。</li><li><strong>二进制日志</strong>：记录对数据库执行更改的所有操作。</li><li><strong>中继日志</strong>：中继日志也是二进制日志，用来给slave 库恢复</li><li><strong>事务日志</strong>：重做日志redo和回滚日志undo</li></ol></li><li>事务是如何通过日志来实现的。</li><li>事务日志是通过redo和innodb的存储引擎日志缓冲（Innodb log buffer）来实现的，当开始一个事务的时候，会记录该事务的lsn(log sequence number)号; 当事务执行时，会往InnoDB存储引擎的日志的日志缓存里面插入事务日志；当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”。</li></ol><h3 id="SQL优化explain"><a href="#SQL优化explain" class="headerlink" title="SQL优化explain"></a>SQL优化explain</h3><ul><li>explain出来的各种item的意义；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select_type</span><br></pre></td></tr></table></figure><ul><li>表示查询中每个select子句的类型，有几种值：simple（表示简单的select，没有union和子查询），primary（有子查询，最外面的select查询就是primary），union（union中的第二个或随后的select查询，不依赖外部查询结果），dependent union（union中的第二个或随后的select查询，依赖外部查询结果）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type</span><br></pre></td></tr></table></figure><ul><li>表示MySQL在表中找到所需行的方式，又称“访问类型”，有几种值：system（表仅有一行（=系统表），这是const连接类型的一个特例），const（常量查询）, ref(非唯一索引访问，只有普通索引)，eq_ref（使用唯一索引或组件查询），all（全表查询），index（根据索引查询全表），range（范围查询）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">possible_keys</span><br></pre></td></tr></table></figure><ul><li>指出MySQL能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key</span><br></pre></td></tr></table></figure><ul><li>显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_len</span><br></pre></td></tr></table></figure><ul><li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref</span><br></pre></td></tr></table></figure><ul><li>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Extra</span><br></pre></td></tr></table></figure><ul><li><p>包含不适合在其他列中显示但十分重要的额外信息</p></li><li><p>profile的意义以及使用场景；</p></li></ul><blockquote><p>查询到 SQL 会执行多少时间, 并看出 CPU/Memory 使用量, 执行过程中 Systemlock, Table lock 花多少时间等等。</p></blockquote><h3 id="innodb的读写参数优化"><a href="#innodb的读写参数优化" class="headerlink" title="innodb的读写参数优化"></a>innodb的读写参数优化</h3><ul><li>读取参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global buffer pool以及 local buffer；</span><br></pre></td></tr></table></figure><ul><li>写入参数；</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit</span><br><span class="line"></span><br><span class="line">innodb_buffer_pool_size</span><br></pre></td></tr></table></figure><ul><li>与IO相关的参数；</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">innodb_write_io_threads = 8</span><br><span class="line"></span><br><span class="line">innodb_read_io_threads = 8</span><br><span class="line"></span><br><span class="line">innodb_thread_concurrency = 0</span><br></pre></td></tr></table></figure><ul><li>缓存参数以及缓存的适用场景。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query <span class="keyword">cache</span>/query_cache_type</span><br></pre></td></tr></table></figure><p>并不是所有表都适合使用query cache。造成query cache失效的原因主要是相应的table发生了变更</p><ul><li><p><strong>第一个</strong>：读操作多的话看看比例，简单来说，如果是用户清单表，或者说是数据比例比较固定，比如说商品列表，是可以打开的，前提是这些库比较集中，数据库中的实务比较小。</p></li><li><p><strong>第二个</strong>：我们“行骗”的时候，比如说我们竞标的时候压测，把query cache打开，还是能收到qps激增的效果，当然前提示前端的连接池什么的都配置一样。大部分情况下如果写入的居多，访问量并不多，那么就不要打开，例如社交网站的，10%的人产生内容，其余的90%都在消费，打开还是效果很好的，但是你如果是qq消息，或者聊天，那就很要命。</p></li><li><p><strong>第三个</strong>：小网站或者没有高并发的无所谓，高并发下，会看到 很多 qcache 锁 等待，所以一般高并发下，不建议打开query cache。</p></li></ul><h3 id="表中有大字段X-例如：text类型-，且字段X不会经常更新，以读为为主，请问"><a href="#表中有大字段X-例如：text类型-，且字段X不会经常更新，以读为为主，请问" class="headerlink" title="表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问"></a>表中有大字段X(例如：text类型)，且字段X不会经常更新，以读为为主，请问</h3><blockquote><p>拆带来的问题：连接消耗 + 存储拆分空间；不拆可能带来的问题：查询性能；</p></blockquote><ul><li>1、如果能容忍拆分带来的空间问题,拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序IO,减少连接消耗,最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗</li><li>2、如果能容忍不拆分带来的查询性能损失的话:上面的方案在某个极致条件下肯定会出现问题,那么不拆就是最好的选择。</li></ul><h3 id="MySQL中InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？"><a href="#MySQL中InnoDB引擎的行锁是通过加在什么上完成-或称实现-的？为什么是这样子的？" class="headerlink" title="MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？"></a>MySQL中InnoDB引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？</h3><blockquote><p>InnoDB是基于索引来完成行锁</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例:  --</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tab_with_index <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="comment">-- for update 可以根据条件来完成行锁锁定,并且 id 是有索引键的列-- </span></span><br><span class="line"><span class="comment">-- 如果 id 不是索引键那么InnoDB将完成表锁,,并发将无从谈起--</span></span><br></pre></td></tr></table></figure><h3 id="什么是存储过程？有哪些优缺点？"><a href="#什么是存储过程？有哪些优缺点？" class="headerlink" title="什么是存储过程？有哪些优缺点？"></a>什么是存储过程？有哪些优缺点？</h3><p>存储过程是一些预编译的SQL语句。</p><ul><li>1、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。</li><li>2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全。</li></ul><h3 id="索引是什么？有什么作用以及优缺点？"><a href="#索引是什么？有什么作用以及优缺点？" class="headerlink" title="索引是什么？有什么作用以及优缺点？"></a>索引是什么？有什么作用以及优缺点？</h3><ul><li><p>1、索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构</p></li><li><p>2、索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。</p></li><li><p>MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引</p><ol><li>索引加快数据库的检索速度。</li><li>索引降低了插入、删除、修改等维护任务的速度。</li><li>唯一索引可以确保每一行数据的唯一性。</li><li>通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。</li><li>索引需要占物理和数据空间。</li></ol></li></ul><h3 id="使用索引查询一定能提高查询的性能吗？为什么"><a href="#使用索引查询一定能提高查询的性能吗？为什么" class="headerlink" title="使用索引查询一定能提高查询的性能吗？为什么"></a>使用索引查询一定能提高查询的性能吗？为什么</h3><blockquote><p>通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价.</p></blockquote><ul><li>索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li><li>基于一个范围的检索,一般查询返回结果集小于表中记录数的30%</li><li>基于非唯一性索引的检索</li></ul><h3 id="简单说一说drop、delete与truncate的区"><a href="#简单说一说drop、delete与truncate的区" class="headerlink" title="简单说一说drop、delete与truncate的区"></a>简单说一说drop、delete与truncate的区</h3><blockquote><p>SQL中的drop、delete、truncate都表示删除，但是三者有一些差别</p></blockquote><ul><li>delete和truncate只删除表的数据不删除表的结构</li><li>速度,一般来说: drop&gt; truncate &gt;delete</li><li>delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;</li><li>如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger。</li></ul><h3 id="drop、delete与truncate分别在什么场景之下使用？"><a href="#drop、delete与truncate分别在什么场景之下使用？" class="headerlink" title="drop、delete与truncate分别在什么场景之下使用？"></a>drop、delete与truncate分别在什么场景之下使用？</h3><ul><li>1、不再需要一张表的时候，用drop</li><li>2、想删除部分数据行时候，用delete，并且带上where子句</li><li>3、保留表而删除所有数据的时候用truncate</li></ul><h3 id="数据库的乐观锁和悲观锁是什么？"><a href="#数据库的乐观锁和悲观锁是什么？" class="headerlink" title="数据库的乐观锁和悲观锁是什么？"></a>数据库的乐观锁和悲观锁是什么？</h3><blockquote><p>数据库通过锁机制来解决并发场景-共享锁（读锁）和排他锁（写锁）。读锁是不阻塞的，多个客户端可以在同一时刻读取同一个资源。写锁是排他的，并且会阻塞其他的读锁和写锁。简单提下乐观锁和悲观锁。</p></blockquote><ul><li><p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p><ul><li><strong>表锁</strong>，锁定整张表，开销最小，但是会加剧锁竞争。</li><li><strong>行锁</strong>，锁定行级别，开销最大，但是可以最大程度的支持并发。</li><li>共享锁（多个事物共享）共享锁也叫读锁或 S 锁。</li><li>排它锁（单个事物占有）排它锁也独占锁、写锁或 X 锁</li></ul></li><li><p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p><ul><li>不过通过数据库的版本机制实现，通过版本号字段或者时间戳字段来实现。</li></ul></li></ul><h3 id="InnoDB的MVCC的机制是什么"><a href="#InnoDB的MVCC的机制是什么" class="headerlink" title="InnoDB的MVCC的机制是什么"></a>InnoDB的MVCC的机制是什么</h3><blockquote><p>MVCC 的英文全称是 Multiversion Concurrency Control，中文翻译过来就是多版本并发控制技术。从名字中也能看出来，MVCC 是通过数据行的多个版本管理来实现数据库的并发控制，简单来说它的思想就是保存数据的历史版本。这样我们就可以通过比较版本号决定数据是否显示出来（具体的规则后面会介绍到），读取数据的时候不需要加锁也可以保证事务的隔离效果。</p></blockquote><ul><li>通过 MVCC 我们可以解决以下几个问题：</li></ul><ol><li>读写之间阻塞的问题，通过 MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。</li><li>降低了死锁的概率。这是因为 MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。</li><li>解决一致性读的问题。一致性读也被称为快照读，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。</li></ol><blockquote><p>在了解 InnoDB 中 MVCC 的实现方式之前，我们需要了解 InnoDB 是如何存储记录的多个版本的。这里的多版本对应的就是 MVCC 前两个字母的释义：Multi Version，我们需要了解和它相关的数据都有哪些，存储在哪里。这些数据包括事务版本号、行记录中的隐藏列和 Undo Log。</p></blockquote><ol><li>事务版本号每开启一个事务，我们都会从数据库中获得一个事务 ID（也就是事务版本号），这个事务 ID 是自增长的，通过 ID 大小，我们就可以判断事务的时间顺序。</li><li>行记录的隐藏列InnoDB 的叶子段存储了数据页，数据页中保存了行记录，而在行记录中有一些重要的隐藏字段。</li></ol><blockquote><p>MVCC 的核心就是 Undo Log+ Read View，“MV”就是通过 Undo Log 来保存数据的历史版本，实现多版本的管理，“CC”是通过 Read View 来实现管理，通过 Read View 原则来决定数据是否显示。同时针对不同的隔离级别，Read View 的生成策略不同，也就实现了不同的隔离级别。</p></blockquote><h3 id="表空间、段、区、数据页是什么？"><a href="#表空间、段、区、数据页是什么？" class="headerlink" title="表空间、段、区、数据页是什么？"></a>表空间、段、区、数据页是什么？</h3><blockquote><p>记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。因此在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page）。</p></blockquote><ol><li>一个页中可以存储多个行记录（Row），同时在数据库中，还存在着区（Extent）、段（Segment）和表空间（Tablespace）。行、页、区、段、表空间的关系如下图所示：</li></ol><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/MysqlInnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"></p><h3 id="快照读与当前读区别"><a href="#快照读与当前读区别" class="headerlink" title="快照读与当前读区别"></a>快照读与当前读区别</h3><ol><li>快照读读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，比如这样：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player_users <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></table></figure><ol start="2"><li>当前读就是读取最新数据，而不是历史版本的数据。加锁的 SELECT，或者对数据进行增删改都会进行当前读，比如：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里加的是读锁。</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> player_users <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br></pre></td></tr></table></figure><h3 id="谈谈-SQL-优化的经验"><a href="#谈谈-SQL-优化的经验" class="headerlink" title="谈谈 SQL 优化的经验"></a>谈谈 SQL 优化的经验</h3><ul><li>查询语句无论是使用哪种判断条件 <strong>等于、小于、大于</strong>， <code>WHERE</code> 左侧的条件查询字段不要使用函数或者表达式</li><li>使用 <code>EXPLAIN</code> 命令优化你的 SELECT 查询，对于复杂、效率低的 sql 语句，我们通常是使用 explain sql 来分析这条 sql 语句，这样方便我们分析，进行优化。</li><li>当你的 SELECT 查询语句只需要使用一条记录时，要使用 <code>LIMIT 1</code></li><li>不要直接使用 <code>SELECT *</code>，而应该使用具体需要查询的表字段，因为使用 EXPLAIN 进行分析时，SELECT * 使用的是全表扫描，也就是 <code>type = all</code>。</li><li>为每一张表设置一个 ID 属性</li><li>避免在 <code>WHERE</code> 字句中对字段进行 <code>NULL</code> 判断</li><li>避免在 <code>WHERE</code> 中使用 <code>!=</code> 或 <code>&lt;&gt;</code> 操作符</li><li>使用 <code>BETWEEN AND</code> 替代 <code>IN</code></li><li>为搜索字段创建索引,大字段类型不要建立索引。</li><li>选择正确的存储引擎，InnoDB 、MyISAM 、MEMORY 等</li><li>使用 <code>LIKE %abc%</code> 不会走索引，而使用 <code>LIKE abc%</code> 会走索引</li><li>对于枚举类型的字段(即有固定罗列值的字段)，建议使用<code>ENUM</code>而不是<code>VARCHAR</code>，如性别、星期、类型、类别等</li><li>拆分大的 DELETE 或 INSERT 语句</li><li>选择合适的字段类型，选择标准是 <strong>尽可能小、尽可能定长、尽可能使用整数</strong>。</li><li>字段设计尽可能使用 <code>NOT NULL</code></li><li>进行水平切割或者垂直分割</li></ul><h3 id="开放性问题"><a href="#开放性问题" class="headerlink" title="开放性问题"></a>开放性问题</h3><p>一个6亿的表a，一个3亿的表b，通过外间tid关联，你如何最快的查询出满足条件的第50000到第50200中的这200条数据记录。</p><ul><li>1、如果A表TID是自增长,并且是连续的,B表的ID为索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> a,b <span class="keyword">where</span> a.tid = b.id <span class="keyword">and</span> a.tid&gt;<span class="number">500000</span> <span class="keyword">limit</span> <span class="number">200</span>;</span><br></pre></td></tr></table></figure><ul><li>2、如果A表的TID不是连续的,那么就需要使用覆盖索引.TID要么是主键,要么是辅助索引,B表ID也需要有索引。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> b , (<span class="keyword">select</span> tid <span class="keyword">from</span> a <span class="keyword">limit</span> <span class="number">50000</span>,<span class="number">200</span>) a <span class="keyword">where</span> b.id = a .tid;</span><br></pre></td></tr></table></figure><h3 id="MySQL-binlog的几种日志录入格式以及区别"><a href="#MySQL-binlog的几种日志录入格式以及区别" class="headerlink" title="MySQL binlog的几种日志录入格式以及区别"></a>MySQL binlog的几种日志录入格式以及区别</h3><blockquote><p><strong>Statement</strong>：每一条会修改数据的sql都会记录在binlog中。</p></blockquote><ul><li><p><strong>优点</strong>：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。(相比row能节约多少性能 与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入row格式所产生的日志量还小于Statement产生的日志量，但是考虑到如果带条 件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所 产生的日志量会增加多少，以及带来的IO性能问题。)</p></li><li><p><strong>缺点</strong>：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的 一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同 的结果。另外mysql 的复制,像一些特定函数功能，slave可与master上要保持一致会有很多相关问题(如sleep()函数， last_insert_id()，以及user-defined functions(udf)会出现问题).</p></li></ul><p><strong>使用以下函数的语句也无法被复制</strong>：</p><ul><li>LOAD_FILE()</li><li>UUID()</li><li>USER()</li><li>FOUND_ROWS()</li><li>SYSDATE() (除非启动时启用了 –sysdate-is-now 选项)</li></ul><p>同时在INSERT …SELECT 会产生比 RBR 更多的行级锁</p><p><strong>Row</strong>:不记录sql语句上下文相关信息，仅保存哪条记录被修改。</p><ul><li><p><strong>优点</strong>： binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下 每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题</p></li><li><p><strong>缺点</strong>:所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比 如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。</p></li><li><p><strong>Mixedlevel</strong>: 是以上两种level的混合使用，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则 采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择 一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。</p></li></ul><h3 id="MySQL数据库cpu飙升到500-的话他怎么处理？"><a href="#MySQL数据库cpu飙升到500-的话他怎么处理？" class="headerlink" title="MySQL数据库cpu飙升到500%的话他怎么处理？"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h3><ul><li>列出所有进程 show processlist,观察所有进程 ,多秒没有状态变化的(干掉)</li><li>查看超时日志或者错误日志 (一般会是查询以及大批量的插入会导致cpu与i/o上涨,当然不排除网络状态突然断了,导致一个请求服务器只接受到一半，比如where子句或分页子句没有发送,,当然的一次被坑经历)。</li></ul><h3 id="备份计划，mysqldump以及xtranbackup的实现原理"><a href="#备份计划，mysqldump以及xtranbackup的实现原理" class="headerlink" title="备份计划，mysqldump以及xtranbackup的实现原理"></a>备份计划，mysqldump以及xtranbackup的实现原理</h3><ul><li><p>备份计划</p><ul><li>这里每个公司都不一样</li></ul></li><li><p>备份恢复时间,这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</p><ul><li><p>20G的2分钟（mysqldump）</p></li><li><p>80G的30分钟(mysqldump)</p></li><li><p>111G的30分钟（mysqldump)</p></li><li><p>288G的3小时（xtra)</p></li><li><p>3T的4小时（xtra)</p></li><li><p>逻辑导入时间一般是备份时间的5倍以上</p></li></ul></li><li><p>xtrabackup实现原理</p><ul><li>在InnoDB内部会维护一个redo日志文件，我们也可以叫做事务日志文件。事务日志会存储每一个InnoDB表数据的记录修改。当InnoDB启动时，InnoDB会检查数据文件和事务日志，并执行两个步骤：它应用（前滚）已经提交的事务日志到数据文件，并将修改过但没有提交的数据进行回滚操作。</li></ul></li></ul><h3 id="mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert…-value-的话，怎么办？如果备份需要带上master的复制点信息怎么办？"><a href="#mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert…-value-的话，怎么办？如果备份需要带上master的复制点信息怎么办？" class="headerlink" title="mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert….value()的话，怎么办？如果备份需要带上master的复制点信息怎么办？"></a>mysqldump中备份出来的sql，如果我想sql文件中，一行只有一个insert….value()的话，怎么办？如果备份需要带上master的复制点信息怎么办？</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--skip-extended-insert</span></span><br><span class="line"></span><br><span class="line">[root@helei-zhuanshu ~]<span class="comment"># mysqldump -uroot -p helei --skip-extended-insert</span></span><br><span class="line"></span><br><span class="line">Enter password:</span><br><span class="line"></span><br><span class="line">KEY `idx_c1` (`c1`),</span><br><span class="line"></span><br><span class="line">KEY `idx_c2` (`c2`)</span><br><span class="line"></span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=51 DEFAULT CHARSET=latin1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = @saved_cs_client */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Dumping data for table `helei`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLES</span> <span class="string">`helei`</span> WRITE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*!40000 ALTER TABLE `helei` DISABLE KEYS */</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`helei`</span> <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">32</span>,<span class="number">37</span>,<span class="number">38</span>,<span class="string">'2016-10-18 06:19:24'</span>,<span class="string">'susususususususususususu'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`helei`</span> <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">37</span>,<span class="number">46</span>,<span class="number">21</span>,<span class="string">'2016-10-18 06:19:24'</span>,<span class="string">'susususususu'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`helei`</span> <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="number">21</span>,<span class="number">5</span>,<span class="number">14</span>,<span class="string">'2016-10-18 06:19:24'</span>,<span class="string">'susu'</span>);</span><br></pre></td></tr></table></figure><h3 id="你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"><a href="#你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？" class="headerlink" title="你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？"></a>你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？</h3><ul><li>主从一致性校验有多种工具 例如checksum、mysqldiff、pt-table-checksum等。</li></ul><h3 id="你们数据库是否支持emoji表情，如果不支持，如何操作？"><a href="#你们数据库是否支持emoji表情，如果不支持，如何操作？" class="headerlink" title="你们数据库是否支持emoji表情，如果不支持，如何操作？"></a>你们数据库是否支持emoji表情，如果不支持，如何操作？</h3><ul><li>如果是utf8字符集的话，需要升级至utf8_mb4方可支持。</li></ul><h3 id="什么是视图？以及视图的使用场景有哪些？"><a href="#什么是视图？以及视图的使用场景有哪些？" class="headerlink" title="什么是视图？以及视图的使用场景有哪些？"></a>什么是视图？以及视图的使用场景有哪些？</h3><ul><li>1、视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</li><li>2、只暴露部分字段给访问者，所以就建一个虚表，就是视图。</li><li>3、查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本章属于持续学习、长期更修。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;数据库的三范式是什么&quot;&gt;&lt;a href=&quot;#数据库的三范式是什么&quot; class=&quot;headerlink&quot; title=&quot;数据库的三范式是什么&quot;&gt;&lt;/a&gt;数据库的三范式是什么&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;第一范式：列不可再分&lt;/li&gt;
&lt;li&gt;第二范式：行可以唯一区分，主键约束&lt;/li&gt;
&lt;li&gt;第三范式：表的非主属性不能依赖与其他表的非主属性 外键约束&lt;/li&gt;
&lt;li&gt;且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上。&lt;/li&gt;
&lt;li&gt;第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。&lt;/li&gt;
&lt;li&gt;第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。&lt;/li&gt;
&lt;li&gt;第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;说下mysql有几种数据库引擎&quot;&gt;&lt;a href=&quot;#说下mysql有几种数据库引擎&quot; class=&quot;headerlink&quot; title=&quot;说下mysql有几种数据库引擎&quot;&gt;&lt;/a&gt;说下mysql有几种数据库引擎&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;不清楚，因为每个版本发布都会新增一些。但是我最熟悉是的innodb。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;说下mysql-Master-slave-的原理&quot;&gt;&lt;a href=&quot;#说下mysql-Master-slave-的原理&quot; class=&quot;headerlink&quot; title=&quot;说下mysql Master slave 的原理&quot;&gt;&lt;/a&gt;说下mysql Master slave 的原理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;主&lt;/strong&gt;：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;从&lt;/strong&gt;：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;从&lt;/strong&gt;：sql执行线程——执行relay log中的语句；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;MySQL中myisam与innodb的区别&quot;&gt;&lt;a href=&quot;#MySQL中myisam与innodb的区别&quot; class=&quot;headerlink&quot; title=&quot;MySQL中myisam与innodb的区别&quot;&gt;&lt;/a&gt;MySQL中myisam与innodb的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;InnoDB支持事物，而MyISAM不支持事物&lt;/li&gt;
&lt;li&gt;InnoDB支持行级锁，而MyISAM支持表级锁&lt;/li&gt;
&lt;li&gt;InnoDB支持MVCC, 而MyISAM不支持&lt;/li&gt;
&lt;li&gt;InnoDB支持外键，而MyISAM不支持&lt;/li&gt;
&lt;li&gt;InnoDB不支持全文索引，而MyISAM支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;innodb引擎的4大特性&quot;&gt;&lt;a href=&quot;#innodb引擎的4大特性&quot; class=&quot;headerlink&quot; title=&quot;innodb引擎的4大特性&quot;&gt;&lt;/a&gt;innodb引擎的4大特性&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;插入缓冲（insert buffer),&lt;/li&gt;
&lt;li&gt;二次写(double write),&lt;/li&gt;
&lt;li&gt;自适应哈希索引(ahi),&lt;/li&gt;
&lt;li&gt;预读(read ahead)&lt;/li&gt;
&lt;li&gt;支持事务操作，具有事务 ACID 隔离特性，默认的隔离级别是&lt;code&gt;可重复读(repetable-read)&lt;/code&gt;、通过MVCC（并发版本控制）来实现的。能够解决&lt;code&gt;脏读&lt;/code&gt;和&lt;code&gt;不可重复读&lt;/code&gt;的问题。&lt;/li&gt;
&lt;li&gt;InnoDB 支持外键操作。&lt;/li&gt;
&lt;li&gt;InnoDB 默认的锁粒度&lt;code&gt;行级锁&lt;/code&gt;，并发性能比较好，会发生死锁的情况。&lt;/li&gt;
&lt;li&gt;和 MyISAM 一样的是，InnoDB 存储引擎也有 &lt;code&gt;.frm文件存储表结构&lt;/code&gt; 定义，但是不同的是，InnoDB 的表数据与索引数据是存储在一起的，都位于 B+ 数的叶子节点上，而 MyISAM 的表数据和索引数据是分开的。&lt;/li&gt;
&lt;li&gt;InnoDB 有安全的日志文件，这个日志文件用于恢复因数据库崩溃或其他情况导致的数据丢失问题，保证数据的一致性。&lt;/li&gt;
&lt;li&gt;InnoDB 和 MyISAM 支持的索引类型相同，但具体实现因为文件结构的不同有很大差异。&lt;/li&gt;
&lt;li&gt;增删改查性能方面，如果执行大量的增删改操作，推荐使用 InnoDB 存储引擎，它在删除操作时是对行删除，不会重建表。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;什么是事务？&quot;&gt;&lt;a href=&quot;#什么是事务？&quot; class=&quot;headerlink&quot; title=&quot;什么是事务？&quot;&gt;&lt;/a&gt;什么是事务？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;覆盖索引和回表&quot;&gt;&lt;a href=&quot;#覆盖索引和回表&quot; class=&quot;headerlink&quot; title=&quot;覆盖索引和回表&quot;&gt;&lt;/a&gt;覆盖索引和回表&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;覆盖索引指的是在一次查询中，如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为覆盖索引，而不再需要回表查询。而要确定一个查询是否是覆盖索引，我们只需要explain sql语句看Extra的结果是否是“Using index”即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;MySQL-事务四大特性&quot;&gt;&lt;a href=&quot;#MySQL-事务四大特性&quot; class=&quot;headerlink&quot; title=&quot;MySQL 事务四大特性&quot;&gt;&lt;/a&gt;MySQL 事务四大特性&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;一说到 MySQL 事务，你肯定能想起来四大特性：&lt;code&gt;原子性&lt;/code&gt;、&lt;code&gt;一致性&lt;/code&gt;、&lt;code&gt;隔离性&lt;/code&gt;、&lt;code&gt;持久性&lt;/code&gt;。什么是 MySQL 中的事务？&lt;/p&gt;
&lt;p&gt;事务是一组操作，组成这组操作的各个单元，要不全都成功要不全都失败，这个特性就是事务。&lt;/p&gt;
&lt;p&gt;在 MySQL 中，事务是在引擎层实现的，只有使用 &lt;code&gt;innodb&lt;/code&gt; 引擎的数据库或表才支持事务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;原子性(Atomicity)&lt;/code&gt;: 原子性指的就是 MySQL 中的包含事务的操作要么&lt;code&gt;全部成功&lt;/code&gt;、要么全部&lt;code&gt;失败回滚&lt;/code&gt;，因此事务的操作如果成功就必须要全部应用到数据库，如果操作失败则不能对数据库有任何影响。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;一致性(Consistency)&lt;/code&gt;：一致性指的是一个事务在执行前后其状态一致。比如 A 和 B 加起来的钱一共是 1000 元，那么不管 A 和 B 之间如何转账，转多少次，事务结束后两个用户的钱加起来还得是 1000，这就是事务的一致性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;持久性(Durability)&lt;/code&gt;: 持久性指的是一旦事务提交，那么发生的改变就是永久性的，即使数据库遇到特殊情况比如故障的时候也不会产生干扰。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;隔离性(Isolation)&lt;/code&gt;：当多个事务同时进行时，就有可能出现&lt;code&gt;脏读(dirty read)&lt;/code&gt;、&lt;code&gt;不可重复读(non-repeatable read)&lt;/code&gt;、&lt;code&gt;幻读(phantom read)&lt;/code&gt; 的情况，为了解决这些并发问题，提出了隔离性的概念。&lt;ul&gt;
&lt;li&gt;重点说下隔离性它们分别是&lt;code&gt;读未提交(read uncommitted)&lt;/code&gt;、&lt;code&gt;读已提交(read committed)&lt;/code&gt;、&lt;code&gt;可重复读(repetable read)&lt;/code&gt; 和 &lt;code&gt;串行化(serializable)&lt;/code&gt;。下面分别来解释一下。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;读未提交&lt;/code&gt;：读未提交指的是一个事务在提交之前，它所做的修改就能够被其他事务所看到。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;读已提交&lt;/code&gt;：读已提交指的是一个事务在提交之后，它所做的变更才能够让其他事务看到。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;可重复读&lt;/code&gt;：可重复读指的是一个事务在执行的过程中，看到的数据是和启动时看到的数据是一致的。未提交的变更对其他事务不可见。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;串行化&lt;/code&gt;：顾名思义是对于同一行记录，&lt;code&gt;写&lt;/code&gt;会加&lt;code&gt;写锁&lt;/code&gt;，&lt;code&gt;读&lt;/code&gt;会加&lt;code&gt;读锁&lt;/code&gt;。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;SQL语句的执行顺序&quot;&gt;&lt;a href=&quot;#SQL语句的执行顺序&quot; class=&quot;headerlink&quot; title=&quot;SQL语句的执行顺序&quot;&gt;&lt;/a&gt;SQL语句的执行顺序&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们在编写一个查询语句的时候&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DISTINCT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt; select_list &amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt; left_table &amp;gt; &amp;lt; join_type &amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;JOIN&lt;/span&gt; &amp;lt; right_table &amp;gt; &lt;span class=&quot;keyword&quot;&gt;ON&lt;/span&gt; &amp;lt; join_condition &amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;WHERE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt; where_condition &amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;BY&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt; group_by_list &amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;HAVING&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt; having_condition &amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;BY&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt; order_by_condition &amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;LIMIT&lt;/span&gt; &amp;lt; limit_number &amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ol&gt;
&lt;li&gt;FROM 连接&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;首先，对 SELECT 语句执行查询时，对&lt;code&gt;FROM&lt;/code&gt; 关键字两边的表执行连接，会形成&lt;code&gt;笛卡尔积&lt;/code&gt;，这时候会产生一个&lt;code&gt;虚表VT1(virtual table)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;首先先来解释一下什么是&lt;code&gt;笛卡尔积&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;现在我们有两个集合 A = {0,1} , B = {2,3,4}&lt;/p&gt;
&lt;p&gt;那么，集合 A * B 得到的结果就是&lt;/p&gt;
&lt;p&gt;A * B = {(0,2)、(1,2)、(0,3)、(1,3)、(0,4)、(1,4)};&lt;/p&gt;
&lt;p&gt;B * A = {(2,0)、{2,1}、{3,0}、{3,1}、{4,0}、(4,1)};&lt;/p&gt;
&lt;p&gt;上面 A * B 和 B * A 的结果就可以称为两个集合相乘的 &lt;code&gt;笛卡尔积&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们可以得出结论，A 集合和 B 集合相乘，包含了集合 A 中的元素和集合 B 中元素之和，也就是 A 元素的个数 * B 元素的个数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;ON 过滤&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;然后对 FROM 连接的结果进行 ON 筛选，创建 VT2，把符合记录的条件存在 VT2 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;JOIN 连接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第三步，如果是 &lt;code&gt;OUTER JOIN(left join、right join)&lt;/code&gt; ，那么这一步就将添加外部行，如果是 left join 就把 ON 过滤条件的左表添加进来，如果是 right join ，就把右表添加进来，从而生成新的虚拟表 VT3。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;WHERE 过滤&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第四步，是执行 WHERE 过滤器，对上一步生产的虚拟表引用 WHERE 筛选，生成虚拟表 VT4。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;WHERE 和 ON 的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有外部列，ON 针对过滤的是关联表，主表(保留表)会返回所有的列;&lt;/li&gt;
&lt;li&gt;如果没有添加外部列，两者的效果是一样的;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;应用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对主表的过滤应该使用 WHERE;&lt;/li&gt;
&lt;li&gt;对于关联表，先条件查询后连接则用 ON，先连接后条件查询则用 WHERE;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;GROUP BY&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;根据 group by 字句中的列，会对 VT4 中的记录进行分组操作，产生虚拟机表 VT5。果应用了group by，那么后面的所有步骤都只能得到的 VT5 的列或者是聚合函数（count、sum、avg等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;HAVING&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;紧跟着 GROUP BY 字句后面的是 HAVING，使用 HAVING 过滤，会把符合条件的放在 VT6&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;7&quot;&gt;
&lt;li&gt;SELECT&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;第七步才会执行 SELECT 语句，将 VT6 中的结果按照 SELECT 进行刷选，生成 VT7&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;8&quot;&gt;
&lt;li&gt;DISTINCT&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;在第八步中，会对 TV7 生成的记录进行去重操作，生成 VT8。事实上如果应用了 group by 子句那么 distinct 是多余的，原因同样在于，分组的时候是将列中唯一的值分成一组，同时只为每一组返回一行记录，那么所以的记录都将是不相同的。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;9&quot;&gt;
&lt;li&gt;ORDER BY&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;应用 order by 子句。按照 order_by_condition 排序 VT8，此时返回的一个游标，而不是虚拟表。sql 是基于集合的理论的，集合不会预先对他的行排序，它只是成员的逻辑集合，成员的顺序是无关紧要的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;什么是临时表，何时删除临时表&quot;&gt;&lt;a href=&quot;#什么是临时表，何时删除临时表&quot; class=&quot;headerlink&quot; title=&quot;什么是临时表，何时删除临时表&quot;&gt;&lt;/a&gt;什么是临时表，何时删除临时表&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在 MySQL 中，有三种类型的表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一种是&amp;#96;永久表&amp;#96;，永久表就是创建以后用来长期保存数据的表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一种是&amp;#96;临时表&amp;#96;，临时表也有两类，一种是和永久表一样，只保存临时数据，但是能够长久存在的；还有一种是临时创建的，SQL 语句执行完成就会删除。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一种是&amp;#96;虚表&amp;#96;，虚表其实就是&amp;#96;视图&amp;#96;，数据可能会来自多张表的执行结果。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;MySQL 会在下面这几种情况产生临时表&lt;ul&gt;
&lt;li&gt;使用 UNION 查询：UNION 有两种，一种是&lt;code&gt;UNION&lt;/code&gt; ，一种是 &lt;code&gt;UNION ALL&lt;/code&gt; ，它们都用于联合查询；区别是 使用 UNION 会去掉两个表中的重复数据，相当于对结果集做了一下&lt;code&gt;去重(distinct)&lt;/code&gt;。使用 UNION ALL，则不会排重，返回所有的行。使用 UNION 查询会产生临时表。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;TEMPTABLE 算法&lt;/code&gt;或者是 UNION 查询中的视图。TEMPTABLE 算法是一种创建临时表的算法，它是将结果放置到临时表中，意味这要 MySQL 要先创建好一个临时表，然后将结果放到临时表中去，然后再使用这个临时表进行相应的查询。&lt;/li&gt;
&lt;li&gt;ORDER BY 和 GROUP BY 的子句不一样时也会产生临时表。&lt;/li&gt;
&lt;li&gt;DISTINCT 查询并且加上 ORDER BY 时；&lt;/li&gt;
&lt;li&gt;SQL 用到 SQL_SMALL_RESULT 选项时；如果查询结果比较小的时候，可以加上 SQL_SMALL_RESULT 来优化，产生临时表&lt;/li&gt;
&lt;li&gt;FROM 中的子查询；&lt;/li&gt;
&lt;li&gt;EXPLAIN 查看执行计划结果的 Extra 列中，如果使用 &lt;code&gt;Using Temporary&lt;/code&gt; 就表示会用到临时表。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;介绍下InnoDB存储引擎的B-树索引&quot;&gt;&lt;a href=&quot;#介绍下InnoDB存储引擎的B-树索引&quot; class=&quot;headerlink&quot; title=&quot;介绍下InnoDB存储引擎的B+树索引&quot;&gt;&lt;/a&gt;介绍下InnoDB存储引擎的B+树索引&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;每个索引都对应一棵B+树，B+树分为好多层，最下边一层是叶子节点，其余的是内节点。所有用户记录都存储在B+树的叶子节点，所有目录项记录都存储在内节点。&lt;/li&gt;
&lt;li&gt;InnoDB存储引擎会自动为主键（如果没有它会自动帮我们添加）建立聚簇索引，聚簇索引的叶子节点包含完整的用户记录。&lt;/li&gt;
&lt;li&gt;我们可以为自己感兴趣的列建立二级索引，二级索引的叶子节点包含的用户记录由索引列 + 主键组成，所以如果想通过二级索引来查找完整的用户记录的话，需要通过回表操作，也就是在通过二级索引找到主键值之后再到聚簇索引中查找完整的用户记录。&lt;/li&gt;
&lt;li&gt;B+树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是联合索引的话，则页面和记录先按照联合索引前边的列排序，如果该列值相同，再按照联合索引后边的列排序。&lt;/li&gt;
&lt;li&gt;通过索引查找记录是从B+树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了Page Directory（页目录），所以在这些页面中的查找非常快。&lt;/li&gt;
&lt;li&gt;二者SELECT COUNT(*)哪个更快，为什么&lt;ul&gt;
&lt;li&gt;myisam更快，因为myisam内部维护了一个计数器，可以直接调取。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://z201.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Mysql" scheme="https://z201.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>面试题-线程池</title>
    <link href="https://z201.github.io/2020/07/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://z201.github.io/2020/07/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-06-30T18:12:50.000Z</published>
    <updated>2020-08-15T01:06:01.836Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章属于持续学习、长期更修。</p></blockquote><ul><li><a href="https://z201.cn/2020/07/30/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">面试题-多线程</a></li></ul><blockquote><p>为避免线程频繁创建和销毁带来的性能问题，而池化的一种方案。</p></blockquote><ul><li><p>利用线程池管理并复用线程、控制最大并发数等。</p></li><li><p>实现任务线程队列缓存策略和拒绝机制。</p></li><li><p>实现某些与时间相关的功能，如定时执行、周期执行等。</p></li><li><p>隔离线程环境。比如，交易服务和搜索服务在同一台服务器上，分别开启两个线程池，交易线程的资源消耗明显要大；因此，通过配置独立的线程池将较慢的交易服务与搜索服务隔离开，避免各服务线程相互影响。</p></li></ul><blockquote><p>这里直接参考阿里巴巴的手册。线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的读者更加明确线程池的运行规则，规避资源耗尽的风险。</p></blockquote><h3 id="常⽤线程池：ExecutorService-是主要的实现类"><a href="#常⽤线程池：ExecutorService-是主要的实现类" class="headerlink" title="常⽤线程池：ExecutorService 是主要的实现类"></a>常⽤线程池：ExecutorService 是主要的实现类</h3><ul><li>Executors.newSingleT hreadPool()</li><li>newFixedThreadPool()</li><li>newcachedTheadPool()</li><li>newScheduledThreadPool()</li></ul><h3 id="Executors-返回的线程池对象的弊端"><a href="#Executors-返回的线程池对象的弊端" class="headerlink" title="Executors 返回的线程池对象的弊端"></a>Executors 返回的线程池对象的弊端</h3><ul><li>FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</li><li>CachedThreadPool 和 ScheduledThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</li><li>查看 Executors 的源码会发现，Executors.newFixedThreadPool()、Executors.newSingleThreadExecutor() 和 Executors.newCachedThreadPool() 等方法的底层都是通过 ThreadPoolExecutor 实现的。</li></ul><h3 id="ThreadPoolExecutor的核心参数"><a href="#ThreadPoolExecutor的核心参数" class="headerlink" title="ThreadPoolExecutor的核心参数"></a>ThreadPoolExecutor的核心参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        <span class="comment">// maximumPoolSize 必须大于 0，且必须大于 corePoolSize</span></span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第 1 个参数：corePoolSize 表示线程池的常驻核心线程数。如果设置为 0，则表示在没有任何任务时，销毁线程池；如果大于 0，即使没有任务时也会保证线程池的线程数量等于此值。但需要注意，此值如果设置的比较小，则会频繁的创建和销毁线程（创建和销毁的原因会在本课时的下半部分讲到）；如果设置的比较大，则会浪费系统资源，所以开发者需要根据自己的实际业务来调整此值。</li><li>第 2 个参数：maximumPoolSize 表示线程池在任务最多时，最大可以创建的线程数。官方规定此值必须大于 0，也必须大于等于 corePoolSize，此值只有在任务比较多，且不能存放在任务队列时，才会用到。</li><li>第 3 个参数：keepAliveTime 表示线程的存活时间，当线程池空闲时并且超过了此时间，多余的线程就会销毁，直到线程池中的线程数量销毁的等于 corePoolSize 为止，如果 maximumPoolSize 等于 corePoolSize，那么线程池在空闲的时候也不会销毁任何线程。</li><li>第 4 个参数：unit 表示存活时间的单位，它是配合 keepAliveTime 参数共同使用的。</li><li>第 5 个参数：workQueue 表示线程池执行的任务队列，当线程池的所有线程都在处理任务时，如果来了新任务就会缓存到此任务队列中排队等待执行。</li><li>第 6 个参数：threadFactory 表示线程的创建工厂，此参数一般用的比较少，我们通常在创建线程池时不指定此参数，它会使用默认的线程创建工厂的方法来创建线程。</li><li>第 7 个参数：RejectedExecutionHandler 表示指定线程池的拒绝策略，当线程池的任务已经在缓存队列 workQueue 中存储满了之后，并且不能创建新的线程来执行此任务时，就会用到此拒绝策略，它属于一种限流保护的机制。</li><li>原理<ul><li>如果当前池⼤⼩ poolSize ⼩于 corePoolSize，则创建新线程执⾏任务。</li><li>如果当前池⼤⼩poolSize⼤于corePoolSize，且等待队列未满，则进⼊等待队列。</li><li>如果当前池⼤⼩ poolSize ⼤于 corePoolSize 且⼩于 maximumPoolSize ，且等待队列已满，则创建新线程执⾏任务。</li><li>如果当前池⼤⼩ poolSize ⼤于 corePoolSize 且⼤于 maximumPoolSize ，且等待队列已满，则调⽤拒绝策略来处理该任务。<ul><li>线程池⾥的每个线程执⾏完任务后不会⽴刻退出，⽽是会去检查下等待队列⾥是否还有线程任务需要执⾏，如果在 keepAliveTime ⾥等不到新的任务了，那么线程就会退出。</li></ul></li></ul></li><li><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong><ul><li><strong><code>corePoolSize</code> :</strong> 核心线程数线程数定义了最小可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul></li></ul><a id="more"></a><h3 id="线程池任务执行的主要流程"><a href="#线程池任务执行的主要流程" class="headerlink" title="线程池任务执行的主要流程"></a>线程池任务执行的主要流程</h3><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B.png"></p><h3 id="execute-VS-submit"><a href="#execute-VS-submit" class="headerlink" title="execute() VS submit()"></a>execute() VS submit()</h3><blockquote><p>execute() 和 submit() 都是用来执行线程池任务的，它们最主要的区别是，submit() 方法可以接收线程池执行的返回值，而 execute() 不能接收返回值。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">10</span>, <span class="number">10L</span>,</span><br><span class="line">        TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">20</span>));</span><br><span class="line"><span class="comment">// execute 使用</span></span><br><span class="line">executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, execute."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// submit 使用</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, submit."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(future.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行结果</span></span><br><span class="line"><span class="comment">//Hello, submit.</span></span><br><span class="line"><span class="comment">//Hello, execute.</span></span><br><span class="line"><span class="comment">//Success</span></span><br></pre></td></tr></table></figure><h3 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h3><blockquote><p>当线程池中的任务队列已经被存满，再有任务添加时会先判断当前线程池中的线程数是否大于等于线程池的最大值，如果是，则会触发线程池的拒绝策略。</p></blockquote><ul><li><p>Java 自带的拒绝策略有 4 种：</p></li><li><p>AbortPolicy，终止策略，线程池会抛出异常并终止执行，它是默认的拒绝策略。</p></li><li><p>CallerRunsPolicy，把任务交给当前线程来执行。</p></li><li><p>DiscardPolicy，忽略此任务（最新的任务）。</p></li><li><p>DiscardOldestPolicy，忽略最早的任务（最先加入队列的任务）。</p></li><li><p>演示AbortPolicy</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>,</span><br><span class="line">        TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()); <span class="comment">// 添加 AbortPolicy 拒绝策略</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-1</span><br><span class="line">pool-1-thread-3</span><br><span class="line">pool-1-thread-2</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task com.lagou.interview.ThreadPoolExample$$Lambda$1&#x2F;1096979270@448139f0 rejected from java.util.concurrent.ThreadPoolExecutor@7cca494b[Running, pool size &#x3D; 3, active threads &#x3D; 3, queued tasks &#x3D; 2, completed tasks &#x3D; 0]</span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063)</span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830)</span><br><span class="line"> at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379)</span><br><span class="line"> at com.lagou.interview.ThreadPoolExample.rejected(ThreadPoolExample.java:35)</span><br><span class="line"> at com.lagou.interview.ThreadPoolExample.main(ThreadPoolExample.java:26)</span><br></pre></td></tr></table></figure><ul><li>第 6 个任务来的时候，线程池则执行了 AbortPolicy  拒绝策略，抛出了异常。因为队列最多存储 2 个任务，最大可以创建 3 个线程来执行任务（2+3=5），所以当第 6 个任务来的时候，此线程池就“忙”不过来了。</li></ul><h3 id="Java⾥的阻塞队列"><a href="#Java⾥的阻塞队列" class="headerlink" title="Java⾥的阻塞队列"></a><strong>Java</strong>⾥的阻塞队列</h3><ul><li>7个队列阻塞<ul><li><strong>ArrayBlockingQueue</strong> ：⼀个由数组结构组成的有界阻塞队列。</li><li><strong>LinkedBlockingQueue</strong> ：⼀个由链表结构组成的有界阻塞队列。</li><li><strong>PriorityBlockingQueue</strong> ：⼀个⽀持优先级排序的⽆界阻塞队列。</li><li><strong>DelayQueue</strong>：⼀个使⽤优先级队列实现的⽆界阻塞队列。</li><li><strong>SynchronousQueue</strong>：⼀个不存储元素的阻塞队列。</li><li><strong>LinkedTransferQueue</strong>：⼀个由链表结构组成的⽆界阻塞队列。</li><li><strong>LinkedBlockingDeque</strong>：⼀个由链表结构组成的双向阻塞队列。</li></ul></li></ul><h3 id="如果你提交任务时，线程池队列已满。会时发会⽣什么？"><a href="#如果你提交任务时，线程池队列已满。会时发会⽣什么？" class="headerlink" title="如果你提交任务时，线程池队列已满。会时发会⽣什么？"></a>如果你提交任务时，线程池队列已满。会时发会⽣什么？</h3><ul><li>⼀个任务不能被调度执⾏那么ThreadPoolExecutor’s submit()⽅法将会抛出⼀个RejectedExecutionException异常。</li></ul><h3 id="shutdown-与shutdownNow"><a href="#shutdown-与shutdownNow" class="headerlink" title="shutdown()与shutdownNow()"></a><code>shutdown()</code>与<code>shutdownNow()</code></h3><ul><li><strong><code>shutdown（）</code></strong> :关闭线程池，线程池的状态变为 <code>SHUTDOWN</code>。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li><li><strong><code>shutdownNow（）</code></strong> :关闭线程池，线程的状态变为 <code>STOP</code>。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。</li></ul><h3 id="isTerminated-与-isShutdown"><a href="#isTerminated-与-isShutdown" class="headerlink" title="isTerminated() 与 isShutdown()"></a><code>isTerminated()</code> 与 <code>isShutdown()</code></h3><ul><li><strong><code>isShutDown</code></strong> 当调用 <code>shutdown()</code> 方法后返回为 true。</li><li><strong><code>isTerminated</code></strong> 当调用 <code>shutdown()</code> 方法后，并且所有提交的任务完成后返回为 true</li></ul><h3 id="如何合理的配置java线程池？"><a href="#如何合理的配置java线程池？" class="headerlink" title="如何合理的配置java线程池？"></a>如何合理的配置<strong>java</strong>线程池？</h3><ul><li><p>如CPU密集型的任务，基本线程池应该配置多⼤？IO密集型的任务，基本线程池应该配置多⼤？⽤有界队列好还是⽆界队列好？任务⾮常多的时候，使⽤什么阻塞队列能获取最好的吞吐量？</p><ul><li>配置线程池时CPU密集型任务可以少配置线程数，⼤概和机器的cpu核数相当，可以使得每个线程都在执⾏任务。</li><li>IO密集型时，⼤部分线程都阻塞，故需要多配置线程数，2*cpu核数</li><li>有界队列和⽆界队列的配置需区分业务场景，⼀般情况下配置有界队列，在⼀些可能会有爆发性增⻓的情况下使⽤⽆界队列。</li><li>任务⾮常多时，使⽤⾮阻塞队列使⽤CAS操作替代锁可以获得好的吞吐量。</li><li>有一个简单并且适用面比较广的公式：<ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul></li><li><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong><ul><li>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。单凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本章属于持续学习、长期更修。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://z201.cn/2020/07/30/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%A4%9A%E7%BA%BF%E7%A8%8B/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;面试题-多线程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;为避免线程频繁创建和销毁带来的性能问题，而池化的一种方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;利用线程池管理并复用线程、控制最大并发数等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现任务线程队列缓存策略和拒绝机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现某些与时间相关的功能，如定时执行、周期执行等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;隔离线程环境。比如，交易服务和搜索服务在同一台服务器上，分别开启两个线程池，交易线程的资源消耗明显要大；因此，通过配置独立的线程池将较慢的交易服务与搜索服务隔离开，避免各服务线程相互影响。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这里直接参考阿里巴巴的手册。线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的读者更加明确线程池的运行规则，规避资源耗尽的风险。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;常⽤线程池：ExecutorService-是主要的实现类&quot;&gt;&lt;a href=&quot;#常⽤线程池：ExecutorService-是主要的实现类&quot; class=&quot;headerlink&quot; title=&quot;常⽤线程池：ExecutorService 是主要的实现类&quot;&gt;&lt;/a&gt;常⽤线程池：ExecutorService 是主要的实现类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Executors.newSingleT hreadPool()&lt;/li&gt;
&lt;li&gt;newFixedThreadPool()&lt;/li&gt;
&lt;li&gt;newcachedTheadPool()&lt;/li&gt;
&lt;li&gt;newScheduledThreadPool()&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Executors-返回的线程池对象的弊端&quot;&gt;&lt;a href=&quot;#Executors-返回的线程池对象的弊端&quot; class=&quot;headerlink&quot; title=&quot;Executors 返回的线程池对象的弊端&quot;&gt;&lt;/a&gt;Executors 返回的线程池对象的弊端&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。&lt;/li&gt;
&lt;li&gt;CachedThreadPool 和 ScheduledThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。&lt;/li&gt;
&lt;li&gt;查看 Executors 的源码会发现，Executors.newFixedThreadPool()、Executors.newSingleThreadExecutor() 和 Executors.newCachedThreadPool() 等方法的底层都是通过 ThreadPoolExecutor 实现的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;ThreadPoolExecutor的核心参数&quot;&gt;&lt;a href=&quot;#ThreadPoolExecutor的核心参数&quot; class=&quot;headerlink&quot; title=&quot;ThreadPoolExecutor的核心参数&quot;&gt;&lt;/a&gt;ThreadPoolExecutor的核心参数&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; corePoolSize,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maximumPoolSize,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; keepAliveTime,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          TimeUnit unit,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          ThreadFactory threadFactory,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;                          RejectedExecutionHandler handler)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (corePoolSize &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// maximumPoolSize 必须大于 0，且必须大于 corePoolSize&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        maximumPoolSize &amp;lt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        maximumPoolSize &amp;lt; corePoolSize ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        keepAliveTime &amp;lt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; IllegalArgumentException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (workQueue == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || threadFactory == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; || handler == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NullPointerException();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.acc = System.getSecurityManager() == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; ?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            AccessController.getContext();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.corePoolSize = corePoolSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.maximumPoolSize = maximumPoolSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.workQueue = workQueue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.keepAliveTime = unit.toNanos(keepAliveTime);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.threadFactory = threadFactory;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.handler = handler;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;第 1 个参数：corePoolSize 表示线程池的常驻核心线程数。如果设置为 0，则表示在没有任何任务时，销毁线程池；如果大于 0，即使没有任务时也会保证线程池的线程数量等于此值。但需要注意，此值如果设置的比较小，则会频繁的创建和销毁线程（创建和销毁的原因会在本课时的下半部分讲到）；如果设置的比较大，则会浪费系统资源，所以开发者需要根据自己的实际业务来调整此值。&lt;/li&gt;
&lt;li&gt;第 2 个参数：maximumPoolSize 表示线程池在任务最多时，最大可以创建的线程数。官方规定此值必须大于 0，也必须大于等于 corePoolSize，此值只有在任务比较多，且不能存放在任务队列时，才会用到。&lt;/li&gt;
&lt;li&gt;第 3 个参数：keepAliveTime 表示线程的存活时间，当线程池空闲时并且超过了此时间，多余的线程就会销毁，直到线程池中的线程数量销毁的等于 corePoolSize 为止，如果 maximumPoolSize 等于 corePoolSize，那么线程池在空闲的时候也不会销毁任何线程。&lt;/li&gt;
&lt;li&gt;第 4 个参数：unit 表示存活时间的单位，它是配合 keepAliveTime 参数共同使用的。&lt;/li&gt;
&lt;li&gt;第 5 个参数：workQueue 表示线程池执行的任务队列，当线程池的所有线程都在处理任务时，如果来了新任务就会缓存到此任务队列中排队等待执行。&lt;/li&gt;
&lt;li&gt;第 6 个参数：threadFactory 表示线程的创建工厂，此参数一般用的比较少，我们通常在创建线程池时不指定此参数，它会使用默认的线程创建工厂的方法来创建线程。&lt;/li&gt;
&lt;li&gt;第 7 个参数：RejectedExecutionHandler 表示指定线程池的拒绝策略，当线程池的任务已经在缓存队列 workQueue 中存储满了之后，并且不能创建新的线程来执行此任务时，就会用到此拒绝策略，它属于一种限流保护的机制。&lt;/li&gt;
&lt;li&gt;原理&lt;ul&gt;
&lt;li&gt;如果当前池⼤⼩ poolSize ⼩于 corePoolSize，则创建新线程执⾏任务。&lt;/li&gt;
&lt;li&gt;如果当前池⼤⼩poolSize⼤于corePoolSize，且等待队列未满，则进⼊等待队列。&lt;/li&gt;
&lt;li&gt;如果当前池⼤⼩ poolSize ⼤于 corePoolSize 且⼩于 maximumPoolSize ，且等待队列已满，则创建新线程执⾏任务。&lt;/li&gt;
&lt;li&gt;如果当前池⼤⼩ poolSize ⼤于 corePoolSize 且⼤于 maximumPoolSize ，且等待队列已满，则调⽤拒绝策略来处理该任务。&lt;ul&gt;
&lt;li&gt;线程池⾥的每个线程执⾏完任务后不会⽴刻退出，⽽是会去检查下等待队列⾥是否还有线程任务需要执⾏，如果在 keepAliveTime ⾥等不到新的任务了，那么线程就会退出。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 3 个最重要的参数：&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;corePoolSize&lt;/code&gt; :&lt;/strong&gt; 核心线程数线程数定义了最小可以同时运行的线程数量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;maximumPoolSize&lt;/code&gt; :&lt;/strong&gt; 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;workQueue&lt;/code&gt;:&lt;/strong&gt; 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="面试" scheme="https://z201.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="https://z201.github.io/tags/Java/"/>
    
      <category term="Java多线程" scheme="https://z201.github.io/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
