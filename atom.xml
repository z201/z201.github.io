<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>庆峰的博客</title>
  
  <subtitle>流水要争先，争的是滔滔不绝。</subtitle>
  <link href="https://z201.cn/atom.xml" rel="self"/>
  
  <link href="https://z201.cn/"/>
  <updated>2024-02-02T15:02:11.359Z</updated>
  <id>https://z201.cn/</id>
  
  <author>
    <name>庆峰的博客</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>业务知识-会计管理</title>
    <link href="https://z201.cn/posts/3038385824/"/>
    <id>https://z201.cn/posts/3038385824/</id>
    <published>2024-01-18T14:54:38.000Z</published>
    <updated>2024-02-02T15:02:11.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="财务管理"><a href="#财务管理" class="headerlink" title="财务管理"></a>财务管理</h2><h3 id="1-财报"><a href="#1-财报" class="headerlink" title="1.财报"></a>1.财报</h3><p><strong>财报的全称是财务报告，包括财务报表及附注说明，不仅仅是财务情况的披露，更能体现一个公司的整体经营情况及行业价值链网</strong>。</p><ul><li>例如，财报中会披露公司的Top5业务、Top5客户及供应商等信息，我们就可以看出这个公司的主要业务是什么、收入来源是什么、主要客户及主要供应商是谁，进而分析该公司所在行业的整体经营环境及关联关系。</li><li>报表分为凭证、账簿（总账、明细账、科目余额表）、财务三表（资产负债表、现金流量表、利润表）<ul><li>凭证：业务凭证、损益凭证</li><li>帐薄：总帐、明细账</li><li>会计报表：资产负债表、利润表、现金流表。</li></ul></li></ul><h4 id="资产负债表"><a href="#资产负债表" class="headerlink" title="资产负债表"></a><strong>资产负债表</strong></h4><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201000916.png"></p><ul><li>它反映在<strong>特定时间点</strong>上公司的财务财富状况（类似数据库中的快照）。它告诉你有多少钱可以用于投资，有多少债务要偿还，以及你作为所有者，你的资产值多少钱。查看资产负债表了解更多。它分为3个部分：<strong>资产，负债和所有者权益</strong>。</li><li>资产是在当前有一定价值或在未来能提供价值的东西。一般分为流动资产和固定资产两类：<ul><li><strong>流动资产</strong> 包括现金以及其他打算在一年内使用或出售的东西，比如账上的现金或货架上的商品</li><li><strong>固定资产</strong> 是可以使用一年以上的实物资产，比如车辆，机器或者房产</li></ul></li><li>负债是你的企业欠别人或别的企业的钱，分为：<ul><li><strong>流动负债</strong> 是你在一年内必须付清的债务，比如税费、采购账单、员工薪酬。它也可以包括一年内到期需支付的贷款和租金</li><li><strong>长期负债</strong> 指一年期以上的债务，它可以包括未偿还的剩余贷款或需支付的租金</li><li>资产负债表是的所有者权益表示的是扣除公司负债后归属于公司股东的那部分资产以及其使用去向。</li></ul></li><li>所有者权益由以下构成：<ul><li><strong>普通股&#x2F;股本</strong>：股份制企业的所有者持有这家公司的股份。非股份制的小微企业所有者可能不持有股票，但享有所有权。在资产负债表上，这一项表示公司的所有者能够主张权利的资金。</li><li><strong>未分配利润</strong>：当公司赚钱了，它可以把钱分配给股东，也可以留存这些钱 （即保留这些利润）用来增值资产或偿还负债。当公司保留利润的时候，这部分钱应该列示在资产负债表上的所有者权益项下。</li></ul></li></ul><h4 id="损益表"><a href="#损益表" class="headerlink" title="损益表"></a><strong>损益表</strong></h4><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201001509.png"></p><ul><li>损益表则让你洞察公司在<strong>一段时间里的业绩表现</strong>（<strong>类似一定周期内的数据指标</strong>）；因此可以用损益表来判断在某一期间是盈利或是亏损，也可以构建覆盖不同时段的损益表，比如一个月，一个季度，一年，或者几年。它告诉你公司有哪些开销，为什么赚钱或者亏损。查看损益表篇了解更多。</li><li>损益表的公式是：利润（也叫<strong>净利润</strong>）&#x3D; 利得（也叫收入）- 费用</li></ul><h4 id="现金流量表"><a href="#现金流量表" class="headerlink" title="现金流量表"></a><strong>现金流量表</strong></h4><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201001731.png"></p><ul><li>现金流是用来度量流进和流出公司的钱。现金流量表将现金流分为三个部分：经营性，投资性和筹资性。它呈现公司账上现金流入和流出的时间点，可以帮助你量入为出。查看现金流量表篇了解更多。<ul><li>现金流入，即进入你公司的现金，比如销售收入，收到的贷款和投资款等。</li><li>现金流出，即离开你公司的现金，比如采购支出，归还贷款，支付工资等。</li></ul></li><li>可以用现金流公式来计算未来某一时点上（或过去某一时点上）<ul><li>当期现金余额 &#x3D; 期初现金余额 + 现金流入 – 现金流出</li></ul></li><li><strong>存在透支的情况，就是余额为负数。</strong>比如：月初有1000元。这个月中，付了1500元费用，卖了300元的产品并收到现金，另外还有1200元的赊销收入，买方要2个月后才支付。下个月初使用权责发生制的会计计量方法，资产负债表将显示公司的总价值仍为1000元，这是由1000-1500费用 + 300收入 + 1200应收账款得出。<strong>余额为-200元。</strong><span id="more"></span></li></ul><h4 id="简单的记账流程"><a href="#简单的记账流程" class="headerlink" title="简单的记账流程"></a>简单的记账流程</h4><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201235043.png"></p><h4 id="财报的简易关系"><a href="#财报的简易关系" class="headerlink" title="财报的简易关系"></a>财报的简易关系</h4><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240202165210.png"></p><h4 id="总资产报酬率"><a href="#总资产报酬率" class="headerlink" title="总资产报酬率"></a>总资产报酬率</h4><ul><li><p>总资产报酬率 &#x3D;（（利润总额+利息支出）&#x2F; (期初资产总额+期末资产总额) &#x2F; 2 ）×100%</p></li><li><p>总资产报酬率越高，表明资产利用效率越高，说明企业在增加收入、节约资金使用等方面取得了良好的效果；该指标越低，说明企业资产利用效率低，应解析差异原因，提高销售利润率，加速资金周转，提高企业经营管理水平。</p><p>  1.表示企业全部资产获取收益的水平，全面反映了企业的获利能力和投入产出状况。通过对该指标的深入解析，可以增强各方面对企业资产经营的关注，促进企业提高单位资产的收益水平。</p><p>  2.一般状况下，企业可据此指标与市场资本利率实行比较，如果该指标大于市场利率，则表明企业可以充分利用财务杠杆，实行负债经营，获取尽可能多的收益。</p><p>  3.该指标越高，表明企业投入产出的水平越好，企业的资产运营越有效。</p></li></ul><h3 id="2-管报"><a href="#2-管报" class="headerlink" title="2.管报"></a>2.管报</h3><ul><li><p>财务信息的完善仅仅是管理报告的基础，在实现管理报告的编制中，必然会涉及到多种维度和指标数据的披露。</p></li><li><p>为了能够在几张通用的数据表中实现多维度分析和指标出具，我们需要对关键维度和指标进行梳理和定义，首先需要对财务分析的业务架构进行定义。</p><ul><li><strong>痛点：帐表一致、业财一致</strong></li></ul></li><li><p>损益分析：</p><ul><li>销量：财务数量、业务数量、实际妥投……</li><li>收入：销售收入、销售返利、销售收入调整……</li><li>成本：BMC成本：交货成本、材料运输成本、材料流利、成本差异……</li><li>NBMC成本：物流、售后、客服、IT……</li><li>存货分析：存货库龄、在途物资、跌价计提、跌价结转、跌价回冲；</li><li>资金分析：资金预估、资金成本、负债结构、风险预期；</li><li>业务分析：销售单据、服务单据、MAU、DAU……</li></ul><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240202174014.png"></p></li></ul><h3 id="3-财报VS管报"><a href="#3-财报VS管报" class="headerlink" title="3.财报VS管报"></a>3.财报VS管报</h3><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201014929.png"></p><ul><li><p>管理报告和财报面向的应用对象不同：</p><ul><li>财报更主要是针对股东、债权人及投资机构等外部人员或主体；主要信息覆盖了公司的基本经营情况，是股东了解公司业绩及运营情况的基础，有标准的准则规范可以参考，形制规范。</li><li>管理报告主要是面向内部经营分析，主要面向集团高层领导、各事业部或BU负责人、财务BP以及其他负责企业内部运营管理的人员，报告的形制不规范，报告的口径标准不禁统一；主要目的是发现经营问题，并以此为依据进行相关改善，提升内部效能。</li></ul><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201011053.png"></p></li></ul><h3 id="4-管报VS预算"><a href="#4-管报VS预算" class="headerlink" title="4.管报VS预算"></a>4.管报VS预算</h3><ul><li><p>战略目标向下分解为预算，年度预算编制形成考核指标；并制定考核方案，分期间对预算进行分解；并与管理报告实际数进行对比分析，形成差异报告；并分析差异根因，促进业务部门形成改进方案；并激励业务部门形成良性改进流程，形成预实结合的激励循环，为实现预算与实际数横向的可比性，需要对维度、指标进行统一；并需要管报和财报在数据层面上有勾稽关系，管理报告数据来自于核算和财报，有需要在细粒度和维度上与之有区别。</p><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201011146.png"></p></li></ul><h3 id="5-管报VS核算"><a href="#5-管报VS核算" class="headerlink" title="5.管报VS核算"></a>5.管报VS核算</h3><ul><li>核算是财务数据的基础，核算的目的一是为了完成记账和标准实务报表的出具，但是更重要的是能够为运营分析提供有效的数据基础；核算数据可以作为管理报告用途的前提是财务信息中包含其需要的维度，并能够结合业务数据形成财务运营指标。</li><li>在会计制度比较完善的公司，会形成标准的会计核算规范准则——也就是COA文档，一般文档中根据业务和财务记账实务的结合，形成一套标准的入账规则。</li></ul><h3 id="6-财务VS业务"><a href="#6-财务VS业务" class="headerlink" title="6.财务VS业务"></a>6.财务VS业务</h3><ul><li><p>以最朴素的视角来看，对于一般性不涉及生产制造的贸易型企业来说，企业中最简单的财务模型可以用建模思维抽象为一个泳池与两个水管。</p><ul><li>进项水管：资金流入，这里主要是指客户的打款，企业投资收益等其他流入项</li><li>出项水管：资金流出，这里主要指给供应商货款，内部员工工资，企业的其他支出等</li></ul><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240130225535.png">  </p></li><li><p>那么如果将这个泳池模型使用专业术语进行描述，就可以分别称之为：</p><ul><li>企业营收（进项水管）</li><li>成本支出（出项水管）</li><li>利润（泳池有水）</li></ul></li><li><p>权责发生制和复式记账法其实也在业务的时时刻刻中都有所体现，比如销售和客户签订合同，这其实是一个收入确认的节点，但签订合同的时刻往往是还没有收到钱的，也许合同签订后 1 周、1 个月，或者是协定分期付款，那么这个时候财务会做出这样的处理：确认这个订单的收入，但把要收的金额记入应收账款中，并推进业务进行到下一节点。</p><ul><li>在这个场景中，对应的会计分录如下：<ul><li>借：应收账款 1000</li><li>贷：主营业务收入 1000</li></ul></li></ul></li><li><p>不同的行业甚至同样的行业中涉及到的场景和产品路线都不同，我们先做个对<strong>业务</strong>简单的归拢，将业务动作分成以下6个大环节：</p></li></ul><table><thead><tr><th>环节</th><th>归类</th><th>费用</th></tr></thead><tbody><tr><td>1. 产品定位和客户获取</td><td>推广、线索</td><td>* 营销费用：企业为推广销售产品而支付的各种成本和费用，通常包括广告宣传、促销活动等； * 广告宣传费用：企业开展广告和宣传活动所支出的费用，通常包括广告投放、创意设计、媒体购买等； * 市场调研费用：企业为了了解市场需求和竞争情况而进行的调查和研究所产生的费用，通常包括问卷调查、市场分析等。</td></tr><tr><td>2.订单&#x2F;合同的签订和分派</td><td>履约确认</td><td>* 销售收入：客户签约时公司收到的货款； * 预付款：客户需提前支付货款，以确保公司有能力完成订单。此外，预付款也可帮助公司提前获得资金，用于生产和采购等环节； * 应收账款：因为客户一般不会立刻支付全部货款，因此公司需要根据合同约定收取剩余款项。</td></tr><tr><td>3.物料的采购</td><td>采购</td><td>* 采购成本：企业为了购买原材料和其他物资而支付的成本，通常包括采购价格、物流费用等； * 存货成本：企业为了维持正常经营所持有的存货所产生的成本，通常包括采购成本、仓储费用、库存成本等； * 应付账款：企业向供应商或其他债权人应付的未付款项，通常包括采购欠款、借款等。</td></tr><tr><td>4.产品生产加工制造</td><td>制造</td><td>* 原材料成本：企业在生产产品或提供服务过程中所使用的直接物品和物质的成本，通常包括所购买的原材料、半成品、零部件等； * 制造费用：企业制造产品时所产生的费用，主要包括直接人工费用、直接材料费用、制造费用等； * 工资薪金：企业支付给员工的报酬和薪金，通常包括工作时间和工作内容相关的工资、奖金、福利等。</td></tr><tr><td>5.库存存货管理和物流运输管理</td><td>仓储物流</td><td>* 仓储费用：企业为存放和保管存货而支付的费用，通常包括仓储租金、保险费等； * 库存成本：企业为持有和管理存货而产生的成本，通常包括采购成本、仓储费用、库存占用成本等； * 物流费用：企业为销售产品和提供服务而支付的物流成本，通常包括运输费用、仓储费用等。</td></tr><tr><td>6.客户满意度和售后服务</td><td>售后</td><td>* 服务成本：企业为提供售后服务而产生的成本，通常包括维修费用、人工成本等； * 保修费用：企业为承诺的产品保修而支付的费用，通常包括维修人工成本、配件等； * 客户退货：客户因为各种原因而退回或者要求更换的产品，企业需要承担相应的成本，包括原产品成本、退货物流费用等。</td></tr></tbody></table><h3 id="7-数字化转型"><a href="#7-数字化转型" class="headerlink" title="7.数字化转型"></a>7.数字化转型</h3><ul><li>当代的企业竞争已不仅仅是产品和服务的竞争，也是企业内部效率和数字化建设的竞争。</li><li>为什么很多企业开始重视数字化建设，因为好的数字化建设是信息效率的提升、内部运营成本的降低，同样也是用户极致体验的基础 。</li><li>同样，企业数字化建设也是业财一体化的前提，只有全部业务和流程进行线上化以后，才能被系统识别，才能形成信息流通过系统实现交互。</li></ul><h4 id="1-数字化转型痛点"><a href="#1-数字化转型痛点" class="headerlink" title="1.数字化转型痛点"></a>1.数字化转型痛点</h4><blockquote><p>财务应是企业高管的“眼睛”，帮助企业“看见”业绩差距、潜在经营风险和管理提升机会</p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201140214.png"></p><ol><li><strong>企业流程运行效率并未真正提升</strong>：启用会计报账平台后，财务人员对于入账前的原始票据审核部分由原来的线下纸质单据转换成了了线上电子化单据审核，凭证的生成借用了会计凭证模板和引擎，<strong>财务人员原始票据的审核及手工凭证的工作量确实减少了，但是业务人员需要在业务系统做一遍，到会计平台报账时再重复看一遍报账业务信息和报账凭据，出现问题时需要二次调整表单及补充上载报账凭据。</strong>对于没有和会计报账平台集成的业务，还需要业务人员把纸质凭据转化成电子票据上载，并手工完成表单填写。从业财端到端流程来看，整体流程的工作量尤其是产供销相关流程的工作量没有减下来，效率也没有真正提升。</li><li><strong>财务数据明细颗粒度不同，存在业财数据的二次核对且财务信息入账滞后</strong>：<strong>仓库存货的收发存、设备维修成本等，在会计报账平台下，不太可能实现基于每一次货物移动或订单收发料的实时财务记账，最终财务数据获取的是业务的汇总数据。</strong>在这样一个模式下，从会计核算系统反查业务信息是无法实现的，从业务追踪会计凭证也是无法实现的。那业务和财务之间的对账是避免不了的。另外，从财务入账的及时性上，财务凭证信息的及时性取决于业务人员报账的及时性，需要借助管理制度及各个系统间的核对报表来报账业财数据的同步及月季数据的完整性。</li><li><strong>企业的合规管控水平并未因此得到提升</strong>：在这样的业财融合模式下，在会计报账平台中所实现的预算控制仍然是在财务入账报销时的事后控制，并没有前移到业务系统，实现业务执行过程中的事前和事中控制；同样，内控点也没有前提到业务系统，实现业务执行过程中的事前和事中控制。因此，企业的合规管控水平并未这样的业财融合而得到提升。</li></ol><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201140625.png"></p><ol><li>业务、财务凭证的实时生成且双向追溯、实现了会计核算的自动化，保证了业务核算的客观性、准确性、及时性，是“强化核算报告，实现合规精准”的重要保障。</li><li>凭证记录生成有两个特点：一是实时性，业务凭证和财务凭证在系统中实时产生，没有丝毫的时间差；二是数据明细颗粒度相同，业务凭证和财务凭证都保持了业务发生时最原始的数据颗粒度，即数据同源。</li><li><strong>将企业内部控制点固化到业务流程中，让财务主动融入业务事前、事中、事后全流程来服务业务，从而加强源头治理，实现预算到考核的闭环，并强化穿透检测来防范风险。</strong></li></ol><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201141142.png"></p><h4 id="2-采购场景"><a href="#2-采购场景" class="headerlink" title="2.采购场景"></a>2.采购场景</h4><ol><li>如上图设置了4个控制点，其中，寻源报价对应系统中的货源清单和采购信息记录，对采购订单的供应商和采购价格进行控制；发票的三单匹配是对采购订单、收货单和发票进行的匹配检查，保证差异处在财务管理要求的容差范围内；二个审批节点通过系统预制好的工作流直接触发到相关审批人处完成审批。</li><li><strong>将预算、资金、内部控制点设计在流程固化到系统中，并在业务执行过程中进行业务的事前事中控制，事后记录反馈。强化了企业对业务的穿透检测，对企业的风险管理尤为重要。</strong></li></ol><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201142048.png"></p><h4 id="3-价值链驱动"><a href="#3-价值链驱动" class="headerlink" title="3.价值链驱动"></a>3.价值链驱动</h4><ul><li>在企业经营的每一个环节，当有业务发生时，外部会计凭证和管理会计凭证会同时实时生成。管理会计中的成本核算对象事前维护好了预算、计划数，可以对实际发生数进行管控并对比，实现成本费用的第一次管控。月底在管理会计内部根据成本对象间服务与被服务的关系及精细的作业动因分析，将成本费用在在管理会计内部不同的成本对象间进行第二次分配，结算。月结完毕后，第二次预算计划和实际的对比及差异分析可以帮助企业找出业务经营中的不足和下一步的业务提升点，助力企业内部责任实体实现精细化的财务管理。</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201142611.png"></p><ul><li>企业分析除了通过会计凭证为主线扩展形成总账、应收、应付主题外，还可以从其他不同的维度展开，如以生产订单为主的生产成本控制分析主题、以项目细分结构（WBS）管理为主的项目成本控制分析主题、以采购+库存为主的库存管理主题、以销售业务为主的产品盈利能力分析主题等等。利用这些主题，财务人员可以深度分析企业经营中发现的可提升空间，从而助力企业理性决策、科学决策。</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201142702.png"></p><h3 id="8-财务与合规"><a href="#8-财务与合规" class="headerlink" title="8.财务与合规"></a>8.财务与合规</h3><ul><li>随着我国多层次资本市场体系建设的推进以及注册制的实施，越来越多的企业有机会进入资本市场获得更丰富的发展资源和更加广阔的发展空间。但是，无论是已上市公司还是走在 IPO 路上的拟上市公司，持续合规化运行和运营效率与效益的持续提升永远是摆在管理者面前紧迫且重要的两大课题。这两项课题都是复杂体系并受到多因素影响，例如前者既包括业务本身的合法合规，也包括内控合规、财务报告合规以及数据合规；后者既受到市场环境、行业政策等外部因素的影响，也受到管理模式、 流程、数字化等内部因素的影响。</li></ul><h4 id="1-合规标准的适度性以及与业务侧的共识"><a href="#1-合规标准的适度性以及与业务侧的共识" class="headerlink" title="1.合规标准的适度性以及与业务侧的共识"></a>1.<strong>合规标准的适度性以及与业务侧的共识</strong></h4><ul><li>内控指引通常为原则和指导性规范，规定企业需要建立哪些内控制度以及设置哪些控制点，但在控制流程长短、控制节点多少、授权的范围和尺度、审批的并行或串行以及线上或线下、 控制记录的形式等方面并未做出过细规定，而是给了企业自主权，因此，如何把握合规标准的尺度和适度性，不形式化和过度化，既能达到合规要求又不影响经营活动的效率，真正发挥内控的风险防范价值，平衡好合规要求与流程效率的关系，是一项既需要极强专业判断又需要极高管理艺术的任务。</li></ul><p>与此同时，内控制度和会计准则的执行覆盖企业全部业务活动，需要业务侧的配合与协作， 因此就合规标准与业务侧形成理解与共识，实现刚性要求与自主执行相结合，避免强推强压，对内控执行的效果和可持续性都具有极大作用。</p><h4 id="2-合规方案落地的信息化支撑"><a href="#2-合规方案落地的信息化支撑" class="headerlink" title="2.合规方案落地的信息化支撑"></a>2.<strong>合规方案落地的信息化支撑</strong></h4><ul><li>合规方案通常是流程和工作方法的结合，其落地执行一是需要建立制度保障 ；二是需要 IT 系统的强力支撑。随着企业数字化转型观念的普及，IT 系统已经得到广泛应用，普遍将内控融入流程，并将流程嵌入 IT系统中固定下来。但是，像收入确认、合同资产确认、项目费用核算与分摊、研发费用归集等场景，仍然缺少成熟的市场化的 IT 系统支撑。这些场景貌似是财务事项，但实际上都基于业务系统计算出每期入账数据，再传递到账务系统生成凭证的过程。有些行业的计算复杂度非常高，但当前 CRM、ERP或其他系统基本都没有成熟的功能可以使用，只能通过自行开发或委托开发的方式解决，成为合规路上的一个障碍。</li></ul><h4 id="3-历史业务的合规整改"><a href="#3-历史业务的合规整改" class="headerlink" title="3.历史业务的合规整改"></a>3.<strong>历史业务的合规整改</strong></h4><ul><li>历史业务的合规整改是 IPO 企业普遍遇到的难题， 报告期内的大量业务需要追溯， 特别是“合同 – 订单 – 发票 – 收入 – 收款”等销售与收款循环的审计验证，需要大量数据和档案的检查与核对。对于规范管理和信息化薄弱的企业，需要补签各种内控单据和记录，甚至需要客户、供应商等外部单位的协助，其难度可想而知。这种情况之所以普遍，是因为很少有企业能够未雨绸缪，各部门能够在内控合规的要求上形成共识并下定决心，前期管理薄弱欠下的账终究要还。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;财务管理&quot;&gt;&lt;a href=&quot;#财务管理&quot; class=&quot;headerlink&quot; title=&quot;财务管理&quot;&gt;&lt;/a&gt;财务管理&lt;/h2&gt;&lt;h3 id=&quot;1-财报&quot;&gt;&lt;a href=&quot;#1-财报&quot; class=&quot;headerlink&quot; title=&quot;1.财报&quot;&gt;&lt;/a&gt;1.财报&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;财报的全称是财务报告，包括财务报表及附注说明，不仅仅是财务情况的披露，更能体现一个公司的整体经营情况及行业价值链网&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，财报中会披露公司的Top5业务、Top5客户及供应商等信息，我们就可以看出这个公司的主要业务是什么、收入来源是什么、主要客户及主要供应商是谁，进而分析该公司所在行业的整体经营环境及关联关系。&lt;/li&gt;
&lt;li&gt;报表分为凭证、账簿（总账、明细账、科目余额表）、财务三表（资产负债表、现金流量表、利润表）&lt;ul&gt;
&lt;li&gt;凭证：业务凭证、损益凭证&lt;/li&gt;
&lt;li&gt;帐薄：总帐、明细账&lt;/li&gt;
&lt;li&gt;会计报表：资产负债表、利润表、现金流表。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;资产负债表&quot;&gt;&lt;a href=&quot;#资产负债表&quot; class=&quot;headerlink&quot; title=&quot;资产负债表&quot;&gt;&lt;/a&gt;&lt;strong&gt;资产负债表&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201000916.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它反映在&lt;strong&gt;特定时间点&lt;/strong&gt;上公司的财务财富状况（类似数据库中的快照）。它告诉你有多少钱可以用于投资，有多少债务要偿还，以及你作为所有者，你的资产值多少钱。查看资产负债表了解更多。它分为3个部分：&lt;strong&gt;资产，负债和所有者权益&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;资产是在当前有一定价值或在未来能提供价值的东西。一般分为流动资产和固定资产两类：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;流动资产&lt;/strong&gt; 包括现金以及其他打算在一年内使用或出售的东西，比如账上的现金或货架上的商品&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;固定资产&lt;/strong&gt; 是可以使用一年以上的实物资产，比如车辆，机器或者房产&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;负债是你的企业欠别人或别的企业的钱，分为：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;流动负债&lt;/strong&gt; 是你在一年内必须付清的债务，比如税费、采购账单、员工薪酬。它也可以包括一年内到期需支付的贷款和租金&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;长期负债&lt;/strong&gt; 指一年期以上的债务，它可以包括未偿还的剩余贷款或需支付的租金&lt;/li&gt;
&lt;li&gt;资产负债表是的所有者权益表示的是扣除公司负债后归属于公司股东的那部分资产以及其使用去向。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所有者权益由以下构成：&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;普通股&amp;#x2F;股本&lt;/strong&gt;：股份制企业的所有者持有这家公司的股份。非股份制的小微企业所有者可能不持有股票，但享有所有权。在资产负债表上，这一项表示公司的所有者能够主张权利的资金。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;未分配利润&lt;/strong&gt;：当公司赚钱了，它可以把钱分配给股东，也可以留存这些钱 （即保留这些利润）用来增值资产或偿还负债。当公司保留利润的时候，这部分钱应该列示在资产负债表上的所有者权益项下。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;损益表&quot;&gt;&lt;a href=&quot;#损益表&quot; class=&quot;headerlink&quot; title=&quot;损益表&quot;&gt;&lt;/a&gt;&lt;strong&gt;损益表&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201001509.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;损益表则让你洞察公司在&lt;strong&gt;一段时间里的业绩表现&lt;/strong&gt;（&lt;strong&gt;类似一定周期内的数据指标&lt;/strong&gt;）；因此可以用损益表来判断在某一期间是盈利或是亏损，也可以构建覆盖不同时段的损益表，比如一个月，一个季度，一年，或者几年。它告诉你公司有哪些开销，为什么赚钱或者亏损。查看损益表篇了解更多。&lt;/li&gt;
&lt;li&gt;损益表的公式是：利润（也叫&lt;strong&gt;净利润&lt;/strong&gt;）&amp;#x3D; 利得（也叫收入）- 费用&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;现金流量表&quot;&gt;&lt;a href=&quot;#现金流量表&quot; class=&quot;headerlink&quot; title=&quot;现金流量表&quot;&gt;&lt;/a&gt;&lt;strong&gt;现金流量表&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201001731.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;现金流是用来度量流进和流出公司的钱。现金流量表将现金流分为三个部分：经营性，投资性和筹资性。它呈现公司账上现金流入和流出的时间点，可以帮助你量入为出。查看现金流量表篇了解更多。&lt;ul&gt;
&lt;li&gt;现金流入，即进入你公司的现金，比如销售收入，收到的贷款和投资款等。&lt;/li&gt;
&lt;li&gt;现金流出，即离开你公司的现金，比如采购支出，归还贷款，支付工资等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以用现金流公式来计算未来某一时点上（或过去某一时点上）&lt;ul&gt;
&lt;li&gt;当期现金余额 &amp;#x3D; 期初现金余额 + 现金流入 – 现金流出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;存在透支的情况，就是余额为负数。&lt;/strong&gt;比如：月初有1000元。这个月中，付了1500元费用，卖了300元的产品并收到现金，另外还有1200元的赊销收入，买方要2个月后才支付。下个月初使用权责发生制的会计计量方法，资产负债表将显示公司的总价值仍为1000元，这是由1000-1500费用 + 300收入 + 1200应收账款得出。&lt;strong&gt;余额为-200元。&lt;/strong&gt;</summary>
    
    
    
    <category term="Life" scheme="https://z201.cn/categories/Life/"/>
    
    
    <category term="Life" scheme="https://z201.cn/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>业务知识-会计基础</title>
    <link href="https://z201.cn/posts/3434435716/"/>
    <id>https://z201.cn/posts/3434435716/</id>
    <published>2024-01-12T14:54:28.000Z</published>
    <updated>2024-02-02T15:00:17.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="会计基础"><a href="#会计基础" class="headerlink" title="会计基础"></a>会计基础</h2><h3 id="1-权责发生制和收付实现制"><a href="#1-权责发生制和收付实现制" class="headerlink" title="1. 权责发生制和收付实现制"></a>1. 权责发生制和收付实现制</h3><ul><li>权责发生制和收付实现制是两种相对应的核算制度，由于<strong>权责发生制相较于收付实现制可以更好地反映企业实际经营情况</strong>，我国要求企业必须使用权责发生制进行核算。</li></ul><h4 id="权责发生制"><a href="#权责发生制" class="headerlink" title="权责发生制"></a><strong>权责发生制</strong></h4><ul><li>又称应收应付制。凡在本期发生应从本期收入中获得补偿的费用，不论是否在本期已实际支付或未付的货币资金，均应作为本期的费用处理；凡在本期发生应归属于本期的收入，不论是否在本期已实际收到或未收到的货币资金，均应作为本期的收入处理。</li><li><strong>简单解释：</strong>只要交易行为发生，记账周期内不管有没有收到钱，都确认记账。</li></ul><h4 id="收付实现制"><a href="#收付实现制" class="headerlink" title="收付实现制"></a><strong>收付实现制</strong></h4><ul><li><p>凡在本期内实际收到或付出的一切款项，无论其发生时间早晚或是否应该由本期承担，均作为本期的收益和费用处理。</p></li><li><p><strong>简单解释：</strong>只有收到钱了才确认记账，不管这笔交易实际上是发生在哪个周期。</p></li></ul><h3 id="2-单式记账法和复式记账法"><a href="#2-单式记账法和复式记账法" class="headerlink" title="2. 单式记账法和复式记账法"></a>2. 单式记账法和复式记账法</h3><blockquote><p>单式记账法和复式记账法是两种不同的记账方法。</p></blockquote><ul><li>单式记账法：我们日常所说的<strong>流水账，只记录收入支出的流水，而没有记录流水与账户的对应关系。</strong></li><li>复式记账法：要求<strong>每一笔流水都记录在两个以上的账簿中，用于反映流水与账户的对应关系</strong>，并能够更清晰地看到每个账户的余额，<strong>我国企业所用的借贷记账法即是复式记账法的一种。</strong><ul><li><strong>记账规则：有借必有贷、借贷必相等。</strong></li></ul></li></ul><h3 id="3-资产-负债-所有者权益"><a href="#3-资产-负债-所有者权益" class="headerlink" title="3.资产 &#x3D; 负债+ 所有者权益"></a>3.资产 &#x3D; 负债+ 所有者权益</h3><ul><li><p>这条等式被称为<strong>会计恒等式</strong>，是一切会计对应关系和核算的基础。在我们的日常观念中，这一条等式其实是很反人类的，为什么资产会由负债组成？</p><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240129212700.png"></p></li><li><p>其实举一个简单的栗子就可以理解，正如贷款购房，房产总价 1000 万，我首付 400 万，剩余 600 万我贷款，那么在这个场景中，我已经购买了房子，1000 万就是我的资产，但这又不完全都是我自己的，只有 400 万才真正是我自己的，剩下的 600 万其实是我的负债，我还需要把负债还清了，因此，所有者权益又被称为净资产。</p><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240129212839.png"></p></li></ul><h3 id="4-记账方式"><a href="#4-记账方式" class="headerlink" title="4. 记账方式"></a>4. 记账方式</h3><ul><li><p>记账方式就是<strong>把复式记账法+ 会计恒等式结合在一起</strong>，并写出会计的<strong>分录</strong>，举一些的例子：</p><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240202182205.png"></p><p>  <strong>用现金花了100 块买衣服：</strong></p><ul><li>借：衣服 100</li><li>贷：现金 100</li></ul><p>  <strong>用花呗花了 100块买衣服：</strong></p><ul><li>借：衣服 100</li><li>贷：花呗 100</li></ul><p>  <strong>用花呗花了10块钱吃饭：</strong></p><ul><li>借：吃饭 10</li><li>贷：花呗 10</li></ul><p>  <strong>「借」反映的是资产的增加、负债和所有者权益的减少，而「贷」反映的是资产的减少、负债和所有者权益的增加</strong>。</p></li></ul><span id="more"></span><h3 id="5-应收和应付"><a href="#5-应收和应付" class="headerlink" title="5. 应收和应付"></a>5. 应收和应付</h3><ul><li><p>应收应付是会计中非常重要的两个概念，也是和业务最为密切相关的概念，应收应付是往来款的一部分，除此之外还有预收、预付款，以上款项平时我们称之为挂账，是<strong>应该发生但尚未实际发生的资金流入或流出</strong>，当挂账已经实际发生时，挂账就被抵掉了。应收应付会有<strong>账期</strong>，在应收应付发生时会定义好一个 deadline，如果超过了账期实际资金流动仍未发生，就会产生坏账，所以会引申出催款、信用评估及管理这些动作。</p></li><li><p>场景一：销售</p><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201214906.png"></p><p>  <strong>新增应收单：</strong>当销售签订合同时，确认收入并新增应收单，用于记录订单应该向客户收取的款项，应收单状态分为未回款、部分回款及已回款。应收单对应分录如下：</p><ul><li>借：应收账款</li><li>贷：主营业务收入</li></ul><p>  <strong>新增收款单：</strong>如果发生了实际收款，则针对关联的应收单新增收款单，以完成应收单的回款、改变应收单状态，完成销售流程。收款单对应分录如下：</p><ul><li>借：银行存款</li><li>贷：应收账款</li></ul></li><li><p>场景二：采购</p><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201214813.png"></p><p>  <strong>新增应付单：</strong>当采购申请通过时，确认成本费用并新增应付单，用于记录应该向供应商支付的采购费用，付款单状态分为未付款、部分付款及已付款。应付单对应分录如下：</p><ul><li>借：主营业务成本&#x2F;销售费用</li><li>贷：应付账款</li></ul><p>  <strong>新增付款单：</strong>当付款申请通过并完成打款时，则对关联的应付单新增付款单，以改变应付单的状态，完成采购流程。付款单对应分录如下：</p><ul><li>借：应付账款</li><li>贷：银行存款</li></ul></li><li><p>场景三：销售退货</p><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201214756.png"></p><p>  当订单发生退订，将针对此订单生成退款应付单，并减少收入。对应分录如下：</p><ul><li>借：主营业务收入</li><li>贷：应付账款</li></ul><p>  当应付单完成付款时，完成退订流程。对应分录如下：</p><ul><li>借：应付账款</li><li>贷：银行存款</li></ul></li></ul><h3 id="6-交易流水"><a href="#6-交易流水" class="headerlink" title="6.交易流水"></a>6.<strong>交易流水</strong></h3><ul><li>将收款单与付款单列表进行聚合，就可以得到完整的交易流水用于对账，而在某一些场景比如使用优惠券进行交易的场景，交易流水并不能真实反映实际的交易情况，还需要结合订单流水进行做账。</li><li>关键三点<ul><li>一是要按时间顺序</li><li>二是记录发生的事情摘要</li><li>三是记录发生金额</li></ul></li></ul><h3 id="7-财务凭证"><a href="#7-财务凭证" class="headerlink" title="7.财务凭证"></a>7.财务凭证</h3><ul><li>记录经济业务发生或者完成情况的<strong>书面证明</strong>，是登记帐薄的依据，包括<strong>纸质会计凭证和电子会计凭证</strong>两种形式。</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201014839.png"></p><ul><li><p>在会计法上，将会计凭证明确地分为两大类，这就是<strong>原始凭证和记账凭证</strong>。</p><ul><li><p>原始凭证：又称单据，在经济业务发生或者完成时取得的或者填制的，用以记录或者证明经济业务的发生或者完成情况的原始凭据。</p><ul><li>比如：现金收据、发货票、增值税专用税票、入库单、领料单等。</li></ul><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201231744.png">  </p></li><li><p>记账凭证：又称记账凭单，是指会计人员根据审核无误的原始凭证，<strong>记载经济业务简要内容，确定会计分录，作为记账依据的会计凭证</strong>。</p><ul><li>收款凭证：记录库存现金和银行存货收款业务的记账凭证<ul><li>比如：收到合同款了。</li></ul></li><li>付款凭证：记录库存现金和银行存款付款业务的记账凭证<ul><li>比如：发工资了。</li></ul></li><li>转账凭证：记录不涉及库存现金和银行存款业务的记录凭证<ul><li>比如：商品出库或者原材料生产，这两个科目都不涉及到现金和付款。所以可以使用转账凭证。</li></ul></li></ul></li></ul><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240131232154.png"></p><ul><li>记账凭证一般基于原始凭证生成，记录会计科目、借贷方向和金额</li></ul><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240131231854.png"></p></li></ul><h3 id="8-财务科目"><a href="#8-财务科目" class="headerlink" title="8.财务科目"></a>8.财务科目</h3><blockquote><p><strong>会计要素；可以理解成记账的分类；而账户是记录科目的载体，账户是有结构的。科目是账目的名字，账户是科目的内容。</strong></p></blockquote><ul><li>会计科目表又可分成：资产类（A）、负债类（L）、权益类（C）、收益类（R）和费损类（E）5种性质，以下是这5种性质在借方和贷方的情形，而这也可以简化为所谓的“T字帐”（▲表示增加，▼表示减少）</li></ul><table><thead><tr><th>类型</th><th>借方</th><th>贷方</th></tr></thead><tbody><tr><td><strong>资产</strong>A</td><td>▲</td><td>▼</td></tr><tr><td><strong>负责</strong>L</td><td>▼</td><td>▲</td></tr><tr><td><strong>权益</strong>C</td><td>▼</td><td>▲</td></tr><tr><td><strong>收益</strong>R</td><td>▼</td><td>▲</td></tr><tr><td><strong>费损</strong>E</td><td>▲</td><td>▼</td></tr></tbody></table><h4 id="1-会计科目表"><a href="#1-会计科目表" class="headerlink" title="1.会计科目表"></a>1.会计科目表</h4><ul><li>会计科目表名称、会计科目表编号仅供参考之用，各个地方使用的方式略有不同。</li><li>一个会计科目表可能有1种以上的会计科目表编号。</li><li>会计科目表分类解释：<ul><li>资产类科目：表示所拥有或控制的各种类型的经济资源，如库存现金、银行活期存款、建筑物、存货、预付租金、商誉、应收账等。</li><li>负债类科目：表示各种经济债务，如应付账、银行贷款、应付债券、分期支付利息等。</li><li>所有者权益类科目：表示资产扣除债务后的余值。</li><li>收入或营业额类科目：表示各种毛收入，如销售、服务收入、利息收入等。</li><li>费用类科目：表示运营时的各种费用支出。如电费、水费、租金、折旧、呆账、利息支出、保险金等。</li><li>备抵科目：某些科目有对应的反向科目，具有相反方向的余额，用来调整当前科目余额。例如，累计折旧是固定资产的备抵科目。坏账准备是长期应收票据的备抵科目。属于该类备抵账户的包括“短期投资跌价准备”、“坏账准备”、“商品进销差价”、“存货跌价准备”、“长期投资减值准备”、“固定资产减值准备”、“无形资产减值准备”等。</li></ul></li></ul><h4 id="2-会计编号"><a href="#2-会计编号" class="headerlink" title="2.会计编号"></a>2.会计编号</h4><blockquote><p>预定千、百、十、个四位数字，自左至右，分别代表大类（千）、项目（百）和科目（十、个），子目则以“N”予以表示；而相关的附加或抵销科目，则以“—N”予以表示；</p></blockquote><ul><li>第1码：类别号码<ul><li>以千位的1、2、3、4、5、6，分别顺序代表资产类、负债类、共同类、所有者权益类、成本类、损益类等六类； [2]</li></ul></li><li>第2码：性质别号码<ul><li>而以百位的1、2、……顺序代表大类之下，项目的分类及固定排列；</li></ul></li><li>第3、4码：项目及科目别号码<ul><li>每个项目之下的科目编号，则从01开始，至99为止；其间复可分段编列不同内容、性质的科目。</li></ul></li></ul><h4 id="3-资产类科目"><a href="#3-资产类科目" class="headerlink" title="3.资产类科目"></a>3.资产类科目</h4><table><thead><tr><th>序号</th><th>科目代码</th><th>科目名称</th><th>英文名称</th><th>备注</th></tr></thead><tbody><tr><td><strong>资产类</strong></td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>1001</td><td>库存现金</td><td>cash on hand</td><td>原科目名称“现金”</td></tr><tr><td>2</td><td>1002</td><td>银行存款</td><td>bank deposit</td><td></td></tr><tr><td>3</td><td>1003</td><td>存放中央银行款项</td><td></td><td>银行专用</td></tr><tr><td></td><td>1011</td><td>存放同业</td><td></td><td>银行专用</td></tr><tr><td></td><td>1012</td><td>其他货币资金</td><td>other monetary capital</td><td></td></tr><tr><td></td><td>1101</td><td>短期投资</td><td></td><td></td></tr><tr><td></td><td>1102</td><td>短期投资跌价准备</td><td></td><td></td></tr><tr><td></td><td>1021</td><td>结算备付金</td><td></td><td>证券专用</td></tr><tr><td></td><td>1031</td><td>存出保证金</td><td></td><td>金融共用</td></tr><tr><td></td><td>1101</td><td>交易性金融资产</td><td>transaction monetary assets</td><td>金融共用</td></tr><tr><td></td><td>1111</td><td>买入返售金融资产</td><td></td><td>金融共用</td></tr><tr><td></td><td>1121</td><td>应收票据</td><td>notes receivable</td><td></td></tr><tr><td></td><td>1122</td><td>应收账款</td><td>Account receivable</td><td></td></tr><tr><td></td><td>1123</td><td>预付账款</td><td>account prepaid</td><td></td></tr><tr><td></td><td>1131</td><td>应收股利</td><td>dividend receivable</td><td></td></tr><tr><td></td><td>1132</td><td>应收利息</td><td>accrued interest receivable</td><td></td></tr><tr><td></td><td>1201</td><td>应收代位追偿款</td><td>示例</td><td>保险专用</td></tr><tr><td></td><td>1211</td><td>应收分保账款</td><td>示例</td><td>保险专用</td></tr><tr><td></td><td>1212</td><td>应收分保合同准备金</td><td>示例</td><td>保险专用</td></tr><tr><td></td><td>1221</td><td>其他应收款</td><td>accounts receivable-others</td><td>示例</td></tr><tr><td></td><td>1231</td><td>坏账准备</td><td>bad debts reserve</td><td>示例</td></tr><tr><td></td><td>1161</td><td>应收补贴款</td><td>示例</td><td>示例</td></tr><tr><td></td><td>1301</td><td>贴现资产</td><td>示例</td><td>银行专用</td></tr><tr><td></td><td>1302</td><td>拆出资金</td><td></td><td></td></tr><tr><td></td><td>1303</td><td>贷款</td><td></td><td>银行和保险共用</td></tr><tr><td></td><td>1304</td><td>贷款损失准备</td><td></td><td>银行和保险共用</td></tr><tr><td></td><td>1311</td><td>代理兑付证券</td><td></td><td>银行和证券共用</td></tr><tr><td></td><td>1312</td><td>代理业务资产</td><td></td><td></td></tr><tr><td></td><td></td><td>协议透支</td><td></td><td>核算客户按照有关协议在规定的限额和期限内发生的存款透支款项</td></tr><tr><td></td><td>1325</td><td>转贷款</td><td>sub-loan</td><td></td></tr><tr><td></td><td>1326</td><td>垫款</td><td>advance</td><td></td></tr><tr><td></td><td>1401</td><td>材料采购</td><td>procurement of materials</td><td>原名“物资采购”</td></tr><tr><td></td><td>1402</td><td>在途物资</td><td>materials in transit</td><td></td></tr><tr><td></td><td>1403</td><td>原材料</td><td>raw materials</td><td></td></tr><tr><td></td><td>1404</td><td>材料成本差异</td><td></td><td></td></tr><tr><td></td><td>1405</td><td>库存商品</td><td>commodity stocks</td><td></td></tr><tr><td></td><td>1406</td><td>发出商品</td><td>goods in transit</td><td></td></tr><tr><td></td><td>1407</td><td>商品进销差价</td><td></td><td></td></tr><tr><td></td><td>1408</td><td>委托加工物资</td><td></td><td></td></tr><tr><td></td><td>1411</td><td>周转材料</td><td></td><td></td></tr><tr><td></td><td>1412</td><td>包装物</td><td>wrappage</td><td></td></tr><tr><td></td><td>1413</td><td>低值易耗品包装物</td><td>low value and easily wornout articles</td><td></td></tr><tr><td></td><td>1232</td><td>自制半成品</td><td></td><td></td></tr><tr><td></td><td>1241</td><td>委托代销商品</td><td></td><td></td></tr><tr><td></td><td>1243</td><td>受托代销商品</td><td></td><td></td></tr><tr><td></td><td>1421</td><td>消耗性生物资产</td><td></td><td>农业专用</td></tr><tr><td></td><td>1431</td><td>贵金属</td><td></td><td>银行专用</td></tr><tr><td></td><td>1441</td><td>抵债资产</td><td></td><td>金融共用</td></tr><tr><td></td><td>1451</td><td>损余物资</td><td></td><td>保险专用</td></tr><tr><td></td><td>1461</td><td>融资租赁资产</td><td>financial leasing assets exclusively for leasing</td><td>租赁专用</td></tr><tr><td></td><td>1471</td><td>存货跌价准备</td><td>reserve against stock price declining</td><td></td></tr><tr><td></td><td>1291</td><td>（分期收款）发出商品</td><td></td><td></td></tr><tr><td></td><td>1301</td><td>待摊费用</td><td>fees to be apportioned</td><td></td></tr><tr><td></td><td>1501</td><td>持有至到期投资</td><td>hold investment due</td><td></td></tr><tr><td></td><td>1502</td><td>持有至到期投资减值准备</td><td>hold investment due reduction reserve</td><td></td></tr><tr><td></td><td>1503</td><td>可供出售金融资产</td><td>financial assets available for sale</td><td></td></tr><tr><td></td><td>1511</td><td>长期股权投资</td><td>long-term stock ownership investment</td><td></td></tr><tr><td></td><td>1402</td><td>长期债券投资</td><td></td><td></td></tr><tr><td></td><td>1512</td><td>长期投资减值准备</td><td>long-term stock ownership investment reduction reserve</td><td></td></tr><tr><td></td><td>1431</td><td>委托贷款</td><td></td><td></td></tr><tr><td></td><td>1521</td><td>投资性房地产</td><td>investment real eastate</td><td></td></tr><tr><td></td><td>1531</td><td>长期应收款</td><td>long-term account receivable</td><td></td></tr><tr><td></td><td>1532</td><td>未实现融资收益</td><td>unrealized financing income</td><td></td></tr><tr><td></td><td>1541</td><td>存出资本保证金</td><td></td><td>保险专用</td></tr><tr><td></td><td>1601</td><td>固定资产</td><td>permanent assets</td><td></td></tr><tr><td></td><td>1602</td><td>累计折旧</td><td>accumulated depreciation</td><td></td></tr><tr><td></td><td>1603</td><td>固定资产减值准备</td><td>permanent assets reduction reserve</td><td></td></tr><tr><td></td><td>1604</td><td>工程物资</td><td>engineer material</td><td></td></tr><tr><td></td><td>1605</td><td>在建工程</td><td>construction in process</td><td></td></tr><tr><td></td><td>1606</td><td>在建工程减值准备</td><td></td><td></td></tr><tr><td></td><td>1607</td><td>固定资产清理</td><td>disposal of fixed assets</td><td></td></tr><tr><td></td><td>1611</td><td>未担保余值</td><td>unguaranteed residual value exclusively for leasing</td><td>租赁专用</td></tr><tr><td></td><td>1621</td><td>生产性生物资产</td><td>productive living assets exclusively for agriculture</td><td>农业专用</td></tr><tr><td></td><td>1622</td><td>生产性生物资产累计折旧</td><td>productive living assets accumulated depreciation exclusively for agriculture</td><td>农业专用</td></tr><tr><td></td><td>1623</td><td>公益性生物资产</td><td>non-profit living assets exclusively for agriculture</td><td>农业专用</td></tr><tr><td></td><td>1631</td><td>油气资产</td><td>oil and gas assets exclusively for oil and gas exploitation</td><td>石油天然气开采专用</td></tr><tr><td></td><td>1632</td><td>累计折耗</td><td>accumulated depletion exclusively for oil and gas exploitation</td><td>石油天然气开采专用</td></tr><tr><td></td><td>1701</td><td>无形资产</td><td>intangible assets</td><td></td></tr><tr><td></td><td>1702</td><td>累计摊销</td><td>accumulated amortization</td><td></td></tr><tr><td></td><td>1703</td><td>无形资产减值准备</td><td>intangible assets reduction reserve</td><td></td></tr><tr><td></td><td>1711</td><td>商誉</td><td>business reputation</td><td></td></tr><tr><td></td><td>1815</td><td>未确认融资费用</td><td></td><td></td></tr><tr><td></td><td>1801</td><td>长期待摊费用</td><td>long-term deferred expenses</td><td></td></tr><tr><td></td><td>1811</td><td>递延所得税资产</td><td>deferred income tax assets</td><td></td></tr><tr><td></td><td>1821</td><td>独立账户资产</td><td></td><td>保险专用</td></tr><tr><td></td><td>1901</td><td>待处理财产损溢</td><td></td><td>waiting assets profit and loss</td></tr></tbody></table><h4 id="4-负债类科目"><a href="#4-负债类科目" class="headerlink" title="4.负债类科目"></a>4.负债类科目</h4><table><thead><tr><th>序号</th><th>科目代码</th><th>科目名称</th><th>英文名称</th><th>备注</th></tr></thead><tbody><tr><td><strong>负债类</strong></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>2101</td><td>短期借款</td><td>short-term loan</td><td></td></tr><tr><td></td><td>2102</td><td>存入保证金</td><td></td><td>金融共用</td></tr><tr><td></td><td>2103</td><td>拆入资金</td><td></td><td>金融共用</td></tr><tr><td></td><td>2104</td><td>向中央银行借款</td><td></td><td>银行专用</td></tr><tr><td></td><td>2011</td><td>吸收存款</td><td></td><td>银行专用</td></tr><tr><td></td><td>2012</td><td>同业存放</td><td></td><td>银行专用</td></tr><tr><td></td><td>2021</td><td>贴现负债</td><td></td><td>银行专用</td></tr><tr><td></td><td>2101</td><td>交易性金融负债</td><td>transaction financial liabilities</td><td></td></tr><tr><td></td><td>2102</td><td>卖出回购金融资产款</td><td></td><td>金融共用</td></tr><tr><td></td><td>2201</td><td>应付票据</td><td>notes payable</td><td></td></tr><tr><td></td><td>2202</td><td>应付账款</td><td>account payable</td><td></td></tr><tr><td></td><td>2203</td><td>预收账款</td><td>item received in advance</td><td></td></tr><tr><td></td><td>2141</td><td>代销商品款</td><td></td><td></td></tr><tr><td></td><td>2211</td><td>应付职工薪酬</td><td>employee pay payable</td><td>“应付工资”合并</td></tr><tr><td></td><td>2153</td><td>应付福利费</td><td></td><td></td></tr><tr><td></td><td>2221</td><td>应交税费</td><td>tax payable</td><td>应交税金 合并</td></tr><tr><td></td><td>2176</td><td>其他应交款</td><td>other account payable</td><td></td></tr><tr><td></td><td>2231</td><td>应付利息</td><td>interest payable</td><td></td></tr><tr><td></td><td>2232</td><td>应付股利</td><td>dividend payable</td><td></td></tr><tr><td></td><td>2171</td><td>应交税金</td><td></td><td>合并</td></tr><tr><td></td><td>2241</td><td>其他应付款</td><td></td><td></td></tr><tr><td></td><td>2251</td><td>应付保单红利</td><td></td><td>保险专用</td></tr><tr><td></td><td>2261</td><td>应付分保账款</td><td></td><td>保险专用</td></tr><tr><td></td><td>2311</td><td>代理买卖证券款</td><td></td><td>证券专用</td></tr><tr><td></td><td>2312</td><td>代理承销证券款</td><td></td><td>证券和银行共用</td></tr><tr><td></td><td>2313</td><td>代理兑付证券款</td><td></td><td>证券和银行共用</td></tr><tr><td></td><td>2314</td><td>代理业务负债</td><td></td><td></td></tr><tr><td></td><td>2401</td><td>递延收益</td><td>deferred income</td><td></td></tr><tr><td></td><td>2191</td><td>预提费用</td><td>withholding expenses</td><td></td></tr><tr><td></td><td>2201</td><td>待转资产价值</td><td></td><td></td></tr><tr><td></td><td>2501</td><td>长期借款</td><td>money borrowed for long term</td><td></td></tr><tr><td></td><td>2502</td><td>应付债券</td><td></td><td></td></tr><tr><td></td><td>2601</td><td>未到期责任准备金</td><td></td><td>保险专用</td></tr><tr><td></td><td>2602</td><td>保险责任准备金</td><td></td><td>保险专用</td></tr><tr><td></td><td>2611</td><td>保户储金</td><td></td><td>保险专用</td></tr><tr><td></td><td>2621</td><td>独立账户负债</td><td></td><td>保险专用</td></tr><tr><td></td><td></td><td>长期债券</td><td>long-term bond</td><td></td></tr><tr><td></td><td>2701</td><td>长期应付款</td><td>long-term account payable</td><td></td></tr><tr><td></td><td>2702</td><td>未确认融资费用</td><td>unacknowledged financial charges</td><td></td></tr><tr><td></td><td>2711</td><td>专项应付款</td><td>special accounts payable</td><td></td></tr><tr><td></td><td>2801</td><td>预计负债</td><td>estimated liabilities</td><td></td></tr><tr><td></td><td>2901</td><td>递延所得税负债</td><td></td><td>deferred income tax liabilities</td></tr></tbody></table><h4 id="5-公共类科目"><a href="#5-公共类科目" class="headerlink" title="5.公共类科目"></a>5.公共类科目</h4><table><thead><tr><th>序号</th><th>科目代码</th><th>科目名称</th><th>英文名称</th><th>备注</th></tr></thead><tbody><tr><td><strong>共同类</strong></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>3001</td><td>清算资金往来</td><td></td><td>银行专用</td></tr><tr><td></td><td>3002</td><td>货币兑换</td><td></td><td>金融共用</td></tr><tr><td></td><td>3101</td><td>衍生工具</td><td>derivative tool</td><td></td></tr><tr><td></td><td>3201</td><td>套期工具</td><td>arbitrage tool</td><td></td></tr><tr><td></td><td>3202</td><td>被套期项目</td><td></td><td>arbitrage project</td></tr></tbody></table><h4 id="6-所有者权益类科目"><a href="#6-所有者权益类科目" class="headerlink" title="6.所有者权益类科目"></a>6.所有者权益类科目</h4><table><thead><tr><th>序号</th><th>科目代码</th><th>科目名称</th><th>英文名称</th><th>备注</th></tr></thead><tbody><tr><td><strong>所有者权益类</strong></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>4001</td><td>实收资本</td><td>paid-up capital</td><td></td></tr><tr><td></td><td>3103</td><td>已归还投资</td><td></td><td></td></tr><tr><td></td><td>4002</td><td>资本公积</td><td>contributed surplus</td><td></td></tr><tr><td></td><td>4101</td><td>盈余公积</td><td>earned surplus</td><td></td></tr><tr><td></td><td>4102</td><td>一般风险准备</td><td></td><td>金融共用</td></tr><tr><td></td><td>4103</td><td>本年利润</td><td>profit for the current year</td><td></td></tr><tr><td></td><td>4104</td><td>利润分配</td><td>allocation of profits</td><td></td></tr><tr><td></td><td>4201</td><td>库存股</td><td></td><td>treasury stock</td></tr></tbody></table><h4 id="7-成本类科目"><a href="#7-成本类科目" class="headerlink" title="7.成本类科目"></a>7.成本类科目</h4><table><thead><tr><th>序号</th><th>科目代码</th><th>科目名称</th><th>英文名称</th><th>备注</th></tr></thead><tbody><tr><td><strong>成本类</strong></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>5001</td><td>生产成本</td><td>production cost</td><td></td></tr><tr><td></td><td>5101</td><td>制造费用</td><td>cost of production</td><td></td></tr><tr><td></td><td>5201</td><td>劳务成本</td><td>service cost</td><td></td></tr><tr><td></td><td>5301</td><td>研发支出</td><td>research and development expenditures</td><td></td></tr><tr><td></td><td>5401</td><td>工程施工</td><td>engineering construction exclusively for construction contractor</td><td>建造承包商专用</td></tr><tr><td></td><td>5402</td><td>工程结算</td><td>engineering settlement exclusively for construction contractor</td><td>建造承包商专用</td></tr><tr><td></td><td>5403</td><td>机械作业</td><td>mechanical operation exclusively for construction contractor</td><td>建造承包商专用</td></tr></tbody></table><h4 id="8-损益类科目"><a href="#8-损益类科目" class="headerlink" title="8.损益类科目"></a>8.损益类科目</h4><table><thead><tr><th>序号</th><th>科目代码</th><th>科目名称</th><th>英文名称</th><th>备注</th></tr></thead><tbody><tr><td><strong>损益类</strong></td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>6001</td><td>主营业务收入</td><td>main business income</td><td></td></tr><tr><td></td><td>6011</td><td>利息收入</td><td>interest income</td><td>金融共用</td></tr><tr><td></td><td>6021</td><td>手续费及佣金收入</td><td>other business income</td><td>金融共用</td></tr><tr><td></td><td>6031</td><td>保费收入</td><td></td><td>保险专用</td></tr><tr><td></td><td>6041</td><td>租赁收入</td><td></td><td>租赁专用</td></tr><tr><td></td><td>6051</td><td>其他业务收入</td><td></td><td>包括固定资产盘盈、处置固定资产净收益、非货币性交易收益、出售无形资产收益、罚款净收入等</td></tr><tr><td></td><td>6061</td><td>汇兑损益</td><td>exchange gain or loss</td><td>金融共用</td></tr><tr><td></td><td>6101</td><td>公允价值变动损益</td><td>sound value flexible loss and profit</td><td></td></tr><tr><td></td><td>5201</td><td>投资收益</td><td>income on investment</td><td></td></tr><tr><td></td><td>6111</td><td>补贴收入</td><td></td><td></td></tr><tr><td></td><td>6201</td><td>摊回保险责任准备金</td><td></td><td></td></tr><tr><td></td><td>6202</td><td>摊回赔付支出</td><td></td><td>保险专用</td></tr><tr><td></td><td>6203</td><td>摊回分保费用</td><td></td><td>保险专用</td></tr><tr><td></td><td>6301</td><td>营业外收入</td><td>nonrevenue receipt</td><td></td></tr><tr><td></td><td>6401</td><td>主营业务成本</td><td>main business cost</td><td></td></tr><tr><td></td><td>6402</td><td>营业税金及附加</td><td>business tariff and annex</td><td>主营业务税金及附加 更名</td></tr><tr><td></td><td>6403</td><td>其他业务支出</td><td>other business expense</td><td></td></tr><tr><td></td><td>6411</td><td>利息支出</td><td>interest expense</td><td>金融共用</td></tr><tr><td></td><td>6421</td><td>手续费及佣金支出</td><td></td><td>金融共用</td></tr><tr><td></td><td>6501</td><td>提取未到期责任准备金</td><td></td><td>保险专用</td></tr><tr><td></td><td>6502</td><td>提取保险责任准备金</td><td></td><td>保险专用</td></tr><tr><td></td><td>6511</td><td>赔付支出</td><td></td><td>保险专用</td></tr><tr><td></td><td>6521</td><td>保户红利支出</td><td></td><td>保险专用</td></tr><tr><td></td><td>6531</td><td>退保金</td><td></td><td>保险专用</td></tr><tr><td></td><td>6541</td><td>分出保费</td><td></td><td>保险专用</td></tr><tr><td></td><td>6542</td><td>分保费用</td><td></td><td>保险专用</td></tr><tr><td></td><td>6601</td><td>销售费用</td><td>marketing cost</td><td>“营业费用”改名</td></tr><tr><td></td><td>6602</td><td>管理费用</td><td>managing cost</td><td></td></tr><tr><td></td><td>6603</td><td>财务费用</td><td>financial cost</td><td></td></tr><tr><td></td><td>6604</td><td>勘探费用</td><td>exploration expense</td><td></td></tr><tr><td></td><td>6701</td><td>资产减值损失</td><td>loss from asset devaluation</td><td>各类资产计提减值时，贷记相关损失准备科目，借记本科目</td></tr><tr><td></td><td>6711</td><td>营业外支出</td><td>nonoperating expense</td><td></td></tr><tr><td></td><td>6801</td><td>所得税费用</td><td>income tax</td><td>所得税 更名</td></tr><tr><td></td><td>6901</td><td>以前年度损益调整</td><td></td><td>prior year profit and loss adjustment</td></tr></tbody></table><h3 id="9-借贷记账法-账户"><a href="#9-借贷记账法-账户" class="headerlink" title="9.借贷记账法-账户"></a>9.借贷记账法-账户</h3><ul><li><p><strong>账户是用来连续、系统、完整的记录企业经济活动的载体，因此具备一定的结构。</strong></p></li><li><p><strong>账户的机构可以分层两个基本部分，即左右两方，分别记录会计要素的增加和减少，一方登记增加、另一方登记减少。因此账户左右两方的名称，那一方登记增加，取决于采用的记账方法和该账户记录的经济内容。</strong></p></li><li><p>账户四要素</p><ul><li>期初余额、期末余额、本期增加发生额、本期减少发生额</li><li>期末余额 &#x3D; 期初余额 + 本期增加发生额 - 本期减少发生额</li></ul><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201221505.png">  </p></li><li><p>借贷记账法的账户格式：T形账户</p><ul><li>左方为借方、右方为贷方，所有账户的借方和贷方按相反，记录增加和减少，即一方登记增加额，另一方就登记减少额。</li></ul></li><li><p>特别注意：在业务系统中，并不会按照财务系统中的记账记录数据，因此需要使用特定的处理手段（<strong>财务引擎</strong>）进行转换处理。</p><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201222259.png"></p></li></ul><h3 id="10-借贷记账法-分录"><a href="#10-借贷记账法-分录" class="headerlink" title="10.借贷记账法-分录"></a>10.借贷记账法-分录</h3><ul><li>会计分录，简称分录；对每一项经济业务列示出应借、应贷的账户名称（科目）及其金额的一种记录。<ul><li><strong>分录由应借、互相对应的科目、金额三要素组成</strong>，可分为：简单会计分录（一借一贷）和复合会计分录（借贷科目大于等于3个）；在中国会计分录记载于会计凭证中。</li></ul></li><li><strong>借贷记账法下的账户对应关系</strong><ul><li>是指采用借贷记账法对每笔交易或者事项进行记录时，相关账户之间形成的应借、应贷的相互关系；存在对应关系的账户称为“对应账户”</li></ul></li></ul><h3 id="11-借贷记账法-试算平衡"><a href="#11-借贷记账法-试算平衡" class="headerlink" title="11.借贷记账法-试算平衡"></a>11.借贷记账法-试算平衡</h3><ul><li><p>根据借贷记帐法的记帐规则和资产与权益（负债和所有者权益）的恒等关系，通过对所有账户发生额和余额的汇总计算比较来检查账户记录是否正确的一种方式。</p><ul><li>发生额试算平衡分类<ul><li>发生额试算平衡：全部账户本期借方发生额合计和本期贷方发生额合计保持平衡。<strong>全部账户<strong><strong>本期</strong></strong>借方额合计 &#x3D; 全部账户<strong><strong>本期</strong></strong>贷方发生额合计</strong>。<ul><li>依据：有借必有贷、借贷必相等</li></ul></li><li>余额试算平衡：全部账户借方期末（初）余额合计与全部账户贷方期末（初）余额合计保持平衡。<strong>全部账户借方<strong><strong>期初</strong></strong>余额合计 &#x3D; 全部账户贷方<strong><strong>期初</strong></strong>余额合计、全部账户借方<strong><strong>期末</strong></strong>余额合计 &#x3D; 全部账户贷方<strong><strong>期末</strong></strong>余额合计。</strong><ul><li>依据：资产 &#x3D; 负债 + 所有者权益</li></ul></li></ul></li></ul><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201225243.png"></p></li></ul><h3 id="12-对账结账"><a href="#12-对账结账" class="headerlink" title="12.对账结账"></a>12.对账结账</h3><h4 id="对账"><a href="#对账" class="headerlink" title="对账"></a>对账</h4><ul><li>对账时对帐薄记录所进行的核对工作，也就是核对账目。对账工作一般在记账之后结账之前，即在月末进行，对账一般分类账证核对，账账核对、帐实核对。<ul><li>账证核对：帐薄记录与会计凭证核对，核对帐薄记录与原始凭证、记账凭证的时间、凭证字号、内容、金额等是否一致，记账方向是否相符</li><li>账账核对：总分类帐薄的核对，总分类帐薄欲所辖明细分类帐薄的核对，总分类帐薄欲序时帐薄之间的核对，明细分类帐薄之间的核对</li><li>帐实核对：指各项财务物资，债券债务等帐面余额与实有数额之间的核对。<ul><li>库存现金日记账与现金库存实际数核对</li><li>银行存款日记帐的帐余额与银行账单余额定期核对是否相符</li><li>各项财产物资明细帐帐面余额与财产资实实际数定期核对是否相符</li><li>有关债券债务明细帐帐面余额与对应单位债券债务帐面记录核对是否相符</li></ul></li></ul></li></ul><h4 id="结账"><a href="#结账" class="headerlink" title="结账"></a>结账</h4><ul><li>结账是将帐薄记录定期结算清楚的工作，编制报表进行月结、季结、年结<ul><li>结算各种损益类账户、计算确定本期利润。</li><li>结出各资产、负债和所有者权益账户的本期发生额合计和期末余额。</li></ul></li></ul><h3 id="13-错帐更正"><a href="#13-错帐更正" class="headerlink" title="13.错帐更正"></a>13.错帐更正</h3><blockquote><p>记账过程中，可能由于种种原因会使账簿记录发生错误，应当采取正确、规范托方法予以更正</p></blockquote><p>1.划线更正法(账簿有错，记账凭证没错)</p><ul><li>在结账前发现账簿记录有文字或者数字错误，而记账凭证没有错误，应当采用划线更正法。更正时可在错误的文字或者数字上划一条红线，在红线的上方填写正确的文字或数字，并由记账人员和会计机构负责人在更正处盖章，已明确责任</li></ul><p>2.红字更正法(记账凭证科目有错或者科目没错金额多记)</p><ul><li>记账后发现记账凭证中应借、应贷会计科目有错误引起的记账错误;用红字写相同的，摘要写”中销xx凭证”，用蓝字写一张正确的凭证</li><li>记账后发现凭证和账簿中应借、应贷科目无误，只是所记金额大于应金额所引起的错误;红字写多记的金额的相同凭证，摘要“冲销XXX’</li></ul><p>3.补充登记法(记账凭证科目没错但金额少记)</p><ul><li>记账后发现记账凭证和账簿记录中科目无误，只是所记金额小于应记金额的错误，应当采用补充登记法;按少记金额用蓝字填制一张与原始凭证</li><li>记账凭证应借应贷科目完全相同的记账凭证，摘要写明“补记XXXX记账凭证少记金额”</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;会计基础&quot;&gt;&lt;a href=&quot;#会计基础&quot; class=&quot;headerlink&quot; title=&quot;会计基础&quot;&gt;&lt;/a&gt;会计基础&lt;/h2&gt;&lt;h3 id=&quot;1-权责发生制和收付实现制&quot;&gt;&lt;a href=&quot;#1-权责发生制和收付实现制&quot; class=&quot;headerlink&quot; title=&quot;1. 权责发生制和收付实现制&quot;&gt;&lt;/a&gt;1. 权责发生制和收付实现制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;权责发生制和收付实现制是两种相对应的核算制度，由于&lt;strong&gt;权责发生制相较于收付实现制可以更好地反映企业实际经营情况&lt;/strong&gt;，我国要求企业必须使用权责发生制进行核算。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;权责发生制&quot;&gt;&lt;a href=&quot;#权责发生制&quot; class=&quot;headerlink&quot; title=&quot;权责发生制&quot;&gt;&lt;/a&gt;&lt;strong&gt;权责发生制&lt;/strong&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;又称应收应付制。凡在本期发生应从本期收入中获得补偿的费用，不论是否在本期已实际支付或未付的货币资金，均应作为本期的费用处理；凡在本期发生应归属于本期的收入，不论是否在本期已实际收到或未收到的货币资金，均应作为本期的收入处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简单解释：&lt;/strong&gt;只要交易行为发生，记账周期内不管有没有收到钱，都确认记账。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;收付实现制&quot;&gt;&lt;a href=&quot;#收付实现制&quot; class=&quot;headerlink&quot; title=&quot;收付实现制&quot;&gt;&lt;/a&gt;&lt;strong&gt;收付实现制&lt;/strong&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;凡在本期内实际收到或付出的一切款项，无论其发生时间早晚或是否应该由本期承担，均作为本期的收益和费用处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;简单解释：&lt;/strong&gt;只有收到钱了才确认记账，不管这笔交易实际上是发生在哪个周期。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-单式记账法和复式记账法&quot;&gt;&lt;a href=&quot;#2-单式记账法和复式记账法&quot; class=&quot;headerlink&quot; title=&quot;2. 单式记账法和复式记账法&quot;&gt;&lt;/a&gt;2. 单式记账法和复式记账法&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;单式记账法和复式记账法是两种不同的记账方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;单式记账法：我们日常所说的&lt;strong&gt;流水账，只记录收入支出的流水，而没有记录流水与账户的对应关系。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;复式记账法：要求&lt;strong&gt;每一笔流水都记录在两个以上的账簿中，用于反映流水与账户的对应关系&lt;/strong&gt;，并能够更清晰地看到每个账户的余额，&lt;strong&gt;我国企业所用的借贷记账法即是复式记账法的一种。&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;记账规则：有借必有贷、借贷必相等。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-资产-负债-所有者权益&quot;&gt;&lt;a href=&quot;#3-资产-负债-所有者权益&quot; class=&quot;headerlink&quot; title=&quot;3.资产 &amp;#x3D; 负债+ 所有者权益&quot;&gt;&lt;/a&gt;3.资产 &amp;#x3D; 负债+ 所有者权益&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;这条等式被称为&lt;strong&gt;会计恒等式&lt;/strong&gt;，是一切会计对应关系和核算的基础。在我们的日常观念中，这一条等式其实是很反人类的，为什么资产会由负债组成？&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240129212700.png&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其实举一个简单的栗子就可以理解，正如贷款购房，房产总价 1000 万，我首付 400 万，剩余 600 万我贷款，那么在这个场景中，我已经购买了房子，1000 万就是我的资产，但这又不完全都是我自己的，只有 400 万才真正是我自己的，剩下的 600 万其实是我的负债，我还需要把负债还清了，因此，所有者权益又被称为净资产。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240129212839.png&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;4-记账方式&quot;&gt;&lt;a href=&quot;#4-记账方式&quot; class=&quot;headerlink&quot; title=&quot;4. 记账方式&quot;&gt;&lt;/a&gt;4. 记账方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;记账方式就是&lt;strong&gt;把复式记账法+ 会计恒等式结合在一起&lt;/strong&gt;，并写出会计的&lt;strong&gt;分录&lt;/strong&gt;，举一些的例子：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240202182205.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;用现金花了100 块买衣服：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;借：衣服 100&lt;/li&gt;
&lt;li&gt;贷：现金 100&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  &lt;strong&gt;用花呗花了 100块买衣服：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;借：衣服 100&lt;/li&gt;
&lt;li&gt;贷：花呗 100&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  &lt;strong&gt;用花呗花了10块钱吃饭：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;借：吃饭 10&lt;/li&gt;
&lt;li&gt;贷：花呗 10&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  &lt;strong&gt;「借」反映的是资产的增加、负债和所有者权益的减少，而「贷」反映的是资产的减少、负债和所有者权益的增加&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Life" scheme="https://z201.cn/categories/Life/"/>
    
    
    <category term="Life" scheme="https://z201.cn/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>业务知识-什么是财务</title>
    <link href="https://z201.cn/posts/690880986/"/>
    <id>https://z201.cn/posts/690880986/</id>
    <published>2024-01-08T14:36:43.000Z</published>
    <updated>2024-02-02T15:04:28.199Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>1970年，诺贝尔经济学奖得主弗里德曼（Friedman）提出“企业从事旨在提高利润的活动”，这种“股东至上”主义在很长一段时间被认为是美国企业的使命。1997年，由美国近200家最著名企业的首席执行官组成的协会——商业圆桌会议（Business Round Table，以下简称BRT），他们这样定义企业的使命（Mission）：管理层和董事会的首要职责是对企业股东负责，而其他利益相关者是对股东责任的派生物。<br>2019年8月19日，BRT 发布了一份新的企业使命宣言，其中强调企业要“为客户创造价值、投资于员工、公平且合乎道德地与供应商打交道、支持我们的社区、保护环境”。这样的使命宣言，更加强调企业的社会责任（Social Responsibility），即企业股东利益最大化可以，但是有条件。<br>由此得出企业存在的意义就是盈利，通过各类经济活动获得利润，并向股东分红；同时为了扩大经营，又会不断获取新的投资。</p></blockquote><h2 id="一、什么是财务"><a href="#一、什么是财务" class="headerlink" title="一、什么是财务"></a>一、什么是财务</h2><blockquote><p>财务是一个很泛的概念，可理解为跟公司资金流动相关的一切活动及关系，按照财务管理的定义，一般会包括<strong>筹资、投资、日常管理及利润分配</strong>四部分。公司里只要是跟钱相关的，都需要有财务的介入，而当业务进行到一定体量时，财务会深入业务流程以控制成本、提高收益率，同时财务还会负责公司的经营风险评估和控制，影响公司的经营决策。</p></blockquote><ul><li>筹资即是筹措资金的动作，包括外部融资和内部融资两种方式，所谓有钱才能办事，筹资是一切经济活动开展的基础</li><li>投资即是把筹到的资金进行合理使用，这里的投资不仅仅包括我们平时常见的对外投资，还包括对内投资，即是将资金用于扩大内部生产经营</li><li>日常管理则是财务的日常工作，包括预算、应收应付管理、存货管理、成本控制等等一系列细致而繁杂的工作</li><li>利润分配就是大家喜闻乐见的分钱环节，辛辛苦苦一整年，就盼着最后分点钱</li><li><strong>对企业日常经济活动进行记录、衡量、出报表的过程。</strong><ul><li>会计主体：设定会计范围、公司主体范围</li><li>持续经营：没倒闭，理论上无限期。</li><li>分期：月报、季报、半年报告、年报。</li><li>货币计量：设定记账本的货币，本国货币：人民币。</li><li>全责发生制：以收取款项的权力，和支付款项的义务为标志来确定本期收入和费用会计核算基础。</li></ul></li></ul><h3 id="财务相关的知识领域"><a href="#财务相关的知识领域" class="headerlink" title="财务相关的知识领域"></a>财务相关的知识领域</h3><blockquote><p>国内“注册会计师”的六大学科。</p></blockquote><ul><li>《会计学》主要对应“对经济事项的记录、分类和汇总，输出财务报表”这一过程所适用的会计准则和执行规范；</li><li>《财务管理》主要对应站在甲方企业的视角，进行资本管理、投融资管理、收入成本管理、盈余管理、预算管理和财务分析等活动；</li><li>《公司战略与风险管理》主要对应企业的战略分析、制定和管理，以及风险管理等活动；</li><li>《审计学》主要对应审计的一般程序、内部控制、职业道德等内容；</li><li>《经济法》和《税法》主要对应我国商业相关法律法规的框架构建、制度要求和执行规范。</li></ul><h3 id="岗位划分"><a href="#岗位划分" class="headerlink" title="岗位划分"></a>岗位划分</h3><blockquote><p>常见的财务活动如，财务规划、收入核算、总账与报表、固定资产管理、员工薪酬、税务等</p></blockquote><ul><li>按照岗位划分的话，财务可以被划分为会计、出纳、审计、财务管理等。</li><li>除此之外，财务工作和岗位还包括内部控制、风险管理、税务筹划、信息披露、上市筹备等。除去这些基础业务岗位，很多集团型公司尤其是上市公司还会单独设置信用会计、成本会计、资金专员、税务专员、预算专员、财务BP等细分岗位，以满足更为细致的数据出具和财务管理要求。</li></ul><h3 id="财务软件"><a href="#财务软件" class="headerlink" title="财务软件"></a>财务软件</h3><ul><li><p>一家集团型公司尤其是上市公司，其财务核算、财报编制、财务管理、税务管理、经营内控等制度要求都是非常严格、标准和精细化的。当一家公司的财务信息化建设到达一定规模时，其财务管理相关的IT投入会逐渐发生边际成本递减，而这一切成本集约化的前提，便是构建一套符合公司业务场景、流程的现状与未来，能够准确进行数据输出并辅助管理决策的自研财务产品体系。</p></li><li><p><strong>正常情况下，业务系统通常只会记录流水，正确的记录业务流水。通过会计账单引擎进行转换，转换成财务需要的凭证格式。</strong></p><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240202174640.png"></p></li></ul><span id="more"></span><h3 id="常用财务名词"><a href="#常用财务名词" class="headerlink" title="常用财务名词"></a>常用财务名词</h3><h4 id="应收"><a href="#应收" class="headerlink" title="应收"></a><strong>应收</strong></h4><ul><li>是指在提供服务、销售产品等过程中应该向购买单位（用户）收取的款项；对于预付货款在财务中属于应收款，待结算后会进行结转，具体看财务业务要求。</li></ul><h4 id="应付"><a href="#应付" class="headerlink" title="应付"></a><strong>应付</strong></h4><ul><li>是指企业应支付但尚未支付的款项（货款、佣金、服务费等），在电商系统中主要的款项是商品采购的货款或应付的提成佣金等；对于预收货款是属于负债，待订单完结时财务会进行结转。</li></ul><h4 id="销售收入"><a href="#销售收入" class="headerlink" title="销售收入"></a><strong>销售收入</strong></h4><ul><li>是企业通过产品销售或提供劳务所获得的货币收入，以及形成的应收货款，我们这里主要是指销售商品产生的收入即企业的主营业务收入。</li></ul><h4 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h4><ul><li>成本是指已销售产品的生产成本或已提供劳务的劳务成本以及其他销售的业务成本，成本有直接成本与间接成本，在我们的系统中主要是指商品的直接成本即采购商品的成本。</li></ul><h4 id="毛利"><a href="#毛利" class="headerlink" title="毛利"></a><strong>毛利</strong></h4><ul><li>毛利是指销售产品赚取的金额，我们这里主要指销售收入减去销售成本，在财务系统中可能会把相关的费用等分摊在成本中，这就是销售毛利。</li></ul><h4 id="毛利率"><a href="#毛利率" class="headerlink" title="毛利率"></a><strong>毛利率</strong></h4><ul><li><strong>销售毛利&#x3D;销售收入-销售成本</strong>（<strong>毛利率&#x3D;毛利&#x2F;销售收入</strong><em><strong>100%&#x3D;(销售收入-销售成本)&#x2F;销售收入</strong></em>**100%**）</li></ul><h4 id="进项税率"><a href="#进项税率" class="headerlink" title="进项税率"></a><strong>进项税率</strong></h4><ul><li>是商品税率，一般指在采购商品时的商品税率，根据进项税计算的税额称之为进项税额,是指纳税人购进货物、加工修理修配劳务、服务、无形资产或者不动产,支付或者负担的增值税额。</li></ul><h4 id="销项税率"><a href="#销项税率" class="headerlink" title="销项税率"></a><strong>销项税率</strong></h4><ul><li>是商品税率，一般指在销售商品时的商品税率，销项税额是指增值税纳税人销售货物和应交税劳务，按照销售额和适用税率计算并向购买方收取的增值税税额。</li></ul><h4 id="增值税"><a href="#增值税" class="headerlink" title="增值税"></a><strong>增值税</strong></h4><ul><li>增值税是对商品生产、流通、劳务服务中多个环节的新增价值或商品的附加值征收的一种流转税；对于我们的系统主要是指采购时产生的增值税，以及销售过程中产生的销售项，企业每个月会根据进项税与销售税向税务局进行申报，经过进项税销项的抵扣，最终确定企业的纳税金额（这里都是根据税票及销售收入）。</li></ul><h4 id="发票"><a href="#发票" class="headerlink" title="发票"></a><strong>发票</strong></h4><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201145620.png"></p><ul><li>上面提到税率与增值税，就不得不得到发票，发票分为普通发票与增值税专用发票，普通发票是一般指小规模纳税人销售商品时开具的发票（如餐馆、服装等），增值税专用发票是具用普票的作用，专用于纳税人销售或者提供增值税应税项目的一种发票，随着国家增值税的改革，发票的作用越来越大，所以在财务系统中税票管理也要求比较严格。</li></ul><h4 id="钩稽与核销"><a href="#钩稽与核销" class="headerlink" title="钩稽与核销"></a><strong>钩稽与核销</strong></h4><ul><li><p>核销：就是销账，减少坏账；收到发票之后就可以核销相应账目；</p></li><li><p>勾稽：是指某个会计报表和另一个会计报表之间以及本会计报表项目的内在逻辑对应关系，如果不相等或不对应，这说明会计报表编制出现问题。比如采购场景</p><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201193006.png"></p><ul><li>这里的发票可以是广义的票据，比如消费的小票、增值税发票等，所以不同的款项可能要开不同的发票，不同的对象可能要开的发票也不同，而不同的国家需要的发票种类也不同，这要看这个国家此类活动需要什么税种。<ul><li>为了正确地了解开出的发票是否多已入账，要<strong>将发票存根联与在财务记帐凭证中的记账联进行核对，匹配成功发票为已核销</strong>，这个过程称为发票的核销。特别是较大的企业发票在营销部开具时财务部必须要有核销的过程。</li></ul></li><li>应收账款的核销，发生一笔应收账款后，也许要分多次收回，这样记账员必须在对每一笔应收账款有个核算的过程，这样来防止呆账及坏账。</li><li>应付账款的核销，发生应付账款后企业也可能不是一下子就付清了，有时要多次进行付款，这时记账员也必须进行核销，防止多付账款。</li></ul><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201192944.png"></p><ul><li>通过核销进入明细帐</li></ul><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201194009.png"></p></li></ul><h4 id="经销"><a href="#经销" class="headerlink" title="经销"></a><strong>经销</strong></h4><ul><li>在财务上一般按照货物所有权来划分的。如果货物采购入库后所有权属于我司，则属于经销，即我们买入商品进行零售处理，售价的定价权在我司，我们只根据实际采购与采购退货的单据进行与供应商结算；这种模式的缺点是如果销售不好，库存积压占用现金流很大。<ul><li><strong>拿钱找供货方进货，然后转手卖出去</strong>；<strong>赚取价格差。</strong></li></ul></li></ul><h4 id="代销"><a href="#代销" class="headerlink" title="代销"></a><strong>代销</strong></h4><ul><li>代销是指货物采购入库后，虽然货物的保管处理都由我司处理，但是我司会以实际销售出库的成本价（或结算价）与供应商进行结算，销售不了商品最终根据合同条款可以退还给供应商，这种模式的优点是卖一件结一件，只是我司会有管理货物的成本等，但库存占用现金流的风险没有。<ul><li><strong>有偿帮卖货，供应商授权商品给你或者企业，不需要采购囤货，由供应商直接发货，或者由你发货给消费者。你赚佣金的模式。</strong></li></ul></li></ul><h4 id="联营"><a href="#联营" class="headerlink" title="联营"></a><strong>联营</strong></h4><ul><li>联营，顾名思义，就是供货商与零售商共同销售商品，零售商会根据销售的金额按照协定的扣点进行提成，这在百货商场等非常常见，像现在所说的扣率代销、佣金提成等基本与联营类似；目前像天猫、京东等平台的又是一种模式与联营非常像。</li></ul><h4 id="移动加权平均"><a href="#移动加权平均" class="headerlink" title="移动加权平均"></a><strong>移动加权平均</strong></h4><ul><li>最常用的成本核算方式之一，每年的审计部门是比较关注这部分的，因为成本影响到公司的利润、管理层的运营决策等；财务成本计算有其它几种如加权平均、先进先出、后进先出（在我国是不允许这种计价方式）</li></ul><h4 id="成本-1"><a href="#成本-1" class="headerlink" title="成本"></a><strong>成本</strong></h4><ul><li>在FMS（财务系统）中主要是主营业务成本，不包括人工费、管理费以及财务费用等，在财务进销存中主要进货的金额经过“成本核算方法”而计算出来的成本。</li></ul><h4 id="含税金额、未税金额、税额"><a href="#含税金额、未税金额、税额" class="headerlink" title="含税金额、未税金额、税额"></a><strong>含税金额、未税金额、税额</strong></h4><ul><li>这几个是有关联的，而且是和税率有关的，前面说的成本一般是根据进项税率计算，销售金额是按销项税率计算，公式如下：</li><li><strong>不含税金额&#x3D;含税金额&#x2F;(1+税率&#x2F;100)</strong></li><li><em><strong>税额&#x3D;含税金额-不含税金额&#x3D;含税金额</strong></em><strong>(税率&#x2F;100)&#x2F;(1+税率&#x2F;100)</strong></li></ul><h4 id="基准价"><a href="#基准价" class="headerlink" title="基准价"></a><strong>基准价</strong></h4><ul><li>系统中基准价是指基准进价，是采购订单(PO单)录入时默认的采购进价，商品的采购进价不能高于基准价，以控制采购风险。</li></ul><h4 id="期初"><a href="#期初" class="headerlink" title="期初"></a>期初</h4><ul><li>一般指期初余额，是期初已存在的账户余额，也是由上期结转至本期的金额或上期期末余额调整后的金额，主要用于反映以前期间的交易和上期采用的会计政策的结果。</li></ul><h4 id="账期"><a href="#账期" class="headerlink" title="账期"></a><strong>账期</strong></h4><ul><li>账期是指供应商商品到货至付款完成这一段时间，对于公司来说账期越长越有利（现金流）；财务系统中是以结算单生成到付款完成这一时间定义为账期（因为有的结算单是每月生成，有的是半月生成，有的是依赖销售单据生成如代销）。</li></ul><h4 id="结算周期"><a href="#结算周期" class="headerlink" title="结算周期"></a><strong>结算周期</strong></h4><ul><li>结算周期是指结算单什么时间生成，在我们的合同中有T+0即昨天当天数据当天生成，T+1即当天数据第二天生成，每周生成，每月生成（每月1日生成）或半月生成(16日生成)</li></ul><table><thead><tr><th>名词</th><th>描述</th></tr></thead><tbody><tr><td>T1结算</td><td>指工作日结算：当天收单，下一个工作日结算。</td></tr><tr><td>D1结算</td><td>指自然日结算：当天收单，次日结算，365天都支持结算。</td></tr><tr><td>D0 结算</td><td>指交易完成后即可以结算；自动结算（每笔交易完成自动结算）、自助结算（交易完成后，主动发起结算）</td></tr><tr><td>清分</td><td>清分是计算应收、应付的过程</td></tr><tr><td>记账</td><td>记账是将清分结果记入账户的过程（收款账号）</td></tr><tr><td>清算</td><td>清算 &#x3D; 清分 + 记账</td></tr><tr><td>结算</td><td>结算 &#x3D; 扣款 + 付款：根据清算结果实现资金转移</td></tr><tr><td>虚拟资金</td><td>客户暂存在平台账户内的资金</td></tr><tr><td>结算对账单</td><td>参与结算交易明细的问题，一次结算对应一个结算账单，用于三方核对账单金额是否准确。</td></tr></tbody></table><h4 id="财务凭证"><a href="#财务凭证" class="headerlink" title="财务凭证"></a><strong>财务凭证</strong></h4><ul><li>此部分根据财务相关业务单据或财务报表，每天或每月根据财务会计科目生成的会记分录，目前我国使用的是借贷记账法（有借必有贷，借贷必相等）;编写财务记账凭证要根据以下两个恒等式进行。<ul><li><strong>公式1：资产＝负债+所有者权益公式</strong> </li><li><strong>公式2：利润 &#x3D; 收入－费用</strong></li></ul></li></ul><h4 id="财务总账与明细账"><a href="#财务总账与明细账" class="headerlink" title="财务总账与明细账"></a><strong>财务总账与明细账</strong></h4><ul><li>每月财务都会进行月结，然后生成凭证，最终为总账，相对于详细的财务账为明细账，具体看公司财务部的要求。</li></ul><h4 id="账套"><a href="#账套" class="headerlink" title="账套"></a><strong>账套</strong></h4><ul><li>这是财务软件中的重要部分，可以按分公司、分部门建立多个账套，不同账套间可能会产生公司间交易，这个根据财务规划确定的。</li></ul><h4 id="权限发生制"><a href="#权限发生制" class="headerlink" title="权限发生制"></a><strong>权限发生制</strong></h4><ul><li>权责发生制又称“应收应付制”。它是以本会计期间发生的费用和收入是否应计入本期损益为标准，处理有关经济业务的一种制度；权责发生制是以权利和责任的发生来决定收入和费用归属期的一项原则</li></ul><h4 id="收付实现制"><a href="#收付实现制" class="headerlink" title="收付实现制"></a><strong>收付实现制</strong></h4><ul><li>收付实现制亦称“收付实现基础”或“现收现付制”。是“权责发生制”的对称。在会计核算中，是以款项是否已经收到或付出作为计算标准，来确定本期收益和费用的一种方法。</li></ul><h4 id="存货"><a href="#存货" class="headerlink" title="存货"></a><strong>存货</strong></h4><ul><li>就是库存，主要是指商品在仓库的库存金额与数量，高库存会占有现金所以风险很高，供应链中有些都在追求零库存（特殊行业除外）。</li></ul><h4 id="库龄"><a href="#库龄" class="headerlink" title="库龄"></a><strong>库龄</strong></h4><ul><li>是指存货商品在库时间，商品出库正常是按其生产日期先进先出的，统计库龄能够很好的判断商品在库情况（30天、60天、90天）</li></ul><p><strong>库存周转天数</strong></p><ul><li>是老板与财务极为关注的重要指标。 公式为：</li><li><strong>库存周转天数＝销售收入&#x2F;((期初库存+期末库存)&#x2F;2)、</strong></li><li><strong>在财务分析上一般采用：库存周转天数＝销售成本&#x2F;((期初库存+期末库存)&#x2F;2)</strong> ；库存周转天数越小越好，证明商品的流转非常快。</li><li><strong>库存周转率＝360&#x2F;库存周转天数。</strong></li></ul><p><strong>暂估入库</strong></p><ul><li><p>暂时估算的意思。暂估入库指的是企业购买商品，商品已经验收入库，但是企业还没有收到发票，在月末合理估计入库成本。</p><p>  <img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240201214702.png"></p><ul><li>暂估回冲时，如果发生了实际确认的入库成本与暂估金额不一致，该如何处理呢？财务系统会根据实际成本与暂估金额的差额自动生成暂估补差单来调整入库成本，若实际成本大于暂估成本，则生成一张金额为正的暂估补差单；反之，则生成一张金额为负的暂估补差单。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;1970年，诺贝尔经济学奖得主弗里德曼（Friedman）提出“企业从事旨在提高利润的活动”，这种“股东至上”主义在很长一段时间被认为是美国企业的使命。1997年，由美国近200家最著名企业的首席执行官组成的协会——商业圆桌会议（Business Round Table，以下简称BRT），他们这样定义企业的使命（Mission）：管理层和董事会的首要职责是对企业股东负责，而其他利益相关者是对股东责任的派生物。&lt;br&gt;2019年8月19日，BRT 发布了一份新的企业使命宣言，其中强调企业要“为客户创造价值、投资于员工、公平且合乎道德地与供应商打交道、支持我们的社区、保护环境”。这样的使命宣言，更加强调企业的社会责任（Social Responsibility），即企业股东利益最大化可以，但是有条件。&lt;br&gt;由此得出企业存在的意义就是盈利，通过各类经济活动获得利润，并向股东分红；同时为了扩大经营，又会不断获取新的投资。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、什么是财务&quot;&gt;&lt;a href=&quot;#一、什么是财务&quot; class=&quot;headerlink&quot; title=&quot;一、什么是财务&quot;&gt;&lt;/a&gt;一、什么是财务&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;财务是一个很泛的概念，可理解为跟公司资金流动相关的一切活动及关系，按照财务管理的定义，一般会包括&lt;strong&gt;筹资、投资、日常管理及利润分配&lt;/strong&gt;四部分。公司里只要是跟钱相关的，都需要有财务的介入，而当业务进行到一定体量时，财务会深入业务流程以控制成本、提高收益率，同时财务还会负责公司的经营风险评估和控制，影响公司的经营决策。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;筹资即是筹措资金的动作，包括外部融资和内部融资两种方式，所谓有钱才能办事，筹资是一切经济活动开展的基础&lt;/li&gt;
&lt;li&gt;投资即是把筹到的资金进行合理使用，这里的投资不仅仅包括我们平时常见的对外投资，还包括对内投资，即是将资金用于扩大内部生产经营&lt;/li&gt;
&lt;li&gt;日常管理则是财务的日常工作，包括预算、应收应付管理、存货管理、成本控制等等一系列细致而繁杂的工作&lt;/li&gt;
&lt;li&gt;利润分配就是大家喜闻乐见的分钱环节，辛辛苦苦一整年，就盼着最后分点钱&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对企业日常经济活动进行记录、衡量、出报表的过程。&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;会计主体：设定会计范围、公司主体范围&lt;/li&gt;
&lt;li&gt;持续经营：没倒闭，理论上无限期。&lt;/li&gt;
&lt;li&gt;分期：月报、季报、半年报告、年报。&lt;/li&gt;
&lt;li&gt;货币计量：设定记账本的货币，本国货币：人民币。&lt;/li&gt;
&lt;li&gt;全责发生制：以收取款项的权力，和支付款项的义务为标志来确定本期收入和费用会计核算基础。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;财务相关的知识领域&quot;&gt;&lt;a href=&quot;#财务相关的知识领域&quot; class=&quot;headerlink&quot; title=&quot;财务相关的知识领域&quot;&gt;&lt;/a&gt;财务相关的知识领域&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;国内“注册会计师”的六大学科。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;《会计学》主要对应“对经济事项的记录、分类和汇总，输出财务报表”这一过程所适用的会计准则和执行规范；&lt;/li&gt;
&lt;li&gt;《财务管理》主要对应站在甲方企业的视角，进行资本管理、投融资管理、收入成本管理、盈余管理、预算管理和财务分析等活动；&lt;/li&gt;
&lt;li&gt;《公司战略与风险管理》主要对应企业的战略分析、制定和管理，以及风险管理等活动；&lt;/li&gt;
&lt;li&gt;《审计学》主要对应审计的一般程序、内部控制、职业道德等内容；&lt;/li&gt;
&lt;li&gt;《经济法》和《税法》主要对应我国商业相关法律法规的框架构建、制度要求和执行规范。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;岗位划分&quot;&gt;&lt;a href=&quot;#岗位划分&quot; class=&quot;headerlink&quot; title=&quot;岗位划分&quot;&gt;&lt;/a&gt;岗位划分&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;常见的财务活动如，财务规划、收入核算、总账与报表、固定资产管理、员工薪酬、税务等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;按照岗位划分的话，财务可以被划分为会计、出纳、审计、财务管理等。&lt;/li&gt;
&lt;li&gt;除此之外，财务工作和岗位还包括内部控制、风险管理、税务筹划、信息披露、上市筹备等。除去这些基础业务岗位，很多集团型公司尤其是上市公司还会单独设置信用会计、成本会计、资金专员、税务专员、预算专员、财务BP等细分岗位，以满足更为细致的数据出具和财务管理要求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;财务软件&quot;&gt;&lt;a href=&quot;#财务软件&quot; class=&quot;headerlink&quot; title=&quot;财务软件&quot;&gt;&lt;/a&gt;财务软件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一家集团型公司尤其是上市公司，其财务核算、财报编制、财务管理、税务管理、经营内控等制度要求都是非常严格、标准和精细化的。当一家公司的财务信息化建设到达一定规模时，其财务管理相关的IT投入会逐渐发生边际成本递减，而这一切成本集约化的前提，便是构建一套符合公司业务场景、流程的现状与未来，能够准确进行数据输出并辅助管理决策的自研财务产品体系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;正常情况下，业务系统通常只会记录流水，正确的记录业务流水。通过会计账单引擎进行转换，转换成财务需要的凭证格式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20240202174640.png&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Life" scheme="https://z201.cn/categories/Life/"/>
    
    
    <category term="Life" scheme="https://z201.cn/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Project-Boi</title>
    <link href="https://z201.cn/posts/3726754257/"/>
    <id>https://z201.cn/posts/3726754257/</id>
    <published>2023-04-09T14:19:20.000Z</published>
    <updated>2024-01-06T13:38:04.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>幸得领导信任，负责BOI项目资料整理申报;第一次做跨国项目申报，资料多次修改后最终申请通过，历经4个月申请排队；终于在2023-04得到BOI批准。</p></blockquote><h2 id="集团直接受益"><a href="#集团直接受益" class="headerlink" title="集团直接受益"></a>集团直接受益</h2><blockquote><p>相关企业连续8年企业所得税减免,可购买泰国土地。</p></blockquote><h3 id="BOI是什么？为何泰国和外国投资者想在BOI-开展业务？"><a href="#BOI是什么？为何泰国和外国投资者想在BOI-开展业务？" class="headerlink" title="BOI是什么？为何泰国和外国投资者想在BOI 开展业务？"></a>BOI是什么？为何泰国和外国投资者想在BOI 开展业务？</h3><blockquote><p>与其他国家&#x2F;地区相比，有很多泰国和外国投资者更注重在泰国做生意。因为泰国有很多优势，无论是气候，地理资源，位子适合作为东盟的中心。尤其是陆上，水上和空中的运输，有很多专业的劳动力，具有数量和质量潜力的农业原料，有各种各样的农产品，例如：大米，橡胶，甘蔗，蔬菜和新鲜水果。所有这些都足以为投资者创造利润和回报。因此，政府建立了投资促进计划（BOI），以支持和鼓励希望在泰国做生意的投资者，并为外国投资者增加投资的吸引力。</p></blockquote><h3 id="BOI-是什么？"><a href="#BOI-是什么？" class="headerlink" title="BOI 是什么？"></a>BOI 是什么？</h3><ul><li>泰国投资促进委员会（BOI）是主管投资的部门，或者更准确地说是泰国政府负责制定投资奖励优惠政策并为投资者提供协助服务的组织。主要职责是促进泰国的投资事业、制定投资奖励优惠政策及相关的指导政策、向投资者提供奖励并为投资者提供相关的服务，包括刺激经济计划和可持续发展国家，包括吸引更多的外国投资者在该国投资，可以加入BOI的公司必须通过标准和符合BOI的条件。</li></ul><h2 id="在BOI-的业务会得到哪些好处？"><a href="#在BOI-的业务会得到哪些好处？" class="headerlink" title="在BOI 的业务会得到哪些好处？"></a>在BOI 的业务会得到哪些好处？</h2><h3 id="1-税收方面的优惠"><a href="#1-税收方面的优惠" class="headerlink" title="1. 税收方面的优惠"></a>1. 税收方面的优惠</h3><ul><li>免征企业所得税，最长不超过13年（取决于业务类型和条件）</li><li>减免50％的所得税 5年（仅适用于投资促进区）</li><li>免&#x2F;减免机器进口税</li><li>免&#x2F;减免原材料进口税</li><li>免开发用品进口税</li></ul><h3 id="2-与税收无关的优惠"><a href="#2-与税收无关的优惠" class="headerlink" title="2. 与税收无关的优惠"></a>2. 与税收无关的优惠</h3><ul><li>允许外国人持有100％的股份（具有其他特定法律的公司除外）。</li><li>允许土地所有权</li><li>允许熟练的工匠&#x2F;专家的外国人来泰国工作</li><li>允许家庭跟随外国雇员进入到泰国（父母，配偶，子女）</li><li>允许外国人可以寄钱或汇款到国外</li></ul><h2 id="批准要求投资促进有什么标准？"><a href="#批准要求投资促进有什么标准？" class="headerlink" title="批准要求投资促进有什么标准？"></a>批准要求投资促进有什么标准？</h2><ol><li>发展各部门的竞争力农业，工业和服务业</li><li>预防对环境质量的影响</li><li>有最低的投资和项目可行性</li></ol><p>其实，将公司进入BOI并不困难，但是需要仔细和周到地准备文件，检查业务是否符合BOI设定的条件，<br>如果完全符合BOI的要求，并且文件完整则可以申请。向BOI请求支持将帮助您会获得各种好处，对您的业务对有利。</p><h2 id="BOI的业务有以下8种类型："><a href="#BOI的业务有以下8种类型：" class="headerlink" title="BOI的业务有以下8种类型："></a>BOI的业务有以下8种类型：</h2><table><thead><tr><th>种类</th><th>行业类别</th><th>例子业务</th></tr></thead><tbody><tr><td>1</td><td>农业及农产品加工业</td><td>生产加工淀粉、生产医疗食品、生物肥料等.</td></tr><tr><td>2</td><td>矿物、陶瓷和基础金属</td><td>矿产勘探、生产玻璃或陶瓷制品、生产钢铁上中下游业务等</td></tr><tr><td>3</td><td>轻工业</td><td>生产医疗器械或零件、生产家具、生产玩具、生产纺织品等</td></tr><tr><td>4</td><td>金属产品、机械设备和运输工具</td><td>机械制造、配件、发动机、交通工具部件、摩托车等</td></tr><tr><td>5</td><td>电子与电器业</td><td>生产电器及部件、硬盘驱动器、微电子物质、数码科技等</td></tr><tr><td>6</td><td>化工产品、塑料及造纸</td><td>药品、印刷品、工业化工产品、塑胶包装制品、纸制品等</td></tr><tr><td>7</td><td>服务业和公用事业</td><td>公用行业和基本服务、大众货物运输业务、医疗服务、旅游业等</td></tr><tr><td>8</td><td>发展科技创新</td><td>发展生物技术、纳米技术、先进材料、数字技术等</td></tr></tbody></table><h2 id="OI申请流程共有8个步骤"><a href="#OI申请流程共有8个步骤" class="headerlink" title="OI申请流程共有8个步骤"></a>OI申请流程共有8个步骤</h2><h3 id="1-研究咨询基本信息资料"><a href="#1-研究咨询基本信息资料" class="headerlink" title="1. 研究咨询基本信息资料"></a>1. 研究咨询基本信息资料</h3><ul><li>BOI申请人可以通过以下网站 <a href="http://www.boi.go.th/">www.boi.go.th</a> 或 BOI中央、BOI区域 、外交部研究BOI的信息。</li></ul><h3 id="2-提交投资促进请求（仅在线提交）"><a href="#2-提交投资促进请求（仅在线提交）" class="headerlink" title="2. 提交投资促进请求（仅在线提交）"></a>2. 提交投资促进请求（仅在线提交）</h3><ul><li>BOI申请人可以通过 <a href="http://www.boi.go.th/">www.boi.go.th</a> 电子投资促进系统提交请求。</li></ul><h3 id="3-项目说明"><a href="#3-项目说明" class="headerlink" title="3. 项目说明"></a>3. 项目说明</h3><ul><li>BOI申请人预约负责该项目的BOI官员，在提交请求之日起的10个工作日内澄清项目。</li></ul><h3 id="4-项目分析"><a href="#4-项目分析" class="headerlink" title="4. 项目分析"></a>4. 项目分析</h3><ul><li>BOI官员进行分析项目，考虑时间是根据投资规模。</li></ul><h3 id="5-审批结果通知"><a href="#5-审批结果通知" class="headerlink" title="5. 审批结果通知"></a>5. 审批结果通知</h3><ul><li>BOI官员将在确认会议决议后7天内通知审批结果。</li></ul><h3 id="6-接受投资审批结果"><a href="#6-接受投资审批结果" class="headerlink" title="6. 接受投资审批结果"></a>6. 接受投资审批结果</h3><ul><li>BOI申请人在接受投资委员通知书的1个月内，要通过以下两种方式对投资促进决议做出回应：通过电子投资促进申请系统（e-Investment Promotion ）或填写纸质的项目审批结果确认表（表格F GA CT 07）</li></ul><h3 id="7-办理领取投资促进证"><a href="#7-办理领取投资促进证" class="headerlink" title="7. 办理领取投资促进证"></a>7. 办理领取投资促进证</h3><ul><li>BOI接收者，要去申请 领取 “投资促进证 “，并向 BOI 提交相关证据。在回复投资决议后6个月内通过纸质形式或者电子投资申请系统（e-Investment ）填写递交领取投资促进证申请表（表格F GA CT 08）以及其他相关文件。</li></ul><h3 id="8-颁布投资促进证"><a href="#8-颁布投资促进证" class="headerlink" title="8. 颁布投资促进证"></a>8. 颁布投资促进证</h3><ul><li>在收到促销证书和完整证据的 10 天内，BOI 官员将颁布”投资促进证 “。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;幸得领导信任，负责BOI项目资料整理申报;第一次做跨国项目申报，资料多次修改后最终申请通过，历经4个月申请排队；终</summary>
      
    
    
    
    <category term="ProjectManagement" scheme="https://z201.cn/categories/ProjectManagement/"/>
    
    
    <category term="ProjectManagement" scheme="https://z201.cn/tags/ProjectManagement/"/>
    
    <category term="Boi" scheme="https://z201.cn/tags/Boi/"/>
    
  </entry>
  
  <entry>
    <title>EnterpriseArchitecture-Fault-Management</title>
    <link href="https://z201.cn/posts/2618974834/"/>
    <id>https://z201.cn/posts/2618974834/</id>
    <published>2022-06-13T16:44:54.000Z</published>
    <updated>2024-01-06T10:53:12.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="故障管理"><a href="#故障管理" class="headerlink" title="故障管理"></a>故障管理</h1><blockquote><p>故障永远只是表面现象，其背后技术和管理上的问题才是根因。技术和管理上的问题，积累到一定量通过故障的形式爆发出来，所以故障是现象，是在给我们严重提醒。在日常运营中，无论什么原因，产品出现服务中断、服务品质下降，导致用户体验下降的情况，都称为故障（故障不包括用户方环境引发的场景）。</p></blockquote><ul><li>在日常运营中，无论什么原因，产品出现服务中断、服务品质下降，导致用户体验下降的情况，都称为故障（故障不包括用户方环境引发的场景）。</li><li>为什么会频繁出故障？</li><li>为什么一个小问题或者某个部件失效，会导致全站宕机or服务不可用？</li><li>为什么发生了故障没法快速知道并且快速恢复？</li></ul><h2 id="故障管理规划"><a href="#故障管理规划" class="headerlink" title="故障管理规划"></a>故障管理规划</h2><ol><li>紧急联系人清单：建立一份紧急联系人清单，列出技术团队成员、管理层、供应商以及其他关键利益相关者的联系信息。确保所有人都知道如何联系到这些人，并在必要时可以迅速响应。</li><li>故障分类与级别划分：建立一份故障分类与级别划分表，将故障划分为不同的级别，例如紧急、高、中、低等级别。定义每个级别的响应时间和解决时间，以及分配给哪些人员和团队进行处理。</li><li>值班制度：建立一份值班制度，确保团队可以在任何时间响应故障。值班制度应该包含轮值制度、联系人信息、响应流程和注意事项等方面的细节。</li><li>故障报告和跟踪：建立一份故障报告和跟踪系统，以便团队可以及时记录故障、跟踪解决进度、追踪根本原因，并确保所有人都可以访问这些信息。故障报告和跟踪系统可以是一个内部的工具，也可以是一个第三方工具，如Jira或ServiceNow等。</li><li>预防措施和持续改进：故障管理不仅仅是应急响应，还需要预防措施和持续改进。团队应该分析故障原因，识别重复出现的故障，并采取措施防止它们再次发生。同时，团队应该不断优化流程，提高响应速度和解决效率。</li><li>培训和知识共享：建立一份培训和知识共享计划，确保团队成员具备必要的技能和知识。团队应该定期组织培训，分享最佳实践和经验，并建立一个知识库，以便所有人都可以访问有用的信息。</li></ol><h2 id="产研故障等级划分"><a href="#产研故障等级划分" class="headerlink" title="产研故障等级划分"></a>产研故障等级划分</h2><ol><li><strong>一级故障</strong>P0：一级故障是指对业务或客户产生严重影响的故障，例如系统崩溃、数据丢失或业务无法正常运行等。一级故障需要立即处理，必须由最高级别的技术人员或高管介入处理，并且立即解决。</li><li><strong>二级故障</strong>P1：二级故障是指对业务或客户产生较大影响的故障，例如某些业务功能无法使用或性能下降等。二级故障需要及时处理，由具备高级别技术经验的人员处理，并且需要在30分钟内解决。</li><li><strong>三级故障</strong>P2：三级故障是指对业务或客户产生轻微影响的故障，例如某些功能无法正常使用，但业务可以继续运行等。三级故障需要尽快处理，由具备相关技术经验的人员处理，并且需要在2个小时内解决。</li><li><strong>四级故障</strong>P3：四级故障是指对业务或客户影响不大的故障，例如某些功能异常或提示信息错误等。四级故障需要在合理时间内解决，由具备基本技术经验的人员处理，并且需要在8个小时内解决。</li><li><strong>五级故障</strong>P4：五级故障是指对业务或客户影响较小的故障，例如一些次要功能无法使用或界面样式问题等。五级故障需要在适当的时间内解决，由具备一定技术知识的人员处理，并且需要在8个小时内解决。</li></ol><h2 id="产研故障来源分类"><a href="#产研故障来源分类" class="headerlink" title="产研故障来源分类"></a>产研故障来源分类</h2><ol><li>系统故障分类<ol><li>基础设施故障：互联网公司的基础设施包括服务器、网络、存储、数据库等，故障可能会导致系统宕机、数据丢失等问题。这些故障通常需要进行设备维护、系统监控、灾备恢复等方式进行处理。</li><li><strong>软件故障</strong>：软件故障是指由于软件设计缺陷、编码错误、系统兼容性问题等原因引起的故障。<ol><li>集成错误：包括系统集成错误、组件集成错误等。这些错误通常是由于研发人员在系统或组件集成过程中出现的错误导致的，需要通过集成测试、回归测试等方式进行检查和修正。</li><li>性能问题：包括系统性能问题、代码性能问题等。这些问题通常是由于研发人员在编写代码或设计系统时未考虑到性能因素导致的，需要通过性能测试、优化等方式进行检查和修正。</li><li>安全问题：包括系统安全问题、数据安全问题等。这些问题通常是由于研发人员在设计或编写代码时未考虑到安全因素导致的，需要通过安全测试、漏洞扫描等方式进行检查和修正。</li><li>用户体验问题：包括界面设计不当、功能不完善等。这些问题通常是由于软件设计或编写时未考虑到用户需求导致的，需要通过用户反馈、用户调研等方式进行检查和修正。</li><li>界面故障问题：包括用户界面显示不正常、功能按钮无法点击、菜单无法弹出等问题。这类故障通常与用户交互相关，需要进行UI调试和界面优化。</li><li>功能故障问题：包括软件功能无法正常使用、程序崩溃、功能异常等问题。这类故障通常需要进行代码调试和功能重构。</li></ol></li><li><strong>人为因素</strong>：人为因素是指由于员工的失误、操作不当、意外或恶意行为等原因引起的故障。<ol><li>编码和文档错误：包括代码错误、文档错误等。这些错误通常是由于研发人员在编写代码或文档时出现的错误导致的，需要通过代码审查、文档审查等方式进行检查和修正。</li><li>系统配置错误：包括系统配置错误、环境配置错误等。这些错误通常是由于研发人员在系统配置或环境配置时出现的错误导致的，需要通过系统配置检查、环境配置检查等方式进行检查和修正。</li></ol></li><li><strong>环境因素</strong>：环境因素是指由于自然灾害、供电故障、通信中断、网络异常等外部因素引起的故障。</li><li><strong>第三方服务故障</strong>：第三方服务故障是指由于供应商服务故障、维护计划、升级等原因引起的故障。</li></ol></li><li>时间分类：白天故障、夜晚故障、周末故障。</li><li>来源分类：用户报告、自动化告警、监视系统等。</li></ol><h3 id="故障来源"><a href="#故障来源" class="headerlink" title="故障来源"></a>故障来源</h3><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20220814005533.png"></p><h3 id="故障生命周期"><a href="#故障生命周期" class="headerlink" title="故障生命周期"></a>故障生命周期</h3><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20220814005056.png"></p><h4 id="故障生命周期流程"><a href="#故障生命周期流程" class="headerlink" title="故障生命周期流程"></a>故障生命周期流程</h4><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20220814005213.png"></p><h3 id="故障管理任务"><a href="#故障管理任务" class="headerlink" title="故障管理任务"></a>故障管理任务</h3><blockquote><p>故障管理任务分解</p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20220814005242.png"></p><h3 id="故障前"><a href="#故障前" class="headerlink" title="故障前"></a>故障前</h3><blockquote><p>提前达成共识，上线运营前的问题统一称为bug，上线运营后的问题统一称为故障&amp;事故。</p></blockquote><h4 id="故障预防"><a href="#故障预防" class="headerlink" title="故障预防"></a>故障预防</h4><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20220814005306.png"></p><h4 id="产研故障预防流程"><a href="#产研故障预防流程" class="headerlink" title="产研故障预防流程"></a>产研故障预防流程</h4><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20220814005416.png"></p><h4 id="处理预案"><a href="#处理预案" class="headerlink" title="处理预案"></a>处理预案</h4><blockquote><p>第一原则：优先恢复业务，而不是定位问题。（在故障组处理的第一原则优先考虑恢复方案）</p></blockquote><ul><li>业务恢复预案<ul><li>信息通报（工单登记、邮件通知技术团队）。完成上述第一步后，通常会给相关技术和业务团队通报故障初步信息，包括登记、影响面、故障简述以及主要处理团队。</li><li>确定故障影响面及等级。故障会通过监控、告警、业务反馈或用户投诉几个渠道反馈过来，这时技术支持会根据故障定级标准，快速做出初步判断，确认影响面，以及故障等级。</li><li>组织故障会议。对于无法马上恢复或仍需要定位排查的故障，根据问题紧急程度就近处理。</li></ul></li><li>恢复系统预案<ul><li>重启；大多情况下适用多数情况，但是重启后容易出现脏数据。</li><li>回滚；回滚的条件是，故障与最近发布有关。</li><li>降级；暂停出问题的模块，需要与业务方沟通，暂时离线出问题的模块。</li><li>限流、扩容；如果是系统扛不住业务流量，可以选择扩容服务。如果不能扩容，可以选择限流，按照一定百分比的流量限流。</li></ul></li></ul><h3 id="故障中"><a href="#故障中" class="headerlink" title="故障中"></a>故障中</h3><blockquote><p>故障应急流程由故障应急小组来主导。对外同步信息，包括大致原因，影响面和预估恢复时长，同时屏蔽各方对故障处理人员的干扰；对内组织协调各团队相关人员集中处理。</p></blockquote><h4 id="故障发现"><a href="#故障发现" class="headerlink" title="故障发现"></a>故障发现</h4><ul><li>确认故障的有效性，登记故障缺陷。同步故障信息给对应的技术团队。</li></ul><h4 id="故障定位"><a href="#故障定位" class="headerlink" title="故障定位"></a>故障定位</h4><blockquote><p>故障发生后，一定要严肃对待。大多数情况下，会过渡盯着故障本身，而揪着相关责任人不放。进而形成一些负面影响。为此将注意力转到故障背后的技术和处理更为合适。</p></blockquote><ul><li>评估大致原因，影响面和预估恢复时长。组织应急小组处理故障。</li><li>在大多数情况下故障定级别都是在处理环境评估，为了提高整体效率，在需求评审和技术评审阶段就应该完成相关业务故障所带来的故障风险。将工作前置化处理，降低运营阶段处理周期。</li><li>如果使用到了第三方的服务，如公有云的各类服务，包括 IaaS、PaaS、CDN 以及视频等等，原则就是默认第三方无责。</li></ul><h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><ul><li>确定故障处理方案<ul><li>包括:正常业务流程处理提交数据修改 &#x2F; 修改配置 &#x2F; 回滚 &#x2F; 紧急版本发布</li></ul></li><li>协调推进故障处理<ul><li>避免扯皮推诿。避免争执不清，甚至出现诋毁攻击的情况。</li><li>正视问题，严肃对待。找出自身不足，作为改进的主要责任者，来落地或推进改进措施。</li></ul></li><li>客户沟通<ul><li>与客户保持联系，</li></ul></li></ul><h3 id="故障后"><a href="#故障后" class="headerlink" title="故障后"></a>故障后</h3><h4 id="故障复盘"><a href="#故障复盘" class="headerlink" title="故障复盘"></a>故障复盘</h4><blockquote><p>复盘的目的是为了从故障中学习，找到我们技术和管理上的不足，然后不断改进。</p></blockquote><ul><li><p>主要针对故障发生时间点，故障影响面，恢复时长，主要处理人或团队做简要说明。</p></li><li><p>故障处理时间线回顾。技术支持在故障处理过程中会简要记录处理过程，这个过程要求客观真实即可。业务恢复后，与处理人进行核对和补充。这个时间线的作用非常关键，它可以相对真实地再现整个故障处理过程。</p></li><li><p>确定相关故障原因，故障根因的改进措施进行讨论；<strong>就事论事</strong>。</p><ul><li>第一问：故障原因有哪些？</li><li>第二问：如何避免再出出现类似故障？</li><li>第三问：当时恢复业务方式？</li><li>第四问：当前系统中是否存在类似的潜在风险？</li></ul></li><li><p>故障完结统计，故障完结报告的主要内容包括故障详细信息，如时间点、影响面、时间线、根因、责任团队（这里不暴露责任人）、后续改进措施，以及通过本次故障总结出来的共性问题和建议。这样做的主要目的是保证信息透明，同时引以为戒，期望团队也能够查漏补缺，不要犯同样的错误。</p></li><li><p>定责的过程是找出跟因，针对不足找出改进措施。落实责任到人。定责的目标，是责任到人。并且让团队成员意识到自己的不足。对故障处理的坚决态度。</p></li><li><p>高压线，类似酒后不开车，</p><p>对于明知高压线依然触犯导致故障需要处罚。</p><ul><li>未经技术主管授权，私自变更线上代码和配置。</li><li>未经技术主管授权，私自在业务高峰期进行网络配置变更。</li><li>未经技术主管授权，私自在生产环境调试。</li><li>未经技术主管授权，私自变更生产数据信息。</li><li>未经技术主管授权，私自将未验证代码合并至主分支。</li></ul></li></ul><h4 id="持续改进"><a href="#持续改进" class="headerlink" title="持续改进"></a>持续改进</h4><blockquote><p>无论是理论还是实践，均证明故障只要有发生的可能，它总会发生。所以为了保障业务稳定性，需提前发现、解决风险，及时发现、定位原因、快速恢复故障，同时要确保改进措施有效落地、避免故障重复发生，我们需要建立一个规范可遵循、闭环的故障管理体系。</p></blockquote><ul><li>改进措施：基于复盘信息制定可验的证改进措施，完成时间点，负责人。如果改进措施无效，故障还会重复发生。</li></ul><h3 id="故障量化"><a href="#故障量化" class="headerlink" title="故障量化"></a>故障量化</h3><h4 id="SRE"><a href="#SRE" class="headerlink" title="SRE"></a>SRE</h4><blockquote><p>Site Reliability Engineer 目前仅实施小部分关键内容，完成最小MVP。SRE-稳定性目标</p></blockquote><ul><li>尽量减少系统故障或异常运行状态的发生，提升系统可用的运行时间占比。</li><li>这里需要考虑三个因素：<strong>成本因素、业务容忍度、系统稳定程度</strong>。</li></ul><table><thead><tr><th>系统可用性</th><th>故障时间&#x2F;年</th><th>故障时间&#x2F;月</th><th>故障时间&#x2F;周</th><th>故障时间&#x2F;日</th></tr></thead><tbody><tr><td>90%</td><td>36.5天</td><td>72小时</td><td>16.8小时</td><td>2.4小时</td></tr><tr><td>99%</td><td>3.65天</td><td>7.2小时</td><td>1.68小时</td><td>14.4分</td></tr><tr><td>99.9%</td><td>8.76小时</td><td>43.8分钟</td><td>10.1分钟</td><td>1.44分</td></tr><tr><td>99.99%</td><td>52.56分钟</td><td>4.38分钟</td><td>1.01分钟</td><td>8.66秒</td></tr><tr><td>99.999%</td><td>5.26分钟</td><td>25.9秒</td><td>6.05秒</td><td>0.86秒</td></tr></tbody></table><ul><li><p>NOC（Network Operation Center）或者叫技术支持 ，这个角色主要有两个职责：一是跟踪线上故障处理和组织故障复盘，二是制定故障定级定责标准，同时有权对故障做出定级和定责。</p></li><li><p>要提高系统的稳定性，就要制定衡量系统稳定性的相关指标，系统的稳定性指标主要有以下两个：</p><ul><li>MTBF，Mean Time Between Failure，平均故障时间间隔。</li><li>MTTR，Mean Time To Repair， 故障平均修复时间。<ul><li>MTTI（Mean Time To Identify，平均故障发现时间；故障发现，故障发生到响应）</li><li>MTTK（Mean Time To Know，平均故障认知时间；故障定位，根因或是根因范围定位出来为止）</li><li>MTTF（Mean Time To Failure，平均失效前时间；故障恢复，采取措施恢复业务)</li><li>MTTV（Mean Time To Verify，平均故障修复验证时间；故障恢复验证，故障解决后验证业务恢复所用时间）</li></ul></li></ul></li><li><p>核心目标</p><ul><li>提升 MTBF，也就是减少故障发生次数，提升故障发生间隔时长。</li><li>降低 MTTR，故障不可避免，那就提升故障处理效率，减少故障影响时长。</li></ul></li></ul><h4 id="SLI"><a href="#SLI" class="headerlink" title="SLI"></a>SLI</h4><blockquote><p>SRE体系建设-可用性建设</p></blockquote><ul><li>容量（Volume）：服务承诺的最大容量是多少，从QPS、TPS、流量、连接数、吞吐量；</li><li>可用性（Availability）：服务是否正常，看HTTP状态码2xx的占比；</li><li>延迟（Latency）：服务响应速度是否够快，rt是否在预期范围内；</li><li>错误率（Errors）：错误率有多少，看HTTP状态码5xx的占比；</li><li>人工介入（Tickets）：是否需要人工介入处理，考虑人工修复。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;故障管理&quot;&gt;&lt;a href=&quot;#故障管理&quot; class=&quot;headerlink&quot; title=&quot;故障管理&quot;&gt;&lt;/a&gt;故障管理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;故障永远只是表面现象，其背后技术和管理上的问题才是根因。技术和管理上的问题，积累到一定量通过故障的</summary>
      
    
    
    
    <category term="EnterpriseArchitecture" scheme="https://z201.cn/categories/EnterpriseArchitecture/"/>
    
    
    <category term="EnterpriseArchitecture" scheme="https://z201.cn/tags/EnterpriseArchitecture/"/>
    
  </entry>
  
  <entry>
    <title>EnterpriseArchitecture-Development-Debt</title>
    <link href="https://z201.cn/posts/3779468321/"/>
    <id>https://z201.cn/posts/3779468321/</id>
    <published>2022-05-15T08:28:57.000Z</published>
    <updated>2024-01-06T10:52:48.722Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>近期在处理公司项目历史债务问题，由于客观历史原因导致。为了快速收益初期不知情况下产生。定期不清理债务导致。</p></blockquote><h2 id="综合债务偿还规划"><a href="#综合债务偿还规划" class="headerlink" title="综合债务偿还规划"></a>综合债务偿还规划</h2><blockquote><p>根据当前情况，除重写策略以外，其他策略同时进行。按阶段将债务问题逐步偿还。根据阶段性成果适当调整下个阶段的重点工作。</p></blockquote><ul><li>达成共识 &gt; 债务可见 &gt; 及时止损 &gt; 不断改善。</li></ul><h3 id="债务的体现"><a href="#债务的体现" class="headerlink" title="债务的体现"></a>债务的体现</h3><ul><li>代码在不同项目中复制迁移，并随着时间增加。</li><li>代码虽然运行稳定，但是回归测试成本在增加。</li><li>迭代维护越来越困难。</li><li>新的feature开发周期越来越长，ROI降低。</li><li>影响开发人员心态。</li></ul><h3 id="技术债务的组成"><a href="#技术债务的组成" class="headerlink" title="技术债务的组成"></a>技术债务的组成</h3><ul><li>代码债务：代码重复、坏味道、代码风格混乱、魔法值、条件太多、异常处理、代码风险、安全风险、严重耦合。</li><li>设计债务：缺少设计、对非功能性认知不足，系统性风险。</li><li>测试债务：缺乏测试、测试覆盖率不足和不使用测试。</li><li>质量债务：缺乏稳定和健壮性的技术验证，版本控制模糊，环境参数混乱。</li><li>文档债务：无技术文档、设计文档或者文档过期。</li></ul><h3 id="技术债务利息"><a href="#技术债务利息" class="headerlink" title="技术债务利息"></a>技术债务利息</h3><blockquote><p>技术债务和贷款买房的思维模式一样，如果借技术债务的收益大于利息的时候，大胆借！</p></blockquote><ul><li><strong>开发速度降低：</strong>通常项目正常情况下，在相同的时间间隔下，完成的任务是接近的。随着项目的迭代，项目单位时间内能完成的任务数明显下降，那很可能是技术债务太多导致的。</li><li><strong>单元测试代码覆盖率低：</strong>现在大部分语言都有单元测试覆盖率的检测工具，通过工具可以很容易知道当前项目单元测试覆盖率如何，如果覆盖率太低或者下降厉害，就说明存在技术债务了。</li><li><strong>代码规范检查的错误率高：</strong>静态代码分析工具提示的代码债务太多，存在大量历史代码就需要处理。</li><li><strong>在线bug越来越多：</strong>正常情况下，如果没有新功能开发，Bug 数量会越来越少。但是如果 Bug 数量下降很慢，甚至有增多的迹象，额外增加研发成本、不稳定的产品质量、难以维护的代码。</li><li><strong>业务共识问题：</strong>理解需求需要时间，加入一个新功能需要写 100 行代码，只要花 20 分钟。但是搞清楚这 100 行代码，应该加到哪个文件里，关联那些系统需要超长时间。</li></ul><h3 id="债务偿还策略"><a href="#债务偿还策略" class="headerlink" title="债务偿还策略"></a>债务偿还策略</h3><blockquote><p>策略并没有绝对好坏，需要根据当前项目场景灵活选择。有个简单原则可以帮助你选择，那就是看哪一种策略<strong>投入产出</strong>ROI更好。</p></blockquote><ul><li>重写：推翻重来，一次还清。</li><li>维持：修修补补，只还利息。</li><li>重构：新旧交替，分期付款。</li><li>投资：好的架构设计、高质量代码就像一种技术投资，能有效减少技术债务的发生。</li><li>测试：日常能做好代码审查、保障单元测试代码覆盖率，预防技术债务。</li><li>还债：因为进度时间紧等客观原因，导致不得不走捷径，那么就应该把欠下的技术债务记下来，放到任务跟踪系统中，安排在后续的开发任务中，及时还债及时解决，就可以避免债务越来越多。</li></ul><h3 id="规划共识"><a href="#规划共识" class="headerlink" title="规划共识"></a>规划共识</h3><blockquote><p>防止技术债务产生的主要方法是了解开发团队存在的技术债务。开发团队必须全面了解技术债务，以及债务对项目的影响。合适的流程可以帮助开发团队避免技术债务积累，例如代码、设计、架构和测试的审查等。而且，这些流程必须是务实的，否则事与愿违。</p></blockquote><ul><li>PDCA（Plan-Do-Check-Act）它最早来⾃于质量管理领域，意思是做任何事情，都要经过规划（Plan）、执⾏（Do)、检查 (Check) 和⾏动 (Act) 这四个步骤。这四个步骤提供了⼀个简易的思考和做事框架。这个循环并不是运⾏⼀次就结束了，⽽是周⽽复始、螺旋上升的。</li><li>WBS（Work Breakdown Structure）任务分解。识别依赖及各环节关键路径，定义完成标准，达成共识并公开透明，变更即时调整。</li><li>MVP（Minimum Viable Product）最⼩化可实⾏产品。来自产品开发，不要⼀下⼦做⼀个「<strong>尽善尽美</strong>」的产品，⽽是先花费最⼩的代价做⼀个「<strong>可⽤</strong>」的产品原型，去验证这个产品是否有价值、是否可⾏，再通过迭代来完善细节。</li><li>ROI（Return on Investment）投资回报率，通常在广告业务作为重要的衡量标准。因为它是衡量广告投放花费的资金是否对于公司业务产生良好的实际影响，例如产生潜在客户、增加销售额、提升品牌知名度或者推动其他有价值的客户活动。</li><li>效率先行。<strong>开发过程越快越好，越快越有竞争力。这的确是软件开发，尤其是互联网行业软件开发的不二法则。</strong></li></ul><h4 id="实施步骤"><a href="#实施步骤" class="headerlink" title="实施步骤"></a>实施步骤</h4><ol><li>团队内债务认知建立，技术债务会直接影响到公司业务的成长，间接影响个人的成长。<ul><li>技术债务产生的负作用，将直接影响相关业务线的发展。</li></ul></li><li>采用低成本的方式进行预防。<ul><li>强化开发人员时间管理认知，帮助开发人员更好的安排时间高效完成工作。</li></ul></li><li>识别债务并标记。<ul><li>服务、组件依赖混乱；文件、函数、包内容太多职责不清晰。</li><li>魔法值、炫技、复杂设计、无设计。函数、接口、参数过多。</li></ul></li><li>采用PDCA的方式循环迭代。<ul><li>标记出存在的负债问题。集中汇总到bug池。关联相关业务线。</li><li>梳理业务边界，统一代码风格、完善开发文档、接口文档、接口单元测试。降低开发人员协调共识周期长的问题。</li></ul></li><li>采用WBS方式标记、处理、公开相关问题。<ul><li>优先处理服务稳定性问题、线上紧急bug问题。</li><li>根据bug与业务的关系程度划分处理级别。</li></ul></li><li>采用MVP方式逐步迭代项目。<ul><li><strong>落地持续改进能力；快速的增量交付。</strong></li><li><strong>提早集成与测试；让问题得以及时暴露，带来了更快的反馈及应对。</strong></li><li><strong>及时规避⻛险；意外仍然会有，但⼤多数情况下，急早发现问题，避免更⼤的影响。</strong></li><li><strong>降低发布周期；降低修复试错成本。</strong></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;近期在处理公司项目历史债务问题，由于客观历史原因导致。为了快速收益初期不知情况下产生。定期不清理债务导致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;综合债务偿还规划&quot;&gt;&lt;a href=&quot;#综合债务偿还规划&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="EnterpriseArchitecture" scheme="https://z201.cn/categories/EnterpriseArchitecture/"/>
    
    
    <category term="EnterpriseArchitecture" scheme="https://z201.cn/tags/EnterpriseArchitecture/"/>
    
  </entry>
  
  <entry>
    <title>减肥-90天减15公斤</title>
    <link href="https://z201.cn/posts/4182966947/"/>
    <id>https://z201.cn/posts/4182966947/</id>
    <published>2022-02-17T03:55:13.000Z</published>
    <updated>2024-02-02T15:03:25.738Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>经过90天的努力，体重最大相差20KG。按照月均计算,已经减重15KG。</p></blockquote><h2 id="为什么减重"><a href="#为什么减重" class="headerlink" title="为什么减重"></a>为什么减重</h2><blockquote><p>已经造成了生活上的不便利，几年前精神旺盛，白天都不困。最近一年中午吃完饭就犯困。</p></blockquote><ul><li><p>旅游容易暴饮暴食是真的。</p></li><li><p>2021-11月初在苏州旅游的时候，因为体重原因不让玩水上项目。</p></li><li><p>2021-11月11日我把床头坐塌了，我突然意识到问题的严重性了。</p></li><li><p>2021-11月11日买了体脂秤，各项指标显示我的身体已经不非常不健康了，开始了减重。</p></li></ul><h3 id="减重规划"><a href="#减重规划" class="headerlink" title="减重规划"></a>减重规划</h3><ul><li><del>第一阶段减重20KG。</del> 2022-02-13 已达成目标。</li><li>第二阶段减少脂肪。体脂率维持在20%。<strong>进行中</strong>。</li><li>第三阶段减少脂肪，体脂率维持在15%。</li></ul><h3 id="减重计划"><a href="#减重计划" class="headerlink" title="减重计划"></a>减重计划</h3><ul><li>控制饮食摄入，在吃饱喝足的情况下。控制碳水、糖、反式脂肪摄入。<ul><li>营养摄入均衡。</li><li>早上吃碳水、中午吃蛋白、晚上吃蔬菜。</li></ul></li><li>保持最低运动量，走路、跳绳。</li><li>多喝水，每天必须喝2升水。</li><li>保持睡眠时长，睡眠能减重是真的。</li></ul><h3 id="减重目标达成"><a href="#减重目标达成" class="headerlink" title="减重目标达成"></a>减重目标达成</h3><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20220217120215.jpg"></p><h3 id="再接再厉"><a href="#再接再厉" class="headerlink" title="再接再厉"></a>再接再厉</h3><blockquote><p>体重已经下降很多了，下一步是就是健康。体脂率下降主要减少脂肪。</p></blockquote><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;经过90天的努力，体重最大相差20KG。按照月均计算,已经减重15KG。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么减重&quot;&gt;&lt;a href=&quot;#为什么减重&quot; class=&quot;headerlink&quot; title=&quot;为什么减重&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="Life" scheme="https://z201.cn/categories/Life/"/>
    
    
    <category term="Life" scheme="https://z201.cn/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>Python3.8-Matplotlib-Employees</title>
    <link href="https://z201.cn/posts/2913752107/"/>
    <id>https://z201.cn/posts/2913752107/</id>
    <published>2021-12-27T01:49:41.000Z</published>
    <updated>2024-01-06T08:45:22.955Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>尝试下使用python Matplotlib可视化数据。</p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20220127095100.png"></p><h3 id="演示代码"><a href="#演示代码" class="headerlink" title="演示代码"></a><a href="https://github.com/z201/jupyter-example/tree/main/Python3.8-Matplotlib-Employees">演示代码</a></h3><ul><li>python3.8运行环境</li><li>测试数据，这里使用mysql提供的测试数据库。<a href="https://z201.cn/posts/3237165083/">安装步骤</a></li><li>jupyter notebook</li><li>pip3 install pymysql</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  jupyter-example git:(main) python --version</span><br><span class="line">Python 3.8.7</span><br><span class="line">➜  jupyter-example git:(main) jupyter notebook --version</span><br><span class="line">6.2.0</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="员工岗位分布"><a href="#员工岗位分布" class="headerlink" title="员工岗位分布"></a>员工岗位分布</h4><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20220127104302.png"></p><h4 id="员工工资分布"><a href="#员工工资分布" class="headerlink" title="员工工资分布"></a>员工工资分布</h4><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20220127104253.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># %matplotlib inline  作用是将Matplotlib绘制的图形内嵌在Jupyter Notebook的页面中，无需执行命令plt.show()便可以直接在页面内展示绘制的图形。</span></span><br><span class="line"></span><br><span class="line">%matplotlib inline </span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_content_from_db</span>(<span class="params">sql</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;连接数据库!&#x27;</span>)</span><br><span class="line">    dbhost=<span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">    dbuser=<span class="string">&#x27;root&#x27;</span></span><br><span class="line">    dbpass=<span class="string">&#x27;123456&#x27;</span></span><br><span class="line">    dbname=<span class="string">&#x27;employees&#x27;</span></span><br><span class="line">     <span class="comment"># 创建数据库连接</span></span><br><span class="line">    db = pymysql.connect(host=dbhost,user=dbuser,password=dbpass,database=dbname,charset = <span class="string">&quot;utf8mb4&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 使用cursor()方法获取操作游标 </span></span><br><span class="line">        cursor = db.cursor()</span><br><span class="line">        <span class="comment"># 执行SQL语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">         <span class="comment"># 获取所有记录列表</span></span><br><span class="line">        results = cursor.fetchall()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;Reading Error &#x27;</span>)    </span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        db.close()</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;Completion of data reading &#x27;</span>)    </span><br><span class="line">    <span class="keyword">return</span> (results)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">title_show</span>(<span class="params">results,title,save_file_name</span>):</span><br><span class="line">    <span class="comment"># 准备数据</span></span><br><span class="line">    indexList = []</span><br><span class="line">    itemList = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> results:</span><br><span class="line">        indexList.append(i[<span class="number">1</span>])</span><br><span class="line">        itemList.append(i[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    plt.rcParams[<span class="string">&quot;font.family&quot;</span>] = <span class="string">&#x27;Arial Unicode MS&#x27;</span> <span class="comment"># 用来正常显示中文标签</span></span><br><span class="line">    plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span> <span class="comment"># 用来正常显示负号</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 3.创建画布</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>), dpi=<span class="number">150</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4.绘制饼图</span></span><br><span class="line">    explode = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.1</span>)  <span class="comment"># 突出展示【其他】手机部分</span></span><br><span class="line">    plt.pie(indexList, labels=itemList, autopct=<span class="string">&quot;%1.1f%%&quot;</span>, explode=explode)</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 5.修饰图像</span></span><br><span class="line">    plt.title(title, fontsize=<span class="number">16</span>)  <span class="comment"># 添加标题</span></span><br><span class="line">    plt.axis(<span class="string">&quot;equal&quot;</span>)  <span class="comment"># 修正饼图的展示效果</span></span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.savefig(save_file_name+<span class="string">&#x27;.png&#x27;</span>,facecolor=<span class="string">&#x27;white&#x27;</span>,dpi= <span class="number">200</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计职位分布</span></span><br><span class="line">sql_1 = <span class="string">&quot;&quot;&quot;SELECT  title , COUNT(*) AS count FROM employees.titles GROUP BY title&quot;&quot;&quot;</span></span><br><span class="line">results = get_content_from_db(sql_1)</span><br><span class="line">title_show(results,<span class="string">&quot;员工岗位分布&quot;</span>,<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"><span class="comment"># 薪资区间统计</span></span><br><span class="line">sql_2 = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">SELECT ELT(INTERVAL(salary, 30000, 50000, 70000, 90000, 110000, 130000, 150000), </span></span><br><span class="line"><span class="string">    &#x27;&lt;30000&#x27;, &#x27;30000-50000&#x27;, &#x27;50000-70000&#x27;, &#x27;70000-90000&#x27;, &#x27;90000-110000&#x27;, &#x27;110000-130000&#x27;, &#x27;&gt;=150000&#x27;)</span></span><br><span class="line"><span class="string">AS salary_level, count(*) AS count FROM employees.salaries GROUP BY salary_level</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">results = get_content_from_db(sql_2)</span><br><span class="line">title_show(results,<span class="string">&quot;员工工资分布&quot;</span>,<span class="string">&#x27;salaries&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;尝试下使用python Matplotlib可视化数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20220127095100.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;演示代码&quot;&gt;&lt;a href=&quot;#演示代码&quot; class=&quot;headerlink&quot; title=&quot;演示代码&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/z201/jupyter-example/tree/main/Python3.8-Matplotlib-Employees&quot;&gt;演示代码&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;python3.8运行环境&lt;/li&gt;
&lt;li&gt;测试数据，这里使用mysql提供的测试数据库。&lt;a href=&quot;https://z201.cn/posts/3237165083/&quot;&gt;安装步骤&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;jupyter notebook&lt;/li&gt;
&lt;li&gt;pip3 install pymysql&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;➜  jupyter-example git:(main) python --version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Python 3.8.7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;➜  jupyter-example git:(main) jupyter notebook --version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6.2.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="DataAnalysis" scheme="https://z201.cn/categories/DataAnalysis/"/>
    
    
    <category term="Mysql" scheme="https://z201.cn/tags/Mysql/"/>
    
    <category term="Python" scheme="https://z201.cn/tags/Python/"/>
    
    <category term="Matplotlib" scheme="https://z201.cn/tags/Matplotlib/"/>
    
    <category term="DataAnalysis" scheme="https://z201.cn/tags/DataAnalysis/"/>
    
  </entry>
  
  <entry>
    <title>Python3.8-Matplotlib-Ip-Line</title>
    <link href="https://z201.cn/posts/3245002987/"/>
    <id>https://z201.cn/posts/3245002987/</id>
    <published>2021-12-25T12:00:28.000Z</published>
    <updated>2024-01-06T08:44:55.155Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>尝试下使用python Matplotlib可视化数据。</p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20220126231734.png"></p><h3 id="演示代码"><a href="#演示代码" class="headerlink" title="演示代码"></a><a href="https://github.com/z201/jupyter-example/tree/main/Python3.8-Matplotlib-Ip-Line">演示代码</a></h3><ul><li>python3.8运行环境</li><li>测试数据库</li><li>jupyter notebook</li><li>pip3 install pymysql</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  jupyter-example git:(main) python --version</span><br><span class="line">Python 3.8.7</span><br><span class="line">➜  jupyter-example git:(main) jupyter notebook --version</span><br><span class="line">6.2.0</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># %matplotlib inline  作用是将Matplotlib绘制的图形内嵌在Jupyter Notebook的页面中，无需执行命令plt.show()便可以直接在页面内展示绘制的图形。</span></span><br><span class="line"></span><br><span class="line">%matplotlib inline </span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_address</span>(<span class="params">date_address,index</span>):</span><br><span class="line">    strlist = date_address.split(<span class="string">&#x27;|&#x27;</span>)<span class="comment"># 用逗号分割str字符串，并保存到列表</span></span><br><span class="line">    address = strlist[index];</span><br><span class="line">    <span class="keyword">return</span> address</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_timestamp</span>(<span class="params">date_time</span>):</span><br><span class="line">    ts = date_time / <span class="number">1000</span></span><br><span class="line">    <span class="comment">#转换成localtime</span></span><br><span class="line">    time_local = time.localtime(ts)</span><br><span class="line">    date = time.strftime(<span class="string">&quot;%Y-%m&quot;</span>, time_local)</span><br><span class="line">    <span class="keyword">return</span> date</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_content_from_db</span>(<span class="params">sql</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;连接数据库!&#x27;</span>)</span><br><span class="line">    dbhost=<span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">    dbuser=<span class="string">&#x27;root&#x27;</span></span><br><span class="line">    dbpass=<span class="string">&#x27;123456&#x27;</span></span><br><span class="line">    dbname=<span class="string">&#x27;ip_info&#x27;</span></span><br><span class="line">     <span class="comment"># 创建数据库连接</span></span><br><span class="line">    db = pymysql.connect(host=dbhost,user=dbuser,password=dbpass,database=dbname,charset = <span class="string">&quot;utf8mb4&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 使用cursor()方法获取操作游标 </span></span><br><span class="line">        cursor = db.cursor()</span><br><span class="line">        <span class="comment"># 执行SQL语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">         <span class="comment"># 获取所有记录列表</span></span><br><span class="line">        results = cursor.fetchall()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;Reading Error &#x27;</span>)    </span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        db.close()</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;Completion of data reading &#x27;</span>)    </span><br><span class="line">    <span class="keyword">return</span> (results)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">line_show</span>(<span class="params">results,save_file_name</span>):</span><br><span class="line">    indexList = []</span><br><span class="line">    timeList = []</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> results:</span><br><span class="line">        total += i[<span class="number">1</span>]</span><br><span class="line">        indexList.append(i[<span class="number">1</span>])</span><br><span class="line">        timeList.append(i[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    plt.rcParams[<span class="string">&quot;font.family&quot;</span>] = <span class="string">&#x27;Arial Unicode MS&#x27;</span> <span class="comment"># 用来正常显示中文标签</span></span><br><span class="line">    plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span> <span class="comment"># 用来正常显示负号</span></span><br><span class="line">    plt.rc(<span class="string">&#x27;figure&#x27;</span>, figsize = (<span class="number">14</span>, <span class="number">7</span>))</span><br><span class="line">    plt.rc(<span class="string">&#x27;font&#x27;</span>, size = <span class="number">14</span>)</span><br><span class="line">    plt.rc(<span class="string">&#x27;axes&#x27;</span>, grid = <span class="literal">False</span>)</span><br><span class="line">    plt.rc(<span class="string">&#x27;axes&#x27;</span>, facecolor = <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">    plt.plot(timeList,</span><br><span class="line">             indexList,</span><br><span class="line">             <span class="string">&#x27;ro-&#x27;</span>,</span><br><span class="line">             color=<span class="string">&#x27;#4169E1&#x27;</span>,</span><br><span class="line">             alpha=<span class="number">0.8</span>,</span><br><span class="line">             linewidth=<span class="number">1</span>,</span><br><span class="line">             label=<span class="string">&#x27;月增长&#x27;</span>)</span><br><span class="line">    <span class="comment"># 设置数字标签</span></span><br><span class="line">    <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(timeList, indexList):</span><br><span class="line">        plt.text(a, b, b, ha=<span class="string">&#x27;center&#x27;</span>, va=<span class="string">&#x27;bottom&#x27;</span>, fontsize=<span class="number">15</span>)</span><br><span class="line">        </span><br><span class="line">    plt.legend(loc=<span class="string">&quot;upper right&quot;</span>)</span><br><span class="line">  </span><br><span class="line">    plt.title(<span class="string">&#x27;用户注册量&#x27;</span>+<span class="built_in">str</span>(total))</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;日期&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;注册数量&#x27;</span>)</span><br><span class="line">    plt.savefig(save_file_name+<span class="string">&#x27;.png&#x27;</span>,facecolor=<span class="string">&#x27;white&#x27;</span>,dpi= <span class="number">200</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询当前数据库中的所有数据表</span></span><br><span class="line">line_sql_1 = <span class="string">&quot;SELECT FROM_UNIXTIME(create_time / 1000, &#x27;%Y-%m&#x27;) AS date , COUNT(*) AS count FROM ip_registered GROUP BY date&quot;</span></span><br><span class="line">results = get_content_from_db(line_sql_1)</span><br><span class="line">line_show(results,<span class="string">&#x27;line&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;尝试下使用python Matplotlib可视化数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20220126231734.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;演示代码&quot;&gt;&lt;a href=&quot;#演示代码&quot; class=&quot;headerlink&quot; title=&quot;演示代码&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/z201/jupyter-example/tree/main/Python3.8-Matplotlib-Ip-Line&quot;&gt;演示代码&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;python3.8运行环境&lt;/li&gt;
&lt;li&gt;测试数据库&lt;/li&gt;
&lt;li&gt;jupyter notebook&lt;/li&gt;
&lt;li&gt;pip3 install pymysql&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;➜  jupyter-example git:(main) python --version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Python 3.8.7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;➜  jupyter-example git:(main) jupyter notebook --version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6.2.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="DataAnalysis" scheme="https://z201.cn/categories/DataAnalysis/"/>
    
    
    <category term="Mysql" scheme="https://z201.cn/tags/Mysql/"/>
    
    <category term="Python" scheme="https://z201.cn/tags/Python/"/>
    
    <category term="Matplotlib" scheme="https://z201.cn/tags/Matplotlib/"/>
    
    <category term="DataAnalysis" scheme="https://z201.cn/tags/DataAnalysis/"/>
    
  </entry>
  
  <entry>
    <title>Python3.8-WordCloud-IpAddress</title>
    <link href="https://z201.cn/posts/3541298682/"/>
    <id>https://z201.cn/posts/3541298682/</id>
    <published>2021-12-22T12:00:28.000Z</published>
    <updated>2024-01-06T08:44:53.040Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>尝试下使用python可视化数据。</p></blockquote><h2 id="云词"><a href="#云词" class="headerlink" title="云词"></a>云词</h2><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20220126200542.jpg"></p><h3 id="演示代码"><a href="#演示代码" class="headerlink" title="演示代码"></a><a href="https://github.com/z201/jupyter-example/tree/main/Python3.8-WordCloud-IpAddress">演示代码</a></h3><ul><li>python3.8运行环境</li><li>测试数据库</li><li>jupyter notebook</li><li>pip3 install pymysql </li><li>pip3 install WordCloud</li><li>pip3 install jieba</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  jupyter-example git:(main) python --version</span><br><span class="line">Python 3.8.7</span><br><span class="line">➜  jupyter-example git:(main) jupyter notebook --version</span><br><span class="line">6.2.0</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 去掉停用词</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remove_stop_words</span>(<span class="params">f</span>):</span><br><span class="line">     stop_words = [<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;|&#x27;</span>]</span><br><span class="line">     <span class="keyword">for</span> stop_word <span class="keyword">in</span> stop_words:</span><br><span class="line">           f = f.replace(stop_word, <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">     <span class="keyword">return</span> f</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 生成词云</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_word_cloud</span>(<span class="params">f</span>):</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;ip解析记录!&#x27;</span>)</span><br><span class="line">     <span class="comment"># 获取运行环境目录位置</span></span><br><span class="line">     base_dir = os.getcwd()</span><br><span class="line">     <span class="comment"># Console 输出目录信息</span></span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;当前目录 &#x27;</span>+base_dir)</span><br><span class="line">     <span class="comment"># 在mac上这个字体可以解决乱码问题</span></span><br><span class="line">     ttf = <span class="string">&#x27;/System/Library/fonts/PingFang.ttc&#x27;</span> </span><br><span class="line">     <span class="comment"># windows 可以用这个，单独下载SimHei.ttf字体放在同级目录</span></span><br><span class="line">     <span class="comment">#FONT_PATH = os.environ.get(&quot;FONT_PATH&quot;, os.path.join(base_dir, &quot;SimHei.ttf&quot;))</span></span><br><span class="line">     FONT_PATH = os.environ.get(<span class="string">&quot;FONT_PATH&quot;</span>, ttf)</span><br><span class="line">     f = remove_stop_words(f)</span><br><span class="line">     cut_text = <span class="string">&quot; &quot;</span>.join(jieba.cut(f,cut_all=<span class="literal">False</span>, HMM=<span class="literal">True</span>))</span><br><span class="line">     wc = WordCloud(</span><br><span class="line">           font_path=FONT_PATH,</span><br><span class="line">           collocations=<span class="literal">False</span>, <span class="comment"># 关键词重复</span></span><br><span class="line">           max_words=<span class="number">100</span>, <span class="comment"># 最大200个词</span></span><br><span class="line">           width=<span class="number">2000</span>,</span><br><span class="line">           height=<span class="number">1200</span>,</span><br><span class="line">    )</span><br><span class="line">     wordcloud = wc.generate(cut_text)</span><br><span class="line">   </span><br><span class="line">     <span class="comment"># 显示词云文件</span></span><br><span class="line">     plt.imshow(wordcloud)</span><br><span class="line">     plt.axis(<span class="string">&quot;off&quot;</span>) <span class="comment">#隐藏坐标</span></span><br><span class="line">     <span class="comment">#plt.savefig(base_dir+&#x27;cloud.png&#x27;,dpi=500) #dpi通过这里可以放大或缩小</span></span><br><span class="line">       <span class="comment"># 写词云图片</span></span><br><span class="line">     wordcloud.to_file(<span class="string">&quot;wordcloud.jpg&quot;</span>)</span><br><span class="line">     plt.show()</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_content_from_db</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;连接数据库!&#x27;</span>)</span><br><span class="line">    dbhost=<span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">    dbuser=<span class="string">&#x27;root&#x27;</span></span><br><span class="line">    dbpass=<span class="string">&#x27;123456&#x27;</span></span><br><span class="line">    dbname=<span class="string">&#x27;ip_info&#x27;</span></span><br><span class="line">     <span class="comment"># 创建数据库连接</span></span><br><span class="line">    db = pymysql.connect(host=dbhost,user=dbuser,password=dbpass,database=dbname)</span><br><span class="line">     <span class="comment"># 使用cursor()方法获取操作游标 </span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">     <span class="comment"># 创建数据表</span></span><br><span class="line">     <span class="comment"># 查询当前数据库中的所有数据表</span></span><br><span class="line">    sql = <span class="string">&quot;SELECT * FROM ip_registered &quot;</span></span><br><span class="line">     <span class="comment"># 执行SQL语句</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    <span class="comment"># 获取所有记录列表</span></span><br><span class="line">    results = cursor.fetchall()</span><br><span class="line">    content = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> results:</span><br><span class="line">        <span class="built_in">id</span> = row[<span class="number">0</span>]</span><br><span class="line">        registeredIp = row[<span class="number">1</span>]</span><br><span class="line">        createTime = row[<span class="number">2</span>]</span><br><span class="line">        updateTime = row[<span class="number">3</span>]</span><br><span class="line">        registeredAddress = row[<span class="number">4</span>]</span><br><span class="line">        content = content + <span class="built_in">str</span>(registeredAddress + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        <span class="comment"># 打印结果</span></span><br><span class="line"><span class="comment">#         print (&quot;id=%s,registeredIp=%s,createTime=%d,updateTime=%s&quot;,registeredAddress=%s % \</span></span><br><span class="line"><span class="comment">#              (id, registeredIp, createTime, updateTime,registeredAddress ))</span></span><br><span class="line">     <span class="comment"># 提交事务 </span></span><br><span class="line">    db.commit()</span><br><span class="line">     <span class="comment"># 关闭游标</span></span><br><span class="line">    db.close()</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line">content = get_content_from_db()</span><br><span class="line"><span class="comment"># 去掉可能出现HTML标签里的内容</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;[^&gt;]+&gt;&#x27;</span>,re.S)</span><br><span class="line">content = pattern.sub(<span class="string">&#x27;&#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将记录生成词云</span></span><br><span class="line">create_word_cloud(content)</span><br></pre></td></tr></table></figure><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;尝试下使用python可视化数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;云词&quot;&gt;&lt;a href=&quot;#云词&quot; class=&quot;headerlink&quot; title=&quot;云词&quot;&gt;&lt;/a&gt;云词&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20220126200542.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;演示代码&quot;&gt;&lt;a href=&quot;#演示代码&quot; class=&quot;headerlink&quot; title=&quot;演示代码&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/z201/jupyter-example/tree/main/Python3.8-WordCloud-IpAddress&quot;&gt;演示代码&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;python3.8运行环境&lt;/li&gt;
&lt;li&gt;测试数据库&lt;/li&gt;
&lt;li&gt;jupyter notebook&lt;/li&gt;
&lt;li&gt;pip3 install pymysql &lt;/li&gt;
&lt;li&gt;pip3 install WordCloud&lt;/li&gt;
&lt;li&gt;pip3 install jieba&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;➜  jupyter-example git:(main) python --version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Python 3.8.7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;➜  jupyter-example git:(main) jupyter notebook --version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6.2.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="DataAnalysis" scheme="https://z201.cn/categories/DataAnalysis/"/>
    
    
    <category term="Mysql" scheme="https://z201.cn/tags/Mysql/"/>
    
    <category term="Python" scheme="https://z201.cn/tags/Python/"/>
    
    <category term="DataAnalysis" scheme="https://z201.cn/tags/DataAnalysis/"/>
    
    <category term="WordCloud" scheme="https://z201.cn/tags/WordCloud/"/>
    
  </entry>
  
  <entry>
    <title>Redis-Redisearch</title>
    <link href="https://z201.cn/posts/882398087/"/>
    <id>https://z201.cn/posts/882398087/</id>
    <published>2021-12-02T12:57:24.000Z</published>
    <updated>2024-01-06T10:57:57.847Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>RediSearch 是一个高性能的全文搜索引擎，它可以作为一个 Redis Module（扩展模块）运行在 Redis 服务器上。</p></blockquote><h2 id="RediSearch"><a href="#RediSearch" class="headerlink" title="RediSearch"></a>RediSearch</h2><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211228011936.png"></p><ul><li>Redis 哈希中多个字段的全文索引</li><li>无性能损失的增量索引</li><li>文档排名（使用<a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf">tf-idf</a>，具有可选的用户提供的权重）</li><li>场加权</li><li>使用 AND、OR 和 NOT 运算符的复杂布尔查询</li><li>前缀匹配、模糊匹配和精确短语查询</li><li>支持<a href="https://oss.redislabs.com/redisearch/Phonetic_Matching/">双变音拼音匹配</a></li><li>自动完成建议（带有模糊前缀建议）</li><li><a href="https://oss.redislabs.com/redisearch/Stemming/">多种语言中</a>基于词干的查询扩展（使用<a href="http://snowballstem.org/">Snowball</a>）</li><li>支持中文标记化和查询（使用<a href="https://github.com/lionsoul2014/friso">Friso</a>）</li><li>数字过滤器和范围</li><li>使用<a href="https://redis.io/commands/georadius">Redis 地理空间索引</a>进行<a href="https://redis.io/commands/georadius">地理</a>空间搜索</li><li>强大的聚合引擎</li><li>支持所有 utf-8 编码文本</li><li>检索完整文档、选定字段或仅检索文档 ID</li><li>排序结果（例如，按创建日期）</li></ul><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><ul><li><a href="https://oss.redis.com/redisearch/Commands/#">Commands</a></li></ul><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><ul><li>docker</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p redisearch/data</span><br><span class="line">docker run -p 6379:6379 -v <span class="variable">$PWD</span>/redisearch/data:/data  -d redislabs/redisearch:latest </span><br></pre></td></tr></table></figure><ul><li>检查安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  docker-run redis-cli </span><br><span class="line">127.0.0.1:6379&gt; MODULE LIST</span><br><span class="line">1) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">   2) <span class="string">&quot;search&quot;</span></span><br><span class="line">   3) <span class="string">&quot;ver&quot;</span></span><br><span class="line">   4) (<span class="built_in">integer</span>) 20015</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><ul><li>测试下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; FT.ADD idx docCn 1.0 LANGUAGE chinese FIELDS txt <span class="string">&quot;Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。[8]&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; FT.SEARCH idx <span class="string">&quot;数据&quot;</span> LANGUAGE chinese HIGHLIGHT SUMMARIZE</span><br><span class="line">1) (<span class="built_in">integer</span>) 1</span><br><span class="line">2) <span class="string">&quot;docCn&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;txt&quot;</span></span><br><span class="line">   2) <span class="string">&quot;&lt;b&gt;\xe6\x95\xb0\xe6\x8d\xae&lt;/b&gt;\xe5... &lt;b&gt;\xe6\x95\xb0\xe6\x8d\xae&lt;/b&gt;\xe8\xbf\x9b\xe8\xa1\x8c\xe5\x86\x99\xe6\x93\x8d\xe4\xbd\x9c\xe3\x80\x82\xe7\x94\xb1\xe4\xba\x8e\xe5\xae\x8c\xe5\x85\xa8\xe5\xae\x9e\xe7\x8e\xb0\xe4\xba\x86\xe5\x8f\x91\xe5\xb8\x83... &lt;b&gt;\xe6\x95\xb0\xe6\x8d\xae&lt;/b&gt;\xe5\x86\x97\xe4\xbd\x99\xe5\xbe\x88\xe6\x9c\x89\xe5\xb8\xae\xe5\x8a\xa9\xe3\x80\x82[8... &quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>对中文支持不够好</li></ul><span id="more"></span><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><ul><li><p>Spring boot 2.6.0</p></li><li><p>spring-lettucemod 1.8.1 </p></li><li><p>注意这里需要排除commons-pool2</p></li></ul><h4 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.6.0&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    </span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.redis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-lettucemod&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.8.1&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;gson&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><ul><li>单元测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StatefulRedisModulesConnection&lt;String, String&gt; connection;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">()</span> &#123;</span><br><span class="line">    Set&lt;String&gt; keys = redisTemplate.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    keys.forEach(item -&gt; &#123;</span><br><span class="line">                redisTemplate.delete(item);</span><br><span class="line">                log.info(<span class="string">&quot; keys - &gt; &#123;&#125; &quot;</span>, item);</span><br><span class="line">            &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="type">String</span> <span class="variable">searchIndexName</span> <span class="operator">=</span> <span class="string">&quot;doc-idx&quot;</span>;</span><br><span class="line">    <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GsonBuilder</span>().setPrettyPrinting().create();</span><br><span class="line">    RediSearchCommands&lt;String, String&gt; commands = connection.sync();</span><br><span class="line">    <span class="type">RedisCommands</span> <span class="variable">redisCommands</span> <span class="operator">=</span> connection.sync();</span><br><span class="line">    List&lt;String&gt; list = commands.list();</span><br><span class="line">    <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">        commands.dropindex(s);</span><br><span class="line">    &#125;</span><br><span class="line">    CreateOptions&lt;String, String&gt; options = CreateOptions.&lt;String, String&gt;builder()</span><br><span class="line">            .on(CreateOptions.DataType.HASH)</span><br><span class="line">            .languageField(Language.CHINESE.getId())</span><br><span class="line">            .prefix(String.format(<span class="string">&quot;%s:&quot;</span>, DocumentDto.class.getName()))</span><br><span class="line">            .build();</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>,gson.toJson(options));</span><br><span class="line">    <span class="type">Field</span> <span class="variable">title</span> <span class="operator">=</span> Field.text(<span class="string">&quot;title&quot;</span>).build();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">subtitle</span> <span class="operator">=</span> Field.text(<span class="string">&quot;subtitle&quot;</span>).build();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">description</span> <span class="operator">=</span> Field.text(<span class="string">&quot;description&quot;</span>).build();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">author</span> <span class="operator">=</span> Field.text(<span class="string">&quot;authors&quot;</span>).build();</span><br><span class="line">    commands.create(</span><br><span class="line">            searchIndexName, <span class="comment">//</span></span><br><span class="line">            options, <span class="comment">//</span></span><br><span class="line">            title,</span><br><span class="line">            subtitle,</span><br><span class="line">            description, <span class="comment">//</span></span><br><span class="line">            author</span><br><span class="line">    );</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s:%s&quot;</span>, DocumentDto.class.getName(), <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;标题&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;subtitle&quot;</span>,<span class="string">&quot;副标题&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;description&quot;</span>,<span class="string">&quot;描述&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;authors&quot;</span>,<span class="string">&quot;作者&quot;</span>);</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">result</span> <span class="operator">=</span> redisHash.hMSet(key,map);</span><br><span class="line">    log.info(<span class="string">&quot; \n key &#123;&#125; \n data &#123;&#125; result &#123;&#125; &quot;</span>, key,gson.toJson(map),result);</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;标题1&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;subtitle&quot;</span>,<span class="string">&quot;副标题2&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;description&quot;</span>,<span class="string">&quot;描述3&quot;</span>);</span><br><span class="line">    map.put(<span class="string">&quot;authors&quot;</span>,<span class="string">&quot;作者4&quot;</span>);</span><br><span class="line">    key = String.format(<span class="string">&quot;%s:%s&quot;</span>, DocumentDto.class.getName(), <span class="string">&quot;2&quot;</span>);</span><br><span class="line">    result = redisHash.hMSet(key,map);</span><br><span class="line">    log.info(<span class="string">&quot; \n key &#123;&#125; \n data &#123;&#125; result &#123;&#125; &quot;</span>, key,gson.toJson(map),result);</span><br><span class="line">    List&lt;String&gt; fields = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    fields.add(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">    fields.add(<span class="string">&quot;subtitle&quot;</span>);</span><br><span class="line">    fields.add(<span class="string">&quot;description&quot;</span>);</span><br><span class="line">    fields.add(<span class="string">&quot;authors&quot;</span>);</span><br><span class="line">    SearchOptions.<span class="type">Summarize</span> <span class="variable">summarize</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchOptions</span>.Summarize();</span><br><span class="line">    summarize.setFields(fields);</span><br><span class="line">    <span class="type">SearchOptions</span> <span class="variable">searchOptions</span> <span class="operator">=</span> SearchOptions.builder()</span><br><span class="line">            .language(Language.CHINESE)</span><br><span class="line">            .limit(SearchOptions.Limit.of(<span class="number">0</span>,<span class="number">10</span>))</span><br><span class="line">            .summarize(summarize)</span><br><span class="line">            .build();</span><br><span class="line">    log.info(<span class="string">&quot; searchOptions &#123;&#125;&quot;</span>,gson.toJson(searchOptions));</span><br><span class="line">    SearchResults&lt;String, String&gt; results = commands.search(searchIndexName, <span class="string">&quot;标&quot;</span>, searchOptions);</span><br><span class="line">    log.info(<span class="string">&quot;&#123;&#125;&quot;</span>, gson.toJson(results));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">key cn.z201.learning.redis.operating.DocumentDto:1 </span><br><span class="line"> data &#123;</span><br><span class="line">  &quot;subtitle&quot;: &quot;副标题&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;描述&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;标题&quot;,</span><br><span class="line">  &quot;authors&quot;: &quot;作者&quot;</span><br><span class="line">&#125; result true </span><br><span class="line"></span><br><span class="line"> key cn.z201.learning.redis.operating.DocumentDto:2 </span><br><span class="line"> data &#123;</span><br><span class="line">  &quot;subtitle&quot;: &quot;副标题2&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;描述3&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;标题1&quot;,</span><br><span class="line">  &quot;authors&quot;: &quot;作者4&quot;</span><br><span class="line">&#125; result true </span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;title&quot;: &quot;标题1... &quot;,</span><br><span class="line">    &quot;subtitle&quot;: &quot;�&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;�&quot;,</span><br><span class="line">    &quot;authors&quot;: &quot;�&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;title&quot;: &quot;标题... &quot;,</span><br><span class="line">    &quot;subtitle&quot;: &quot;�&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;�&quot;,</span><br><span class="line">    &quot;authors&quot;: &quot;�&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>结果很不友好，对中文支持一般般。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;RediSearch 是一个高性能的全文搜索引擎，它可以作为一个 Redis Module（扩展模块）运行在 Redis 服务器上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;RediSearch&quot;&gt;&lt;a href=&quot;#RediSearch&quot; class=&quot;headerlink&quot; title=&quot;RediSearch&quot;&gt;&lt;/a&gt;RediSearch&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211228011936.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis 哈希中多个字段的全文索引&lt;/li&gt;
&lt;li&gt;无性能损失的增量索引&lt;/li&gt;
&lt;li&gt;文档排名（使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Tf%E2%80%93idf&quot;&gt;tf-idf&lt;/a&gt;，具有可选的用户提供的权重）&lt;/li&gt;
&lt;li&gt;场加权&lt;/li&gt;
&lt;li&gt;使用 AND、OR 和 NOT 运算符的复杂布尔查询&lt;/li&gt;
&lt;li&gt;前缀匹配、模糊匹配和精确短语查询&lt;/li&gt;
&lt;li&gt;支持&lt;a href=&quot;https://oss.redislabs.com/redisearch/Phonetic_Matching/&quot;&gt;双变音拼音匹配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;自动完成建议（带有模糊前缀建议）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://oss.redislabs.com/redisearch/Stemming/&quot;&gt;多种语言中&lt;/a&gt;基于词干的查询扩展（使用&lt;a href=&quot;http://snowballstem.org/&quot;&gt;Snowball&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;支持中文标记化和查询（使用&lt;a href=&quot;https://github.com/lionsoul2014/friso&quot;&gt;Friso&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;数字过滤器和范围&lt;/li&gt;
&lt;li&gt;使用&lt;a href=&quot;https://redis.io/commands/georadius&quot;&gt;Redis 地理空间索引&lt;/a&gt;进行&lt;a href=&quot;https://redis.io/commands/georadius&quot;&gt;地理&lt;/a&gt;空间搜索&lt;/li&gt;
&lt;li&gt;强大的聚合引擎&lt;/li&gt;
&lt;li&gt;支持所有 utf-8 编码文本&lt;/li&gt;
&lt;li&gt;检索完整文档、选定字段或仅检索文档 ID&lt;/li&gt;
&lt;li&gt;排序结果（例如，按创建日期）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;官方文档&quot;&gt;&lt;a href=&quot;#官方文档&quot; class=&quot;headerlink&quot; title=&quot;官方文档&quot;&gt;&lt;/a&gt;官方文档&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://oss.redis.com/redisearch/Commands/#&quot;&gt;Commands&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;运行环境&quot;&gt;&lt;a href=&quot;#运行环境&quot; class=&quot;headerlink&quot; title=&quot;运行环境&quot;&gt;&lt;/a&gt;运行环境&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;docker&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;mkdir&lt;/span&gt; -p redisearch/data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker run -p 6379:6379 -v &lt;span class=&quot;variable&quot;&gt;$PWD&lt;/span&gt;/redisearch/data:/data  -d redislabs/redisearch:latest &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;检查安装&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;➜  docker-run redis-cli &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127.0.0.1:6379&amp;gt; MODULE LIST&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1) 1) &lt;span class=&quot;string&quot;&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   2) &lt;span class=&quot;string&quot;&gt;&amp;quot;search&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   3) &lt;span class=&quot;string&quot;&gt;&amp;quot;ver&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   4) (&lt;span class=&quot;built_in&quot;&gt;integer&lt;/span&gt;) 20015&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127.0.0.1:6379&amp;gt; &lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;测试下&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;127.0.0.1:6379&amp;gt; FT.ADD idx docCn 1.0 LANGUAGE chinese FIELDS txt &lt;span class=&quot;string&quot;&gt;&amp;quot;Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。[8]&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127.0.0.1:6379&amp;gt; FT.SEARCH idx &lt;span class=&quot;string&quot;&gt;&amp;quot;数据&amp;quot;&lt;/span&gt; LANGUAGE chinese HIGHLIGHT SUMMARIZE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1) (&lt;span class=&quot;built_in&quot;&gt;integer&lt;/span&gt;) 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2) &lt;span class=&quot;string&quot;&gt;&amp;quot;docCn&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3) 1) &lt;span class=&quot;string&quot;&gt;&amp;quot;txt&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   2) &lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;lt;b&amp;gt;&#92;xe6&#92;x95&#92;xb0&#92;xe6&#92;x8d&#92;xae&amp;lt;/b&amp;gt;&#92;xe5... &amp;lt;b&amp;gt;&#92;xe6&#92;x95&#92;xb0&#92;xe6&#92;x8d&#92;xae&amp;lt;/b&amp;gt;&#92;xe8&#92;xbf&#92;x9b&#92;xe8&#92;xa1&#92;x8c&#92;xe5&#92;x86&#92;x99&#92;xe6&#92;x93&#92;x8d&#92;xe4&#92;xbd&#92;x9c&#92;xe3&#92;x80&#92;x82&#92;xe7&#92;x94&#92;xb1&#92;xe4&#92;xba&#92;x8e&#92;xe5&#92;xae&#92;x8c&#92;xe5&#92;x85&#92;xa8&#92;xe5&#92;xae&#92;x9e&#92;xe7&#92;x8e&#92;xb0&#92;xe4&#92;xba&#92;x86&#92;xe5&#92;x8f&#92;x91&#92;xe5&#92;xb8&#92;x83... &amp;lt;b&amp;gt;&#92;xe6&#92;x95&#92;xb0&#92;xe6&#92;x8d&#92;xae&amp;lt;/b&amp;gt;&#92;xe5&#92;x86&#92;x97&#92;xe4&#92;xbd&#92;x99&#92;xe5&#92;xbe&#92;x88&#92;xe6&#92;x9c&#92;x89&#92;xe5&#92;xb8&#92;xae&#92;xe5&#92;x8a&#92;xa9&#92;xe3&#92;x80&#92;x82[8... &amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;对中文支持不够好&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Programmatic" scheme="https://z201.cn/categories/Programmatic/"/>
    
    
    <category term="Programmatic" scheme="https://z201.cn/tags/Programmatic/"/>
    
    <category term="Redis" scheme="https://z201.cn/tags/Redis/"/>
    
    <category term="DataBase" scheme="https://z201.cn/tags/DataBase/"/>
    
    <category term="Redisearch" scheme="https://z201.cn/tags/Redisearch/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Optimization</title>
    <link href="https://z201.cn/posts/2485590586/"/>
    <id>https://z201.cn/posts/2485590586/</id>
    <published>2021-12-01T06:56:01.000Z</published>
    <updated>2024-01-06T10:36:53.234Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单优化的下博客。</p></blockquote><h3 id="优化内容"><a href="#优化内容" class="headerlink" title="优化内容"></a>优化内容</h3><ul><li>SEO优化</li><li>增加站内搜索</li><li>增加网站地图</li><li>添加字数统计和阅读时长</li><li>GitHub Fork Me</li><li>允许复制代码</li><li>图片懒加载</li></ul><h4 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h4><blockquote><p>hexo 默认生成文章命名方式，在中文标题下很不友好。可以选择生成永久的链接。</p></blockquote><ul><li>使用abbrlink插件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><ul><li>配置_config.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="comment">#permalink_defaults:</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink/</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span> <span class="comment">#support crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">dec</span>   <span class="comment">#support dec(default) and hex</span></span><br></pre></td></tr></table></figure><ul><li>生成的链接将会是这样的(官方样例)：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">crc16 &amp; hex</span><br><span class="line">https://post.x.com/posts/66c8.html</span><br><span class="line"></span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https://post.x.com/posts/65535.html</span><br><span class="line">crc32 &amp; hex</span><br><span class="line">https://post.x.com/posts/8ddf18fb.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; dec</span><br><span class="line">https://post.x.com/posts/1690090958.html</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="增加站内搜索"><a href="#增加站内搜索" class="headerlink" title="增加站内搜索"></a>增加站内搜索</h4><blockquote><p>增加站内搜索</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><ul><li>配置_config.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.json</span>  <span class="comment">#支持 json 或者 xml，默认 xml，但我用的有问题，推荐 json</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><ul><li>配置主题中的_config.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">   <span class="attr">enable:</span> <span class="literal">false</span> <span class="string">//</span> <span class="string">改成true</span></span><br></pre></td></tr></table></figure><h4 id="增加网站地图"><a href="#增加网站地图" class="headerlink" title="增加网站地图"></a>增加网站地图</h4><blockquote><p>站点的SEO</p></blockquote><ul><li>主要针对百度、谷歌</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><ul><li>配置_config.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br></pre></td></tr></table></figure><ul><li>增加robots.txt</li></ul><blockquote><p>网站根目录source下新建robots.txt</p></blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /archives/ </span><br><span class="line"></span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /vendors/</span><br><span class="line">Disallow: /fancybox/</span><br><span class="line"></span><br><span class="line">Sitemap: https://z201.com/sitemap.xml</span><br><span class="line">Sitemap: https://z201.com/baidusitemap.xml</span><br></pre></td></tr></table></figure><h4 id="增加字数统计阅读时长"><a href="#增加字数统计阅读时长" class="headerlink" title="增加字数统计阅读时长"></a>增加字数统计阅读时长</h4><blockquote><p>简单的优化</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><ul><li>配置_config.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line"> <span class="comment">#文章内是否显示</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line"> <span class="comment"># 网页底部是否显示</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">post_wordcount:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span>       </span><br><span class="line">  <span class="attr">wordcount:</span> <span class="literal">true</span>       <span class="comment"># 单篇 字数统计</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span>        <span class="comment"># 单篇 阅读时长</span></span><br><span class="line">  <span class="attr">totalcount:</span> <span class="literal">false</span>     <span class="comment"># 网站 字数统计</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>配置主题中的_config.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>  <span class="comment"># 是否换行显示 字数统计 及 阅读时长</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>  <span class="comment"># 文章 字数统计 阅读时长 使用图标 还是 文本表示</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span> <span class="comment"># 博客底部统计 字数统计 阅读时长 使用图标 还是 文本表示</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure><h4 id="GitHub-Fork-Me"><a href="#GitHub-Fork-Me" class="headerlink" title="GitHub Fork Me"></a>GitHub Fork Me</h4><blockquote><p>在网站的右上角增加githu仓库信息</p></blockquote><ul><li>修改主题中的_config.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `Follow me on GitHub` banner in the top-right corner.</span></span><br><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/z201</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br></pre></td></tr></table></figure><h4 id="允许复制代码"><a href="#允许复制代码" class="headerlink" title="允许复制代码"></a>允许复制代码</h4><blockquote><p>增加代码复制功能</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span></span><br><span class="line">  <span class="comment"># See: https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">night</span> <span class="string">eighties</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Show text copy result.</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span></span><br></pre></td></tr></table></figure><h4 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h4><blockquote><p>提高博客访问速度</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-lazyload-image --save</span><br></pre></td></tr></table></figure><ul><li>配置_config.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># image lazyload</span></span><br><span class="line"><span class="attr">lazyload:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="attr">onlypost:</span> <span class="literal">false</span>  <span class="comment"># 是否只对文章的图片做懒加载</span></span><br><span class="line">  <span class="attr">loadingImg:</span> <span class="comment"># eg ./images/loading.gif</span></span><br></pre></td></tr></table></figure><h4 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h4><blockquote><p>在页面上显示思维导图</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-simple-mindmap</span><br></pre></td></tr></table></figure><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Create-a-new-draft"><a href="#Create-a-new-draft" class="headerlink" title="Create a new draft"></a>Create a new draft</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new draft <span class="string">&quot;new draft&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Crete-a-new-page"><a href="#Crete-a-new-page" class="headerlink" title="Crete a new page"></a>Crete a new page</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> <span class="title class_">page</span> <span class="string">&quot;new page&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p><h3 id="Localization-testing"><a href="#Localization-testing" class="headerlink" title="Localization testing"></a>Localization testing</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server -g</span><br></pre></td></tr></table></figure><p>visit website : <a href="http://localhost:4000/">http://localhost:4000</a> </p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;简单优化的下博客。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;优化内容&quot;&gt;&lt;a href=&quot;#优化内容&quot; class=&quot;headerlink&quot; title=&quot;优化内容&quot;&gt;&lt;/a&gt;优化内容&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;SEO优化&lt;/li&gt;
&lt;li&gt;增加站内搜索&lt;/li&gt;
&lt;li&gt;增加网站地图&lt;/li&gt;
&lt;li&gt;添加字数统计和阅读时长&lt;/li&gt;
&lt;li&gt;GitHub Fork Me&lt;/li&gt;
&lt;li&gt;允许复制代码&lt;/li&gt;
&lt;li&gt;图片懒加载&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;SEO优化&quot;&gt;&lt;a href=&quot;#SEO优化&quot; class=&quot;headerlink&quot; title=&quot;SEO优化&quot;&gt;&lt;/a&gt;SEO优化&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;hexo 默认生成文章命名方式，在中文标题下很不友好。可以选择生成永久的链接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;使用abbrlink插件&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-abbrlink --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;配置_config.yml&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#permalink: :year/:month/:day/:title/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#permalink_defaults:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;permalink:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;posts/:abbrlink/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;abbrlink:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;alg:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;crc32&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#support crc16(default) and crc32&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attr&quot;&gt;rep:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;dec&lt;/span&gt;   &lt;span class=&quot;comment&quot;&gt;#support dec(default) and hex&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;生成的链接将会是这样的(官方样例)：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;crc16 &amp;amp; hex&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https://post.x.com/posts/66c8.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;crc16 &amp;amp; dec&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https://post.x.com/posts/65535.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;crc32 &amp;amp; hex&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https://post.x.com/posts/8ddf18fb.html&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;crc32 &amp;amp; dec&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;https://post.x.com/posts/1690090958.html&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Life" scheme="https://z201.cn/categories/Life/"/>
    
    
    <category term="Life" scheme="https://z201.cn/tags/Life/"/>
    
    <category term="Hexo" scheme="https://z201.cn/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Rust第一个CLI程序</title>
    <link href="https://z201.cn/posts/750520263/"/>
    <id>https://z201.cn/posts/750520263/</id>
    <published>2021-11-28T12:46:51.000Z</published>
    <updated>2021-12-23T14:36:57.188Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>编写第一个CLI小程序练手。</p></blockquote><h3 id="项目需求"><a href="#项目需求" class="headerlink" title="项目需求"></a>项目需求</h3><ul><li>访问一个网站,输出页面内容成md文件。</li></ul><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new learning-05 </span><br></pre></td></tr></table></figure><ul><li>使用vs code 打开项目。</li></ul><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><ul><li>修改Cargo.toml </li><li>引入 reqwest 和 html2md<ul><li>reqwest 是一个http客户端</li><li>html2md 顾名思义就是html转markdown</li></ul></li></ul><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">reqwest</span> = &#123; version = <span class="string">&quot;0.11&quot;</span>, features = [<span class="string">&quot;blocking&quot;</span>]&#125;</span><br><span class="line"><span class="attr">html2md</span> = <span class="string">&quot;0.2&quot;</span>%    </span><br></pre></td></tr></table></figure><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = <span class="string">&quot;https://z201.vip&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span> = <span class="string">&quot;z201.md&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;url &#123;&#125; output &#123;&#125;&quot;</span>,url,output);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">body</span> = reqwest::blocking::<span class="title function_ invoke__">get</span>(url).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">text</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Converting html to markdown...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">md</span> = html2md::<span class="title function_ invoke__">parse_html</span>(&amp;body);</span><br><span class="line">    </span><br><span class="line">    fs::<span class="title function_ invoke__">write</span>(output, md.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Converted markdown has been saved in &#123;&#125;.&quot;</span>, output);</span><br><span class="line">&#125;       </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url https://z201.vip output z201.md</span><br><span class="line">Converting html to markdown...</span><br><span class="line">Converted markdown has been saved in z201.md.</span><br></pre></td></tr></table></figure><h3 id="迭代代码"><a href="#迭代代码" class="headerlink" title="迭代代码"></a>迭代代码</h3><h4 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h4><ul><li>这里将url 和 output作为参数。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span>: <span class="type">Vec</span>&lt;<span class="type">String</span>&gt; = env::<span class="title function_ invoke__">args</span>().<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;args &#123;:?&#125; &quot;</span>,args);</span><br><span class="line">    <span class="comment">// 获取第一个参数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = &amp;args[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 获取第二个参数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span> = &amp;args[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 判断参数是否为空,不知道这个是否有效。</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(url.<span class="title function_ invoke__">is_empty</span>(),<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(output.<span class="title function_ invoke__">is_empty</span>(),<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;url &#123;&#125; output &#123;&#125;&quot;</span>,url,output);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">body</span> = reqwest::blocking::<span class="title function_ invoke__">get</span>(url).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">text</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Converting html to markdown...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">md</span> = html2md::<span class="title function_ invoke__">parse_html</span>(&amp;body);</span><br><span class="line">    </span><br><span class="line">    fs::<span class="title function_ invoke__">write</span>(output, md.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Converted markdown has been saved in &#123;&#125;.&quot;</span>, output);</span><br><span class="line">&#125;       </span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  learning-05 git:(master) ✗ cargo run https://z201.vip z201.md</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.09s</span><br><span class="line">     Running `target/debug/learning-05 <span class="string">&#x27;https://z201.vip&#x27;</span> z201.md`</span><br><span class="line">args [<span class="string">&quot;target/debug/learning-05&quot;</span>, <span class="string">&quot;https://z201.vip&quot;</span>, <span class="string">&quot;z201.md&quot;</span>] </span><br><span class="line">url https://z201.vip output z201.md</span><br><span class="line">Converting html to markdown...</span><br><span class="line">Converted markdown has been saved <span class="keyword">in</span> z201.md.</span><br></pre></td></tr></table></figure><h4 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h4><ul><li>换一种方式来处理参数</li><li>打包测试</li></ul><h5 id="增加依赖"><a href="#增加依赖" class="headerlink" title="增加依赖"></a>增加依赖</h5><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">reqwest</span> = &#123; version = <span class="string">&quot;0.11&quot;</span>, features = [<span class="string">&quot;blocking&quot;</span>]&#125;</span><br><span class="line"><span class="attr">html2md</span> = <span class="string">&quot;0.2&quot;</span></span><br><span class="line"><span class="attr">structopt</span> = <span class="string">&quot;0.3.13&quot;</span></span><br></pre></td></tr></table></figure><ul><li>代码</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"><span class="keyword">use</span> structopt::StructOpt; <span class="comment">// 使用StructOpt传递参数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(StructOpt, Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cli</span>&#123;</span><br><span class="line">    url:<span class="type">String</span>,</span><br><span class="line">    output:<span class="type">String</span>,</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">args</span> = Cli::<span class="title function_ invoke__">from_args</span>();</span><br><span class="line">    <span class="comment">// println!(&quot;args &#123;:?&#125; &quot;,args);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url</span> = &amp;args.url;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">output</span> = &amp;args.output;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;url &#123;&#125;\n output &#123;&#125;&quot;</span>,url,output);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">body</span> = reqwest::blocking::<span class="title function_ invoke__">get</span>(url).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">text</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Converting html to markdown...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">md</span> = html2md::<span class="title function_ invoke__">parse_html</span>(&amp;body);</span><br><span class="line">    fs::<span class="title function_ invoke__">write</span>(output, md.<span class="title function_ invoke__">as_bytes</span>()).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Converted markdown has been saved in &#123;&#125;.&quot;</span>, output);</span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">check</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build --release   </span><br></pre></td></tr></table></figure><ul><li>慢慢等待</li></ul><h4 id="测试下"><a href="#测试下" class="headerlink" title="测试下"></a>测试下</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> target/release</span><br><span class="line">./learning-05 https://z201.vip z201.md</span><br><span class="line">url https://z201.vip</span><br><span class="line"> output z201.md</span><br><span class="line">Converting html to markdown...</span><br><span class="line">Converted markdown has been saved <span class="keyword">in</span> z201.md.</span><br></pre></td></tr></table></figure><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;编写第一个CLI小程序练手。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;项目需求&quot;&gt;&lt;a href=&quot;#项目需求&quot; class=&quot;headerlink&quot; title=&quot;项目需求&quot;&gt;&lt;/a&gt;项目需求&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;访问一个网站,</summary>
      
    
    
    
    <category term="Rust" scheme="https://z201.cn/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://z201.cn/tags/Rust/"/>
    
    <category term="Cli" scheme="https://z201.cn/tags/Cli/"/>
    
  </entry>
  
  <entry>
    <title>Rust所有权</title>
    <link href="https://z201.cn/posts/3684915749/"/>
    <id>https://z201.cn/posts/3684915749/</id>
    <published>2021-11-27T04:43:39.000Z</published>
    <updated>2024-01-06T10:43:07.033Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Rust的核心功能之一 <strong>ownership</strong> ,运行的程序都需要使用计算机管理内存的方式，比如Java 具备垃圾回收，还有一些语言需要手动去释放内存。而Rust则是第三种方式，通过所有权管理内存，编译器在编译时会根据一些列规则检查，在运行时所有权系统的任务功能都不会减慢程序。</p></blockquote><ul><li><strong>所有权和生命周期是 Rust 和其它编程语言的主要区别，也是 Rust 其它知识点的基础。</strong></li></ul><h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><ul><li><p><strong>栈是程序运行的基础。每当一个函数被调用时，一块连续的内存就会在栈顶被分配出来，这块内存被称为帧（frame）。</strong></p></li><li><p>栈以放入值的顺序存储并以相反的顺序取出值。这也被称为 <strong>后进先出</strong> (last in , first out) 。添加数据的时候加 <strong>进栈</strong> (pushing anto the stack) ，而移出数据叫 <strong>出栈</strong> (poping off th stack)。</p></li><li><p>在调用的过程中，一个新的帧会分配足够的空间存储寄存器的上下文。在函数里使用到的通用寄存器会在栈保存一个副本，当这个函数调用结束，通过副本，可以恢复出原本的寄存器的上下文，就像什么都没有经历一样。此外，函数所需要使用到的局部变量，也都会在帧分配的时候被预留出来。</p></li><li><p>栈的操作时非常快的，这主要得益于它存取数据的方式，数据的存取位置总时在栈顶，而不需要重新寻找一个位置去存放或者读取。另一个属性就是，<strong>栈中所有的数据都必须占据已知且固定的大小。</strong></p></li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211222143000.png"></p><ul><li>但是工作中我们依然要避免大量数据存放栈中，<strong>避免栈溢出</strong>(stack overfow)，运行程序调用栈超出了系统运行的最大空间，就无法创建新的<strong>帧</strong>。就会出现<strong>溢出现象</strong>。</li></ul><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><blockquote><p>在编译时，一切无法确定大小或者大小可以改变的数据，都无法安全地放在栈上，最好放在堆上。</p></blockquote><ul><li>堆主要存放大小未知，可能大小变化的数据，堆事缺乏组织的。<strong>当向堆中存放数据时，要申请一个空间，操作系统在堆的某处足够大的空间，把它标记为已经使用。</strong>并返回一个指针(pointer)，这个过程叫做<strong>堆上分配内存</strong>(<em>allocating on the heap</em>)。</li><li>访问堆上的数据比访问栈上的数据慢,因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存）。当代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。</li></ul><h5 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">say</span>(name : <span class="type">String</span>)&#123;</span><br><span class="line"> <span class="title function_ invoke__">println</span>(<span class="string">&quot;name &#123;&#125;&quot;</span> , name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">say</span>(<span class="string">&quot;tomcat&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br><span class="line"><span class="title function_ invoke__">say</span>(<span class="string">&quot;jetty&quot;</span>.<span class="title function_ invoke__">to_string</span>());</span><br></pre></td></tr></table></figure><ul><li>字符串的数据结构，在编译器是不确定的，运行期才代码才知道大小。比如<code>tomcat</code> 和 <code>jetty</code>，当say方法执行的时候才知道参数的具体长度。</li></ul><h5 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">arr.<span class="title function_ invoke__">push</span>(<span class="number">1</span>);</span><br><span class="line">arr.<span class="title function_ invoke__">push</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><ul><li>列表初始化长度是4，而不是2。在堆上内存分配会使用libc提供的mallo函数。系统调用的代价是昂贵的，所以我们要避免频繁地 malloc()。</li></ul><h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><blockquote><p>如果手工管理堆内存的话，堆上内存分配后忘记释放，就会造成<strong>内存泄漏</strong>。一旦有内存泄漏，程序运行得越久，就越吃内存，最终会因为占满内存而被操作系统终止运行。</p></blockquote><h5 id="堆越界"><a href="#堆越界" class="headerlink" title="堆越界"></a>堆越界</h5><blockquote><p>如果堆上内存被释放，但栈上指向堆上内存的相应指针没有被清空，就有可能发生使用已释放内存（use after free）的情况。</p></blockquote><h5 id="GC垃圾回收处理"><a href="#GC垃圾回收处理" class="headerlink" title="GC垃圾回收处理"></a>GC垃圾回收处理</h5><ul><li>比如Java采用垃圾回收(<strong>GC</strong>)，来自动管理内存，定期标记(mark)找出不在被引用的对象，然后清理(sweep)掉。</li><li>但是GC是不确定的，可能引起STW(Stop The World)。</li></ul><h5 id="ARC自动引用计数处理方式"><a href="#ARC自动引用计数处理方式" class="headerlink" title="ARC自动引用计数处理方式"></a>ARC自动引用计数处理方式</h5><ul><li>在编译时，它为每个函数插入 retain&#x2F;release 语句来自动维护堆上对象的引用计数，当引用计数为零的时候，release 语句就释放对象。</li></ul><h4 id="栈与堆"><a href="#栈与堆" class="headerlink" title="栈与堆"></a>栈与堆</h4><ul><li><strong>栈上存放的数据是静态的，固定大小，固定生命周期；堆上存放的数据是动态的，不固定大小，不固定生命周期。</strong></li></ul><span id="more"></span><h4 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h4><ul><li>Rust中每一个值都有一个被称为其<strong>所有者</strong>的变量。</li><li>值有且只有一个所有者。当所有者（变量）离开作用域，这个值将被丢弃。</li></ul><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="comment">// 作用域开启， var无效，未声明。</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">var</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 使用var </span></span><br><span class="line">&#125; <span class="comment">// 作用域结束, var不再有效。</span></span><br></pre></td></tr></table></figure><ul><li><p>当变量<code>var</code>离开作用域的时候，Rust会调用一个特殊的函数<code>drop</code>自动处理。</p><blockquote><p>在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 <strong>资源获取即初始化</strong>（*Resource Acquisition Is Initialization (RAII)*）。</p></blockquote></li></ul><h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><blockquote><p>定义某个变量且赋值，在编译期间就知道了具体内容。</p></blockquote><h5 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure><ul><li>将<code>x</code>的值赋给<code>y</code>，这时候有了两个变量且值都等于5。此时栈中会存放两个5。</li></ul><h5 id="案例二-1"><a href="#案例二-1" class="headerlink" title="案例二"></a>案例二</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1 value &#123;&#125;&quot;</span>,s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s2 value &#123;&#125;&quot;</span>,s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--&gt; src/main.rs:5:28</span><br><span class="line">  |</span><br><span class="line">3 |     let s1 = String::from(&quot;hi&quot;);</span><br><span class="line">  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait</span><br><span class="line">4 |     let s2 = s1;</span><br><span class="line">  |              -- value moved here</span><br><span class="line">5 |     println!(&quot;s1 value &#123;&#125;&quot;,s1);</span><br><span class="line">  |                            ^^ value borrowed here after move</span><br></pre></td></tr></table></figure><ul><li>编译器会提示两个错误，将s1 赋值给 s2 后 s1 就不能被访问了。</li><li>如果还想让s1 被访问就需要 clone复制一份堆数据出来。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1 value &#123;&#125;&quot;</span>,s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s2 value &#123;&#125;&quot;</span>,s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, world!</span><br><span class="line">s1 value hi</span><br><span class="line">s2 value hi</span><br></pre></td></tr></table></figure><h4 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h4><blockquote><p>Rust 有一个叫做 <code>Copy</code> trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上</p></blockquote><ul><li>所有整数类型，比如 u32。</li><li>布尔类型，bool，它的值是 true 和 false。<br>所有浮点数类型，比如 f64。</li><li>字符类型，char。</li><li>Tuple元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是。</li></ul><h4 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a>所有权与函数</h4><blockquote><p>将值传递给函数在语义上与给变量赋值相似。向函数传递值可能会移动或者复制，就像赋值语句一样。</p></blockquote><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hi&quot;</span>);    <span class="comment">// s 进入作用域</span></span><br><span class="line">    <span class="title function_ invoke__">hello</span>(s);                    </span><br><span class="line">                                    <span class="comment">// s 到这里不再有效</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;                      <span class="comment">// x 进入作用域</span></span><br><span class="line">    <span class="title function_ invoke__">hello_copy</span>(x);                  <span class="comment">// x 应该移动函数里，</span></span><br><span class="line">                                    <span class="comment">// 但 i32 是 Copy 的，所以在后面可继续使用 x</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125; <span class="comment">// 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，</span></span><br><span class="line">  <span class="comment">// 所以不会有特殊操作</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>(some_string: <span class="type">String</span>) &#123; <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// 移出作用域并调用 `drop` 方法。占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">hello_copy</span>(some_integer: <span class="type">i32</span>) &#123; <span class="comment">// </span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// 移出作用域并调用 `drop` 方法。占用的内存被释放</span></span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hi</span><br><span class="line">5</span><br><span class="line">x 5</span><br></pre></td></tr></table></figure><h4 id="返回值与作用域"><a href="#返回值与作用域" class="headerlink" title="返回值与作用域"></a>返回值与作用域</h4><blockquote><p>返回值也可以转移所有权</p></blockquote><h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives</span>();              <span class="comment">// gives_ownership 将返回值移给 s1</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s1 &#123;&#125;&quot;</span>,s1);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s2 进入作用域</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s2 &#123;&#125;&quot;</span>,s2);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">gives_back</span>(s2);        <span class="comment">// s2 gives_back 中,  它也将返回值移给 s3</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s3 &#123;&#125;&quot;</span>,s3);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;             <span class="comment">//  将返回值移动给</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// some_string 进入作用域.</span></span><br><span class="line">    some_string                              <span class="comment">// 返回 some_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123; <span class="comment">// a_string 进入作用域</span></span><br><span class="line"></span><br><span class="line">    a_string  <span class="comment">// 返回 a_string 并移出给调用的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 hello</span><br><span class="line">s2 hello</span><br><span class="line">s3 hello</span><br></pre></td></tr></table></figure><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Rust的核心功能之一 &lt;strong&gt;ownership&lt;/strong&gt; ,运行的程序都需要使用计算机管理内存的方式，比如Java 具备垃圾回收，还有一些语言需要手动去释放内存。而Rust则是第三种方式，通过所有权管理内存，编译器在编译时会根据一些列规则检查，在运行时所有权系统的任务功能都不会减慢程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;所有权和生命周期是 Rust 和其它编程语言的主要区别，也是 Rust 其它知识点的基础。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;所有权&quot;&gt;&lt;a href=&quot;#所有权&quot; class=&quot;headerlink&quot; title=&quot;所有权&quot;&gt;&lt;/a&gt;所有权&lt;/h3&gt;&lt;h4 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;栈是程序运行的基础。每当一个函数被调用时，一块连续的内存就会在栈顶被分配出来，这块内存被称为帧（frame）。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;栈以放入值的顺序存储并以相反的顺序取出值。这也被称为 &lt;strong&gt;后进先出&lt;/strong&gt; (last in , first out) 。添加数据的时候加 &lt;strong&gt;进栈&lt;/strong&gt; (pushing anto the stack) ，而移出数据叫 &lt;strong&gt;出栈&lt;/strong&gt; (poping off th stack)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在调用的过程中，一个新的帧会分配足够的空间存储寄存器的上下文。在函数里使用到的通用寄存器会在栈保存一个副本，当这个函数调用结束，通过副本，可以恢复出原本的寄存器的上下文，就像什么都没有经历一样。此外，函数所需要使用到的局部变量，也都会在帧分配的时候被预留出来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;栈的操作时非常快的，这主要得益于它存取数据的方式，数据的存取位置总时在栈顶，而不需要重新寻找一个位置去存放或者读取。另一个属性就是，&lt;strong&gt;栈中所有的数据都必须占据已知且固定的大小。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211222143000.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;但是工作中我们依然要避免大量数据存放栈中，&lt;strong&gt;避免栈溢出&lt;/strong&gt;(stack overfow)，运行程序调用栈超出了系统运行的最大空间，就无法创建新的&lt;strong&gt;帧&lt;/strong&gt;。就会出现&lt;strong&gt;溢出现象&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;堆&quot;&gt;&lt;a href=&quot;#堆&quot; class=&quot;headerlink&quot; title=&quot;堆&quot;&gt;&lt;/a&gt;堆&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在编译时，一切无法确定大小或者大小可以改变的数据，都无法安全地放在栈上，最好放在堆上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;堆主要存放大小未知，可能大小变化的数据，堆事缺乏组织的。&lt;strong&gt;当向堆中存放数据时，要申请一个空间，操作系统在堆的某处足够大的空间，把它标记为已经使用。&lt;/strong&gt;并返回一个指针(pointer)，这个过程叫做&lt;strong&gt;堆上分配内存&lt;/strong&gt;(&lt;em&gt;allocating on the heap&lt;/em&gt;)。&lt;/li&gt;
&lt;li&gt;访问堆上的数据比访问栈上的数据慢,因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存）。当代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;案例一&quot;&gt;&lt;a href=&quot;#案例一&quot; class=&quot;headerlink&quot; title=&quot;案例一&quot;&gt;&lt;/a&gt;案例一&lt;/h5&gt;&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;say&lt;/span&gt;(name : &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	 &lt;span class=&quot;title function_ invoke__&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;name &amp;#123;&amp;#125;&amp;quot;&lt;/span&gt; , name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title function_ invoke__&quot;&gt;say&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;tomcat&amp;quot;&lt;/span&gt;.&lt;span class=&quot;title function_ invoke__&quot;&gt;to_string&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title function_ invoke__&quot;&gt;say&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;jetty&amp;quot;&lt;/span&gt;.&lt;span class=&quot;title function_ invoke__&quot;&gt;to_string&lt;/span&gt;());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;字符串的数据结构，在编译器是不确定的，运行期才代码才知道大小。比如&lt;code&gt;tomcat&lt;/code&gt; 和 &lt;code&gt;jetty&lt;/code&gt;，当say方法执行的时候才知道参数的具体长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;案例二&quot;&gt;&lt;a href=&quot;#案例二&quot; class=&quot;headerlink&quot; title=&quot;案例二&quot;&gt;&lt;/a&gt;案例二&lt;/h5&gt;&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;mut &lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;arr&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;Vec&lt;/span&gt;::&lt;span class=&quot;title function_ invoke__&quot;&gt;new&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr.&lt;span class=&quot;title function_ invoke__&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr.&lt;span class=&quot;title function_ invoke__&quot;&gt;push&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;列表初始化长度是4，而不是2。在堆上内存分配会使用libc提供的mallo函数。系统调用的代价是昂贵的，所以我们要避免频繁地 malloc()。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;如果手工管理堆内存的话，堆上内存分配后忘记释放，就会造成&lt;strong&gt;内存泄漏&lt;/strong&gt;。一旦有内存泄漏，程序运行得越久，就越吃内存，最终会因为占满内存而被操作系统终止运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;堆越界&quot;&gt;&lt;a href=&quot;#堆越界&quot; class=&quot;headerlink&quot; title=&quot;堆越界&quot;&gt;&lt;/a&gt;堆越界&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;如果堆上内存被释放，但栈上指向堆上内存的相应指针没有被清空，就有可能发生使用已释放内存（use after free）的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;GC垃圾回收处理&quot;&gt;&lt;a href=&quot;#GC垃圾回收处理&quot; class=&quot;headerlink&quot; title=&quot;GC垃圾回收处理&quot;&gt;&lt;/a&gt;GC垃圾回收处理&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;比如Java采用垃圾回收(&lt;strong&gt;GC&lt;/strong&gt;)，来自动管理内存，定期标记(mark)找出不在被引用的对象，然后清理(sweep)掉。&lt;/li&gt;
&lt;li&gt;但是GC是不确定的，可能引起STW(Stop The World)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;ARC自动引用计数处理方式&quot;&gt;&lt;a href=&quot;#ARC自动引用计数处理方式&quot; class=&quot;headerlink&quot; title=&quot;ARC自动引用计数处理方式&quot;&gt;&lt;/a&gt;ARC自动引用计数处理方式&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;在编译时，它为每个函数插入 retain&amp;#x2F;release 语句来自动维护堆上对象的引用计数，当引用计数为零的时候，release 语句就释放对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;栈与堆&quot;&gt;&lt;a href=&quot;#栈与堆&quot; class=&quot;headerlink&quot; title=&quot;栈与堆&quot;&gt;&lt;/a&gt;栈与堆&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;栈上存放的数据是静态的，固定大小，固定生命周期；堆上存放的数据是动态的，不固定大小，不固定生命周期。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://z201.cn/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://z201.cn/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust函数与控制流</title>
    <link href="https://z201.cn/posts/1087924605/"/>
    <id>https://z201.cn/posts/1087924605/</id>
    <published>2021-11-26T15:21:28.000Z</published>
    <updated>2024-01-06T10:58:24.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote><p>函数遍布于 Rust 代码中,Rust 代码中的函数和变量名使用 <em>snake case</em> 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词。</p></blockquote><ul><li>Rust 中的函数定义以 <code>fn</code> 开始并在函数名后跟一对圆括号。大括号告诉编译器哪里是函数体的开始和结尾。</li><li>可以使用函数名后跟圆括号来调用我们定义过的任意函数。<strong>Rust 不关心函数定义于何处，只要定义了就行。</strong></li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">hello</span>()&#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;hello function&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, world!</span><br><span class="line">hello function</span><br></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><blockquote><p>函数也可以被定义为拥有 参数（parameters），参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。</p></blockquote><ul><li>在函数签名中，<strong>必须</strong> 声明每个参数的类型。这是 Rust 设计中一个经过慎重考虑的决定：要求在函数定义中提供类型注解，意味着编译器不需要你在代码的其他地方注明类型来指出你的意图。</li><li>多个参数时，使用逗号分隔。</li></ul><h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">number</span>(x:<span class="type">i8</span>)&#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;value &#123;&#125; &quot;</span>,x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">number</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, world!</span><br><span class="line">value 1</span><br></pre></td></tr></table></figure><ul><li>number函数声明一个<code>x</code>的参数，<code>x</code>的类型被指定为<code>i8</code>。</li></ul><span id="more"></span><h3 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h3><blockquote><p>Rust 是一门基于表达式（expression-based）的语言,函数体由一系列的语句和一个可选的结尾表达式构成</p></blockquote><ul><li>函数可以向调用它的代码返回值。不需要对返回值命令，但要在箭头（<code>-&gt;</code>）后声明它的类型。在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。使用 <code>return</code> 关键字和指定值，可从函数中提前返回。</li></ul><h3 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="comment">// number(1);</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x &#123;&#125; y &#123;&#125;&quot;</span>, x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, world!</span><br><span class="line">x 5 y 4</span><br></pre></td></tr></table></figure><h3 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">i</span>() <span class="punctuation">-&gt;</span> <span class="type">i8</span>&#123;</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">i</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;value &#123;&#125;&quot;</span> , x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value 1</span><br></pre></td></tr></table></figure><h3 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a>案例三</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">ii</span>(x : <span class="type">i8</span>)<span class="punctuation">-&gt;</span> <span class="type">i8</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">ii</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;value &#123;&#125;&quot;</span>,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value 3</span><br></pre></td></tr></table></figure><h2 id="函数与变量"><a href="#函数与变量" class="headerlink" title="函数与变量"></a>函数与变量</h2><blockquote><p>在 Rust 下，函数是一等公民，可以作为参数或者返回值。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">one</span>(value: <span class="type">i32</span>, f: <span class="title function_ invoke__">fn</span>(<span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">f</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">two</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    value * value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">three</span>(value: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    value * value * value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;apply square: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">apply</span>(<span class="number">2</span>, square));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;apply cube: &#123;&#125;&quot;</span>, <span class="title function_ invoke__">apply</span>(<span class="number">2</span>, cube));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply square: 4</span><br><span class="line">apply cube: 8</span><br></pre></td></tr></table></figure><ul><li><strong>fn(i32) -&gt; i32 是 three函数第二个参数，它表示可以接受一个函数作为参数。这个传入的函数必须是：参数只有一个，且类型为 i32，返回值类型也是 i32。</strong></li><li><strong>Rust 函数参数的类型和返回值的类型都必须显式定义，如果没有返回值可以省略，返回 unit。函数内部如果提前返回，需要用 return 关键字</strong></li></ul><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><blockquote><p>根据条件是否为真来决定是否执行某些代码</p></blockquote><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><h4 id="案例一-1"><a href="#案例一-1" class="headerlink" title="案例一"></a>案例一</h4><ul><li>注意不需要()</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n <span class="title function_ invoke__">ii</span>(x : <span class="type">i8</span>)<span class="punctuation">-&gt;</span> <span class="type">i8</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">ii</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> number &gt; x&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;value &#123;&#125;&quot;</span>,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;value x &#123;&#125;&quot;</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value 3</span><br></pre></td></tr></table></figure><h4 id="案例二-1"><a href="#案例二-1" class="headerlink" title="案例二"></a>案例二</h4><blockquote><p>在 let 语句中使用if</p></blockquote><ul><li>将if 表达式中返回值赋给一个变量。这里需要注意返回类型需要一致。否则编译失败。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> c &#123;</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of c is: &#123;&#125;&quot;</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><blockquote><p>Rust 为此提供了多种 <strong>循环</strong>（<em>loops</em>）。一个循环执行循环体中的代码直到结尾并紧接着回到开头继续执行。</p></blockquote><h4 id="案例一-2"><a href="#案例一-2" class="headerlink" title="案例一"></a>案例一</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Console，需要手动停止。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello!</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><h4 id="案例二-2"><a href="#案例二-2" class="headerlink" title="案例二"></a>案例二</h4><blockquote><p>使用break 关键字跳出循环。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        number += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;result &#123;&#125; value &#123;&#125;&quot;</span>,result ,number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result 10 value 10</span><br></pre></td></tr></table></figure><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><blockquote><p>当条件为真，执行循环。当条件不再为真。调用 <code>break</code> 停止循环。</p></blockquote><h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> number &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">        number = number - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;done &#123;&#125; &quot;</span>,number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3!</span><br><span class="line">2!</span><br><span class="line">1!</span><br><span class="line">done 0 </span><br></pre></td></tr></table></figure><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><blockquote><p>遍历集合</p></blockquote><h4 id="案例一-3"><a href="#案例一-3" class="headerlink" title="案例一"></a>案例一</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="number">3</span> &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;value &#123;&#125;&quot;</span>,arr[index]);</span><br><span class="line">index = index + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;value is: &#123;&#125;&quot;</span>, element);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">value 1</span><br><span class="line">value 2</span><br><span class="line">value 3</span><br><span class="line">value is: 1</span><br><span class="line">value is: 2</span><br><span class="line">value is: 3</span><br><span class="line">value is: 4</span><br><span class="line">value is: 5</span><br></pre></td></tr></table></figure><h4 id="案例二-3"><a href="#案例二-3" class="headerlink" title="案例二"></a>案例二</h4><blockquote><p>使用 <code>rev</code>来反转range</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;done!!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3!</span><br><span class="line">2!</span><br><span class="line">1!</span><br><span class="line">done!!!</span><br></pre></td></tr></table></figure><h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;函数遍布于 Rust 代码中,Rust 代码中的函数和变量名使用 &lt;em&gt;snake case&lt;/em&gt; 规范风格。在 snake case 中，所有字母都是小写并使用下划线分隔单词。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Rust 中的函数定义以 &lt;code&gt;fn&lt;/code&gt; 开始并在函数名后跟一对圆括号。大括号告诉编译器哪里是函数体的开始和结尾。&lt;/li&gt;
&lt;li&gt;可以使用函数名后跟圆括号来调用我们定义过的任意函数。&lt;strong&gt;Rust 不关心函数定义于何处，只要定义了就行。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;案例&quot;&gt;&lt;a href=&quot;#案例&quot; class=&quot;headerlink&quot; title=&quot;案例&quot;&gt;&lt;/a&gt;案例&lt;/h3&gt;&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Hello, world!&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;title function_ invoke__&quot;&gt;hello&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;hello&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;hello function&amp;quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;Console&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight tex&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Hello, world!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hello function&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;函数参数&quot;&gt;&lt;a href=&quot;#函数参数&quot; class=&quot;headerlink&quot; title=&quot;函数参数&quot;&gt;&lt;/a&gt;函数参数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;函数也可以被定义为拥有 参数（parameters），参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在函数签名中，&lt;strong&gt;必须&lt;/strong&gt; 声明每个参数的类型。这是 Rust 设计中一个经过慎重考虑的决定：要求在函数定义中提供类型注解，意味着编译器不需要你在代码的其他地方注明类型来指出你的意图。&lt;/li&gt;
&lt;li&gt;多个参数时，使用逗号分隔。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;案例-1&quot;&gt;&lt;a href=&quot;#案例-1&quot; class=&quot;headerlink&quot; title=&quot;案例&quot;&gt;&lt;/a&gt;案例&lt;/h3&gt;&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;number&lt;/span&gt;(x:&lt;span class=&quot;type&quot;&gt;i8&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;print!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;value &amp;#123;&amp;#125; &amp;quot;&lt;/span&gt;,x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Hello, world!&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;title function_ invoke__&quot;&gt;number&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;Console&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Hello, world!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;value 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;number函数声明一个&lt;code&gt;x&lt;/code&gt;的参数，&lt;code&gt;x&lt;/code&gt;的类型被指定为&lt;code&gt;i8&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://z201.cn/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://z201.cn/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust变量与数据类型</title>
    <link href="https://z201.cn/posts/2633150323/"/>
    <id>https://z201.cn/posts/2633150323/</id>
    <published>2021-11-25T14:49:11.000Z</published>
    <updated>2024-01-06T09:42:32.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Rust变量与数据类型"><a href="#Rust变量与数据类型" class="headerlink" title="Rust变量与数据类型"></a>Rust变量与数据类型</h2><blockquote><p>Rust 是一种静态类型的语言。 Rust 中的每个值都是某种数据类型。 编译器可以根据分配给它的值自动推断变量的数据类型。</p></blockquote><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><blockquote><p>使用let关键字声明变量</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Rust基础语法!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">str_</span> = <span class="string">&quot;String&quot;</span>; <span class="comment">// string 类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f_</span> = <span class="number">1.1</span>; <span class="comment">// float 类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bool_</span> = <span class="literal">true</span>; <span class="comment">// boolean 类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">char_</span> = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// unicode character </span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;string &#123;&#125;&quot;</span>,str_); </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;float &#123;&#125;&quot;</span>,f_); </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;boolean &#123;&#125;&quot;</span>,bool_); </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;icon &#123;&#125;&quot;</span>,char_); </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rust基础语法!</span><br><span class="line">string String</span><br><span class="line"><span class="built_in">float</span> 1.1</span><br><span class="line">boolean <span class="literal">true</span></span><br><span class="line">icon a</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="println"><a href="#println" class="headerlink" title="println!"></a>println!</h3><blockquote><p>打印控制台方法</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="meta">#[stable(feature = <span class="string">&quot;rust1&quot;</span>, since = <span class="string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line"><span class="meta">#[allow_internal_unstable(print_internals, format_args_nl)]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    () =&gt; ($crate::<span class="built_in">print!</span>(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    ($($arg:tt)*) =&gt; (&#123;</span><br><span class="line">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个参数是占位符 *{ }*，特别的语法</li><li>一个参数是变量或者常量</li></ul><h3 id="scalar-Types"><a href="#scalar-Types" class="headerlink" title="scalar Types"></a>scalar Types</h3><blockquote><p>Rust有四种标量类型 整型、浮点型、布尔型、字符型</p></blockquote><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><blockquote><p>整型是指没有小数部分的数字。也就是说，整型是用于表示整数的。整型可以进一步分为有符号（Signed）与无符号（Unsigned）的。可以存储正负值。</p></blockquote><table><thead><tr><th></th><th>大小</th><th>有符号Signed</th><th>无符号Unsigned</th></tr></thead><tbody><tr><td></td><td>8bit</td><td>i8</td><td>u8</td></tr><tr><td></td><td>16bit</td><td>i16</td><td>u16</td></tr><tr><td></td><td>32bit</td><td>i32</td><td>u32</td></tr><tr><td></td><td>64bit</td><td>i64</td><td>u64</td></tr><tr><td></td><td>128bit</td><td>i128</td><td>u128</td></tr><tr><td></td><td>arch</td><td>issize</td><td>Size</td></tr></tbody></table><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="number">1</span>;    <span class="comment">// 默认类型为i32</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">u20</span>:<span class="type">u32</span> = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">i32</span>:<span class="type">i32</span> = -<span class="number">15</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s</span>:<span class="type">isize</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">count</span>:<span class="type">usize</span> = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;result value is &#123;&#125;&quot;</span>,result);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;u20 is &#123;&#125; i32 is &#123;&#125;&quot;</span>,u20,<span class="type">i32</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;mark is &#123;&#125; and count is &#123;&#125;&quot;</span>,s,count);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result value is 1</span><br><span class="line">u20 is 20 i32 is -15</span><br><span class="line">mark is 10 and count is 30</span><br></pre></td></tr></table></figure><h4 id="整型溢出"><a href="#整型溢出" class="headerlink" title="整型溢出"></a>整型溢出</h4><blockquote><p>当分配给整型变量的值超出该整型在 Rust 中定义值的范围时，就会发生整型溢出</p></blockquote><h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">u1</span>:<span class="type">u8</span> = <span class="number">255</span>;</span><br><span class="line"><span class="comment">// u8数据范围为0~255</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">u2</span>:<span class="type">u8</span> = <span class="number">256</span>;   <span class="comment">//溢出值为 1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">u3</span>:<span class="type">u8</span> = <span class="number">257</span>;   <span class="comment">//溢出值为 2</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">u4</span>:<span class="type">u8</span> = <span class="number">258</span>;    <span class="comment">//溢出值为 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;1 is &#123;&#125; &quot;</span>,u1);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;2 is &#123;&#125;&quot;</span>,u2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;3 is &#123;&#125;&quot;</span>,u3);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;4 is &#123;&#125;&quot;</span>,u4);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">error: literal out of range <span class="keyword">for</span> `u8`</span><br><span class="line">  --&gt; src/main.rs:24:16</span><br><span class="line">   |</span><br><span class="line">24 |    <span class="built_in">let</span> u2:u8 = 256;   //溢出值为 1</span><br><span class="line">   |                ^^^</span><br><span class="line">   |</span><br><span class="line">   = note: `<span class="comment">#[deny(overflowing_literals)]` on by default</span></span><br><span class="line">   = note: the literal `256` does not fit into the <span class="built_in">type</span> `u8` whose range is `0..=255`</span><br><span class="line"></span><br><span class="line">error: literal out of range <span class="keyword">for</span> `u8`</span><br><span class="line">  --&gt; src/main.rs:25:16</span><br><span class="line">   |</span><br><span class="line">25 |    <span class="built_in">let</span> u3:u8 = 257;   //溢出值为 2</span><br><span class="line">   |                ^^^</span><br><span class="line">   |</span><br><span class="line">   = note: the literal `257` does not fit into the <span class="built_in">type</span> `u8` whose range is `0..=255`</span><br><span class="line"></span><br><span class="line">error: literal out of range <span class="keyword">for</span> `u8`</span><br><span class="line">  --&gt; src/main.rs:26:16</span><br><span class="line">   |</span><br><span class="line">26 |    <span class="built_in">let</span> u4:u8 = 258;    //溢出值为 3</span><br><span class="line">   |                ^^^</span><br><span class="line">   |</span><br><span class="line">   = note: the literal `258` does not fit into the <span class="built_in">type</span> `u8` whose range is `0..=255`</span><br><span class="line"></span><br><span class="line">error: could not compile `learning-02` due to 3 previous errors</span><br></pre></td></tr></table></figure><ul><li>Rust的提示非常棒</li></ul><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><blockquote><p>Rust 中的浮点型可被分为 <strong>f32</strong> 和 <strong>f64</strong>。f32 是单精度浮点型，f64 是双精度浮点型。默认浮点型为 f64。</p></blockquote><h5 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">f1</span> = <span class="number">10.00</span>;        <span class="comment">//默认为 f64 浮点型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">f2</span>:<span class="type">f32</span> = <span class="number">8.35</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">f3</span>:<span class="type">f64</span> = <span class="number">15000.600</span>;  <span class="comment">//双精度浮点型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;f1 value is &#123;&#125;&quot;</span>,f1);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;f2 is &#123;&#125;&quot;</span>,f2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;f3 is &#123;&#125;&quot;</span>,f3);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1 value is 10</span><br><span class="line">f2 is 8.35</span><br><span class="line">f3 is 15000.6</span><br></pre></td></tr></table></figure><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><blockquote><p>Rust 中不支持自动类型转换</p></blockquote><h5 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">interest</span>:<span class="type">f32</span> = <span class="number">8</span>;   <span class="comment">// 浮点型变量被赋予整型值</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;interest is &#123;&#125;&quot;</span>,interest);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: mismatched types</span><br><span class="line">  --&gt; src/main.rs:41:23</span><br><span class="line">   |</span><br><span class="line">41 |    let interest:f32 = 8;   // 浮点型变量被赋予整型值</span><br><span class="line">   |                 ---   ^</span><br><span class="line">   |                 |     |</span><br><span class="line">   |                 |     expected `f32`, found integer</span><br><span class="line">   |                 |     help: use a float literal: `8.0`</span><br><span class="line">   |                 expected due to this</span><br></pre></td></tr></table></figure><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><blockquote><p>布尔型有两种可能的值 ——<em>true</em> 或是 <em>false</em>。使用 <strong>bool</strong> 关键字可以声明布尔型变量。</p></blockquote><h5 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">b</span>:<span class="type">bool</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;boolean &#123;&#125;&quot;</span>,b);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean true</span><br></pre></td></tr></table></figure><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><blockquote><p>Rust 中的字符型支持数字，字母，Unicode 和特殊字符。使用 char 关键字可以声明字符型变量。Rust 中的字符型用 Unicode 标量值储存，即 Rust 中的字符型可以表示比 ASCII 更多的字符。Unicode 标量值的范围包括从 U+0000 到 U+D7FF 和从 U+E000 到 U+10FFFF。</p></blockquote><h5 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">def_c</span> = <span class="string">&#x27;@&#x27;</span>; <span class="comment">//默认为字符型</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span>:<span class="type">char</span> = <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">emoji</span>:<span class="type">char</span> = &#x27;😁&#x27;;</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">character is @</span><br><span class="line">alphabet is Z</span><br><span class="line">emoji is 😁</span><br></pre></td></tr></table></figure><h5 id="类型转字符串"><a href="#类型转字符串" class="headerlink" title="类型转字符串"></a>类型转字符串</h5><blockquote><p>to_String()</p></blockquote><h6 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h6><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">u32</span> = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="variable">s</span>: <span class="type">String</span> = x.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h4 id="let变量"><a href="#let变量" class="headerlink" title="let变量"></a>let变量</h4><blockquote><p>变量是程序可以操纵的命名存储</p></blockquote><ul><li><p>必须以字母或下划线开头。</p></li><li><p>变量的名称可以由字母，数字和下划线字符组成。</p></li><li><p>Rust区分大小写</p></li><li><p>不可变性</p><ul><li>变量默认是不可变的，只读的。也就是说，变量的值在初始化后不可再被改变。比如</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">var</span> = <span class="number">25_000</span>;</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;var is &#123;&#125; &quot;</span>,var);</span><br><span class="line"> var = <span class="number">35_000</span>;</span><br><span class="line"> <span class="built_in">println!</span>(<span class="string">&quot;var changed is &#123;&#125;&quot;</span>,var);</span><br></pre></td></tr></table></figure><p>Console</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  --&gt; src/main.rs:57:5</span><br><span class="line">   |</span><br><span class="line">55 |     let var = 25_000;</span><br><span class="line">   |         ---</span><br><span class="line">   |         |</span><br><span class="line">   |         first assignment to `var`</span><br><span class="line">   |         help: consider making this binding mutable: `mut var`</span><br><span class="line">56 |     println!(&quot;var is &#123;&#125; &quot;,var);</span><br><span class="line">57 |     var = 35_000;</span><br><span class="line">   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable</span><br></pre></td></tr></table></figure><ul><li>可变性<ul><li>在变量名前加上 <strong>mut</strong> 关键字可以使其可变。可变变量的值可以更改。</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">var</span> = <span class="number">25_000</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;var is &#123;&#125; &quot;</span>,var);</span><br><span class="line">  var = <span class="number">35_000</span>;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;var changed is &#123;&#125;&quot;</span>,var);</span><br></pre></td></tr></table></figure><p>Console</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var is 25000 </span><br><span class="line">var changed is 35000</span><br></pre></td></tr></table></figure><h4 id="const常量"><a href="#const常量" class="headerlink" title="const常量"></a>const常量</h4><blockquote><p>常量一定要显式声明它的数据类型。以下是声明常量的语法：</p></blockquote><ul><li>而声明常量时一定要声明它的数据类型。<code>const VARIABLE_NAME:dataType = value;</code></li><li>使用 <strong>let</strong> 关键字声明的变量默认是不可变的。但是你可以选择使用 <strong>mut</strong> 关键字来使其可变。常量则<code>永远是不可变的</code>。</li><li>常量可以在任何范围内声明，包括全局范围。</li></ul><h5 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VAR_NAME:<span class="type">char</span> = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;VAR_NAME is &#123;&#125;&quot;</span>,VAR_NAME);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VAR_NAME is A</span><br></pre></td></tr></table></figure><h4 id="shadowing-覆盖"><a href="#shadowing-覆盖" class="headerlink" title="shadowing 覆盖"></a>shadowing 覆盖</h4><blockquote><p>Rust 支持不同数据类型的变量之间的覆盖（隐藏 shadowing）。</p></blockquote><ul><li>变量可以被覆盖，常量不行。</li></ul><h5 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">salary</span> = <span class="number">100.00</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">salary</span> = <span class="number">1.50</span> ; </span><br><span class="line"><span class="comment">// 读取salary变量的值</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of salary is :&#123;&#125;&quot;</span>,salary);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The value of salary is :1.5</span><br></pre></td></tr></table></figure><h5 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> salary2 = <span class="number">100.00</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">salary2</span> = <span class="number">1.50</span> ; </span><br><span class="line"><span class="comment">// 读取salary变量的值</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of salary is :&#123;&#125;&quot;</span>,salary2);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  --&gt; src/main.rs:68:11</span><br><span class="line">   |</span><br><span class="line">68 |     const salary2 = 100.00;</span><br><span class="line">   |           ^^^^^^^ help: provide a type for the constant: `salary2: f64`</span><br></pre></td></tr></table></figure><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><blockquote><p>运算符（操作符）定义了对于数据的的处理。被运算符所作用的数据被称为运算数。</p></blockquote><h4 id="算数运算法"><a href="#算数运算法" class="headerlink" title="算数运算法"></a>算数运算法</h4><ul><li>加 +</li><li>减 -</li><li>乘 *</li><li>除 &#x2F; </li><li>取余 %</li></ul><h4 id="操作运算符"><a href="#操作运算符" class="headerlink" title="操作运算符"></a>操作运算符</h4><ul><li><code>&gt;</code> 大于</li><li><code>&lt;</code>小于</li><li><code>&gt;=</code> 大于等于</li><li><code>&lt;=</code> 小于等于</li><li><code>==</code> 等于</li><li><code>!=</code> 不等于</li></ul><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><ul><li><code>&amp;&amp;</code> 与</li><li><code>||</code> 或</li><li><code>! </code>非</li></ul><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><ul><li>&amp; （按位与）</li><li>|（按位或）</li><li>^（按位异或）</li><li>!（按位非）</li><li>&lt;&lt;（左移）</li><li>&gt;&gt;（右移）</li><li>&gt;&gt;&gt;（无符号右移）</li></ul><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Rust变量与数据类型&quot;&gt;&lt;a href=&quot;#Rust变量与数据类型&quot; class=&quot;headerlink&quot; title=&quot;Rust变量与数据类型&quot;&gt;&lt;/a&gt;Rust变量与数据类型&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Rust 是一种静态类型的语言。 Rust 中的每个值都是某种数据类型。 编译器可以根据分配给它的值自动推断变量的数据类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;let&quot;&gt;&lt;a href=&quot;#let&quot; class=&quot;headerlink&quot; title=&quot;let&quot;&gt;&lt;/a&gt;let&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;使用let关键字声明变量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;Rust基础语法!&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;str_&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&amp;quot;String&amp;quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// string 类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;f_&lt;/span&gt; = &lt;span class=&quot;number&quot;&gt;1.1&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// float 类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;bool_&lt;/span&gt; = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// boolean 类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;char_&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&amp;#x27;a&amp;#x27;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// unicode character &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;string &amp;#123;&amp;#125;&amp;quot;&lt;/span&gt;,str_); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;float &amp;#123;&amp;#125;&amp;quot;&lt;/span&gt;,f_); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;boolean &amp;#123;&amp;#125;&amp;quot;&lt;/span&gt;,bool_); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;println!&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;icon &amp;#123;&amp;#125;&amp;quot;&lt;/span&gt;,char_); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;Console&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Rust基础语法!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;string String&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;float&lt;/span&gt; 1.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;boolean &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;icon a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://z201.cn/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://z201.cn/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门</title>
    <link href="https://z201.cn/posts/3684915742/"/>
    <id>https://z201.cn/posts/3684915742/</id>
    <published>2021-11-23T18:43:39.000Z</published>
    <updated>2024-01-06T10:43:10.593Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习下Rust</p></blockquote><h2 id="为什么学习Rust"><a href="#为什么学习Rust" class="headerlink" title="为什么学习Rust"></a>为什么学习Rust</h2><blockquote><p>在知乎上看到一个人对Rust的评论。</p><p>首先，Rust 是有点反人类，否则不会一直都不火。然后，Rust 之所以反人类，是因为人类这玩意既愚蠢，又自大，破事还贼多。 你看 C++ 就很相信人类，它要求人类自己把自己 new 出来的东西给 delete 掉。 C++：“这点小事我相信你可以的！” 人类：“没问题！包在我身上！” 然后呢，内存泄漏、double free、野指针满世界飘…… C++：“……”</p><p>Java 选择不相信人类，但替人类把事办好。 Java：“别动，让我来，我有gc！” 人类：“你怎么做事这么慢呀？你怎么还 stop the world 了呀？你是不是不爱我了呀？” Java：“……”</p><p>Rust 发现唯一的办法就是既不相信人类，也不惯着人类。 Rust：“按老子说的做，不做就不编译！” 人类：“你反人类！” Rust：“滚！”</p></blockquote><ul><li>C&#x2F;C++ 完全相信而且惯着程序员，让大家自行管理内存，所以可以编写很自由的代码，但一个不小心就会造成内存泄漏等问题导致程序崩溃。</li><li>Java&#x2F;Golang 完全不相信程序员，但也惯着程序员。所有的内存生命周期都由 JVM 运行时统一管理。 在绝大部分场景下，你可以非常自由的写代码，而且不用关心内存到底是什么情况。 内存使用有问题的时候，我们可以通过 JVM 来信息相关的分析诊断和调整。</li><li>Rust 语言选择既不相信程序员，也不惯着程序员。 让你在写代码的时候，必须清楚明白的用 Rust 的规则管理好你的变量，好让机器能明白高效地分析和管理内存。 但是这样会导致代码不利于人的理解，写代码很不自由，学习成本也很高。</li></ul><span id="more"></span><h2 id="安装Rust开发环境"><a href="#安装Rust开发环境" class="headerlink" title="安装Rust开发环境"></a>安装Rust开发环境</h2><h3 id="安装Rust"><a href="#安装Rust" class="headerlink" title="安装Rust"></a>安装Rust</h3><blockquote><p>Rust在Mac系统上非常的友好</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure><ul><li>脚本会检测你的操作系统，然后提示你是否安装</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211124031930.png"></p><ul><li>默认选择1就好了</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211124032020.png"></p><ul><li>这样就安装好了</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="variable">$HOME</span>/.cargo/env</span><br><span class="line"><span class="comment"># 设置下Rust的环境变量</span></span><br><span class="line">rustc --version </span><br><span class="line"><span class="comment"># 如果正常显示版本说明安装成功了</span></span><br></pre></td></tr></table></figure><h3 id="创建测试项目"><a href="#创建测试项目" class="headerlink" title="创建测试项目"></a>创建测试项目</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> learning</span><br><span class="line"><span class="built_in">cd</span> learning</span><br><span class="line">cargo new learning-01</span><br><span class="line"><span class="built_in">cd</span> learning-01</span><br><span class="line">cargo run</span><br><span class="line"></span><br><span class="line">Hello, world!</span><br><span class="line"><span class="comment"># 如果变成成功并输出消息则表示测试项目通过了。</span></span><br></pre></td></tr></table></figure><h2 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h2><blockquote><p>Rust 是一个系统级编程语言，被 Mozilla 员工 “Graydon Hoare” 于 2006 年 开发。他形容 Rust 是一种线程安全的支持并发的实用型的编程语言，支持函数式编程与命令式编程。</p></blockquote><h3 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h3><blockquote><p>Cargo是Rust的构建系统和包管理工具，和Java中maven类似的功能。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查看版本</span><br><span class="line">cargo --version </span><br></pre></td></tr></table></figure><ul><li>创建一个项目</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cargo new new_project</span><br><span class="line"><span class="built_in">cd</span> new _project</span><br><span class="line">➜  new_project git:(master) ✗ tree </span><br><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br><span class="line"></span><br><span class="line">1 directory, 2 files</span><br></pre></td></tr></table></figure><ul><li>这里的Cargo.toml就是配置文件 <a href="https://github.com/toml-lang/toml"><em>TOML</em></a> (<em>Tom’s Obvious, Minimal Language</em>) 格式，这是 Cargo 配置文件的格式。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[package]</span><br><span class="line">name = &quot;new_project&quot;</span><br><span class="line">version = &quot;0.1.0&quot;</span><br><span class="line">edition = &quot;2021&quot;</span><br><span class="line"></span><br><span class="line"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br></pre></td></tr></table></figure><ul><li>构建并运行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br><span class="line">➜  new_project git:(master) ✗ cargo build</span><br><span class="line">   Compiling new_project v0.1.0 (/Users/z201/word/rust/learning-rust/new_project)</span><br><span class="line">    Building [                             ] 0/1: new_project(bin)                                                                                                                                                                </span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 11.12s</span><br><span class="line">    </span><br><span class="line">➜  new_project git:(master) ✗ ./target/debug/new_project </span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><ul><li>也可以直接编译加运行</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure><ul><li>快速检查是否可以编译</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo check</span><br></pre></td></tr></table></figure><h2 id="使用VS-Code作为开发工具"><a href="#使用VS-Code作为开发工具" class="headerlink" title="使用VS Code作为开发工具"></a>使用VS Code作为开发工具</h2><blockquote><p>这里主要安装一些社区推荐的插件</p></blockquote><ol><li>rust-analyzer：它会实时编译和分析你的 Rust 代码，提示代码中的错误，并对类型进行标注。你也可以使用官方的 rust 插件取代。</li><li>rust syntax：为代码提供语法高亮。</li><li>crates：帮助你分析当前项目的依赖是否是最新的版本。</li><li>better toml：Rust 使用 toml 做项目的配置管理。可以帮你语法高亮，并展示 toml 文件中的错误。</li><li>rust test lens：可以帮你快速运行某个 Rust 测试。</li><li>Tabnine：基于 AI 的自动补全，可以帮助你更快地撰写代码。</li></ol><h3 id="使用国内的Rust镜像"><a href="#使用国内的Rust镜像" class="headerlink" title="使用国内的Rust镜像"></a>使用国内的Rust镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到cargo</span></span><br><span class="line"><span class="built_in">cd</span> ~/.cargo/.</span><br><span class="line"><span class="comment"># 创建一个config文件</span></span><br><span class="line">➜  .cargo <span class="built_in">touch</span> config</span><br><span class="line">➜  .cargo vim config </span><br><span class="line">➜  .cargo <span class="built_in">chmod</span> u+x config </span><br></pre></td></tr></table></figure><ul><li>往config写入内容</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry = <span class="string">&quot;https://github.com/rust-lang/crates.io-index&quot;</span></span><br><span class="line"># 根据情况来切换</span><br><span class="line">replace-with = <span class="symbol">&#x27;ustc</span>&#x27;</span><br><span class="line"># 清华大学</span><br><span class="line">[source.tuna]</span><br><span class="line">registry = <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;</span></span><br><span class="line"></span><br><span class="line"># 中国科学技术大学</span><br><span class="line">[source.ustc]</span><br><span class="line">registry = <span class="string">&quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span></span><br><span class="line"></span><br><span class="line"># 上海交通大学</span><br><span class="line">[source.sjtu]</span><br><span class="line">registry = <span class="string">&quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;</span></span><br><span class="line"></span><br><span class="line"># rustcc社区</span><br><span class="line">[source.rustcc]</span><br><span class="line">registry = <span class="string">&quot;git://crates.rustcc.cn/crates.io-index&quot;</span></span><br><span class="line"></span><br><span class="line"># 字节跳动</span><br><span class="line">[source.rsproxy]</span><br><span class="line">registry = <span class="string">&quot;https://rsproxy.cn/crates.io-index&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习下Rust&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么学习Rust&quot;&gt;&lt;a href=&quot;#为什么学习Rust&quot; class=&quot;headerlink&quot; title=&quot;为什么学习Rust&quot;&gt;&lt;/a&gt;为什么学习Rust&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在知乎上看到一个人对Rust的评论。&lt;/p&gt;
&lt;p&gt;首先，Rust 是有点反人类，否则不会一直都不火。然后，Rust 之所以反人类，是因为人类这玩意既愚蠢，又自大，破事还贼多。 你看 C++ 就很相信人类，它要求人类自己把自己 new 出来的东西给 delete 掉。 C++：“这点小事我相信你可以的！” 人类：“没问题！包在我身上！” 然后呢，内存泄漏、double free、野指针满世界飘…… C++：“……”&lt;/p&gt;
&lt;p&gt;Java 选择不相信人类，但替人类把事办好。 Java：“别动，让我来，我有gc！” 人类：“你怎么做事这么慢呀？你怎么还 stop the world 了呀？你是不是不爱我了呀？” Java：“……”&lt;/p&gt;
&lt;p&gt;Rust 发现唯一的办法就是既不相信人类，也不惯着人类。 Rust：“按老子说的做，不做就不编译！” 人类：“你反人类！” Rust：“滚！”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;C&amp;#x2F;C++ 完全相信而且惯着程序员，让大家自行管理内存，所以可以编写很自由的代码，但一个不小心就会造成内存泄漏等问题导致程序崩溃。&lt;/li&gt;
&lt;li&gt;Java&amp;#x2F;Golang 完全不相信程序员，但也惯着程序员。所有的内存生命周期都由 JVM 运行时统一管理。 在绝大部分场景下，你可以非常自由的写代码，而且不用关心内存到底是什么情况。 内存使用有问题的时候，我们可以通过 JVM 来信息相关的分析诊断和调整。&lt;/li&gt;
&lt;li&gt;Rust 语言选择既不相信程序员，也不惯着程序员。 让你在写代码的时候，必须清楚明白的用 Rust 的规则管理好你的变量，好让机器能明白高效地分析和管理内存。 但是这样会导致代码不利于人的理解，写代码很不自由，学习成本也很高。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://z201.cn/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://z201.cn/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>EnterpriseArchitecture-Distributed-System</title>
    <link href="https://z201.cn/posts/1077437200/"/>
    <id>https://z201.cn/posts/1077437200/</id>
    <published>2021-11-04T07:15:58.000Z</published>
    <updated>2024-01-06T10:55:21.989Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><blockquote><p>开发了几年的分布式系统，对其原理模模糊糊。大量的时间在研究场景下解决方案。并未深入总结过。本文梳理个人对分布式的认知理解。</p></blockquote><ul><li><p>在没有系统学习分布式相关知识的情况，通常选择针对局部场景需求进行认知下<code>局部最优解决</code>。处理问题也没有十足的把握，在系统稳定性上只能通过case by case的方式处理。</p></li><li><p>解决单机性能瓶颈。</p></li><li><p>解决数据增加运维成本。</p></li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20220219110005.png"></p><span id="more"></span><h3 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h3><ul><li>CAP</li><li>BASE</li><li>ACID</li></ul><h3 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h3><h4 id="网络异步"><a href="#网络异步" class="headerlink" title="网络异步"></a>网络异步</h4><ul><li><p>本地调用</p></li><li><p>远程调用</p><ul><li><p>请求超时机制</p></li><li><p>响应超时机制</p></li><li><p>幂等性</p></li><li><p>重试机制</p></li></ul></li></ul><h4 id="无状态服务"><a href="#无状态服务" class="headerlink" title="无状态服务"></a>无状态服务</h4><ul><li>协同工作<ul><li>分布式锁</li><li>系统时钟<ul><li>墙上时钟</li><li>系统时钟 &#x3D; 本地时间 &#x3D; 时间服务器的返回时间 + 时间服务器响应的网络时延</li></ul></li></ul></li></ul><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><ul><li>轮询</li><li>权重</li><li>Hash</li><li>一致性Hash</li><li>FAIR</li></ul><h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h4><ul><li>统一配置文件</li><li>降低运营出错率</li></ul><h4 id="系统雪崩"><a href="#系统雪崩" class="headerlink" title="系统雪崩"></a>系统雪崩</h4><ul><li>快速失败<ul><li>熔断机制</li></ul></li><li>降级机制<ul><li>限流</li></ul></li><li>弹性扩容 增加系统服务能力<ul><li>Docker </li><li>k8s</li></ul></li></ul><h4 id="可观测性"><a href="#可观测性" class="headerlink" title="可观测性"></a>可观测性</h4><ul><li>分布式系统监控</li><li>分布式追踪Trace</li><li>异常告警机制</li><li>运行指标可视化</li></ul><h4 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h4><ul><li>混沌工程</li></ul><h3 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h3><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><ul><li>并发事务排序</li><li>分布式主键</li></ul><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><ul><li>Mysql</li><li>Redis</li><li>Zookeeper</li><li>Etcd</li></ul><h4 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h4><ul><li>Hash </li><li>Region</li></ul><h4 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h4><ul><li>主重复制</li><li>一致性协议<ul><li>Raft</li><li>Paxos</li></ul></li><li>去中心<ul><li>Quorum</li><li>Vector Clock</li></ul></li><li>一致性级别<ul><li>线性一致性</li><li>顺序一致性</li><li>最终一致性</li></ul></li></ul><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><ul><li>分布式文件存储<ul><li>HDFS</li><li>GFS</li></ul></li><li>分布式消息列队<ul><li>Kafka</li><li>Pulsar</li><li>RocketMq</li></ul></li><li>分布式缓存<ul><li>Redis Cluster</li></ul></li><li>Sql<ul><li>Mysql</li><li>Sharing机制</li></ul></li><li>NoSql<ul><li>Redis</li></ul></li><li>NewSql<ul><li>TiDB</li></ul></li></ul><h4 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h4><ul><li>OLTP 联机事务处理<ul><li>对数据进行增删改查，SQL 查询优化，事务处理等就属于 OLTP 的范畴。它对实时性要求高，需要将用户的数据有效地存储到数据库中，同时有时候针对互联网应用的需求。需要设置数据库的主从架构保证数据库的高并发和高可用性。</li></ul></li><li>OLAP 联机分析处理<ul><li>对已经存储在数据库中的数据进行分析，帮我们得出报表，指导业务。它对数据的实时性要求不高，但数据量往往很大，存储在数据库（数据仓库）中的数据可能还存在数据质量的问题，比如数据重复、数据中有缺失值，或者单位不统一等，因此在进行数据分析之前，首要任务就是对收集的数据进行清洗，从而保证数据质量。</li></ul></li></ul><h3 id="分布式监控"><a href="#分布式监控" class="headerlink" title="分布式监控"></a>分布式监控</h3><blockquote><p>监控系统在分布式场景下是非常重要切容易被忽视的一个环节，正确运用，它在故障事发前进行告警、在故障期间定位问题、在故障事后复盘。</p></blockquote><h4 id="监控的模式"><a href="#监控的模式" class="headerlink" title="监控的模式"></a>监控的模式</h4><blockquote><p>监控贯穿了应用系统整个生命周期，可以归纳为系统、业务、数据三大监控板块。</p></blockquote><h5 id="业务监控"><a href="#业务监控" class="headerlink" title="业务监控"></a>业务监控</h5><ul><li>定义业务指标。通过对业务进行埋点、数据统计的方式对业务情况反馈，比如ORI场景计算等等。</li></ul><h5 id="应用监控"><a href="#应用监控" class="headerlink" title="应用监控"></a>应用监控</h5><ul><li>通过第三方探针或者内省的方式，将应用当前的运行特征暴露出来。比如通过端口等方式暴露运营信息比如SpringBoot Actuaotr 对应用运行特征暴露。Skywalking 通过探针对应用之间的链路处理过程进行暴露。</li></ul><h5 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h5><ul><li>对物理主机、容器系统层面进行监控，比如CPU利用率、内存利用率、硬盘使用等等操作系统。</li></ul><h5 id="监控的方式"><a href="#监控的方式" class="headerlink" title="监控的方式"></a>监控的方式</h5><ul><li>健康检查监控<ul><li>对应用、中间件本身进行监控，比如心跳、运行特征状态等等。</li></ul></li><li>日志监控<ul><li>对应用、中间件日志进行监控，通过异常日志等信息告警或者其他处理。ELK相关解决方案。</li></ul></li><li>调用链监控<ul><li>应用、中间件之间存在调用、被调用的场景，对业务执行的时间、调用应用、中间件等信息进行记录。便于系统优化、故障排查等。Skywalking APM相关产品解决方案。</li></ul></li><li>指标监控<ul><li>建立不同的指标体系，对应用、中间件、操作系统运行信息聚合计算后，反应出一些重要的指标趋势。Prometheus、时序数据库等相关组合配合。</li></ul></li></ul><h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><h4 id="分布式架构演变"><a href="#分布式架构演变" class="headerlink" title="分布式架构演变"></a>分布式架构演变</h4>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;分布式系统&quot;&gt;&lt;a href=&quot;#分布式系统&quot; class=&quot;headerlink&quot; title=&quot;分布式系统&quot;&gt;&lt;/a&gt;分布式系统&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;开发了几年的分布式系统，对其原理模模糊糊。大量的时间在研究场景下解决方案。并未深入总结过。本文梳理个人对分布式的认知理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在没有系统学习分布式相关知识的情况，通常选择针对局部场景需求进行认知下&lt;code&gt;局部最优解决&lt;/code&gt;。处理问题也没有十足的把握，在系统稳定性上只能通过case by case的方式处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解决单机性能瓶颈。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解决数据增加运维成本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20220219110005.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="EnterpriseArchitecture" scheme="https://z201.cn/categories/EnterpriseArchitecture/"/>
    
    
    <category term="Programmatic" scheme="https://z201.cn/tags/Programmatic/"/>
    
    <category term="EnterpriseArchitecture" scheme="https://z201.cn/tags/EnterpriseArchitecture/"/>
    
  </entry>
  
  <entry>
    <title>Programmatic-Permission-Design</title>
    <link href="https://z201.cn/posts/1449986837/"/>
    <id>https://z201.cn/posts/1449986837/</id>
    <published>2021-09-20T13:38:35.000Z</published>
    <updated>2024-01-06T10:01:55.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>权限管理是一个几乎所有大中型 B 端系统都会涉及的重要组成部分，其目的是对整个系统进行权限控制，避免造成误操作及数据泄露等风险问题。</p></blockquote><h2 id="权限与权限管理"><a href="#权限与权限管理" class="headerlink" title="权限与权限管理"></a>权限与权限管理</h2><h3 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h3><blockquote><p>权限相关的基本概念：</p></blockquote><ul><li>权限：用户可操作行为的最小单位。</li><li>用户：每个用户都有唯一标识，并被授予一个或多个角色。</li><li>角色：由不同的权限组合而成，最终分配给具体用户。</li><li>权限管理：控制用户的权限，只能访问授权内容。</li></ul><h3 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h3><ul><li>ACL（Access Control List）：基于用户级别的权限控制。<ul><li>将系统的各种权限直接授予具体的用户。抽象来说，为每个用户维护了单独的权限列表，当需要分配权限、收回权限时，需要修改对应用户的权限信息。</li></ul></li><li>RBAC（Role Base Access Control）：基于角色级别的权限控制。<ul><li>与 ACL 对比，RBAC不用给用户单个分配权限，权限与用户之前通过角色关联。通过给不同的角色分配不同的权限，只需要将用户指向对应的角色就会有对应的权限。分配权限、收回权限只需要通过修改用户的角色即可。</li></ul></li><li>ABAC（Attribute Base Access Control）：基于属性级别的权限控制。<ul><li>不同于常见的将用户通过某种方式直接关联到权限的方式，ABAC 是通过动态计算一个或一组属性来是否满足某种条件来进行权限判断。属性一般分为四类：用户属性（自然人属性，如年龄、性别等），环境属性（物理环境，如时间、地点、气候），操作属性（读、写）和对象属性（操作对象，如资金、某张图片、某个特定的页面，又称资源属性）。</li></ul></li><li>因此理论上能够实现灵活的权限控制、将在权限与用户之前通过一组或多组属性实现关联，几乎能满足所有类型的需求。</li></ul><h3 id="权限管控"><a href="#权限管控" class="headerlink" title="权限管控"></a>权限管控</h3><blockquote><p>抽象来看权限体系可以分为如下两类：功能权限 与 数据权限 两部分。</p></blockquote><ul><li>功能权限指的是在系统中的功能可否使用，通常我们将功能权限分为查看、编辑、删除等，同时编辑、删除权限又包含了查看。通过小的权限点拆分更精细的赋予了员工能否进入某个页面查看信息、编辑信息的能力。</li><li>数据权限指数据中存在的数据是否能查看，是一个更细粒度的权限。比如一个页面，不同角色查看不同的数据就需要通过数据权限控制。<br>从管理对象维度又可以分为：企业能力 与 员工能力。</li><li>企业能力店铺维度的权限，比如开通某服务，可以通过企业能力去体现。</li><li>企业能力赋予用户的权限，比如收电子发票、资金管理等。</li><li>企业能力优先级绝对高于员工能力，所有场景的权限判断，店铺能力必须先于员工能力。简单地说，企业能力决定了“企业能做什么”，员工能力决定了“用户能做什么”。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;权限管理是一个几乎所有大中型 B 端系统都会涉及的重要组成部分，其目的是对整个系统进行权限控制，避免造成误操作及数</summary>
      
    
    
    
    <category term="Programmatic" scheme="https://z201.cn/categories/Programmatic/"/>
    
    
    <category term="Programmatic" scheme="https://z201.cn/tags/Programmatic/"/>
    
    <category term="EnterpriseArchitecture" scheme="https://z201.cn/tags/EnterpriseArchitecture/"/>
    
  </entry>
  
  <entry>
    <title>Java-Jvm-Optimization</title>
    <link href="https://z201.cn/posts/3325845222/"/>
    <id>https://z201.cn/posts/3325845222/</id>
    <published>2021-08-19T06:09:45.000Z</published>
    <updated>2024-01-06T10:35:30.021Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jvm调优是日常工作中经常会使用的技巧，整理下。</p></blockquote><h3 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h3><blockquote><p>为什么要调优，当默认配置参数不能很好的发挥程序性能的时候。</p></blockquote><ul><li>Heap内存（老年代）持续上涨达到设置的最大内存值。</li><li>Full GC 次数频繁。</li><li>GC 停顿时间过长（超过1秒）。</li><li>应用出现OutOfMemory 等内存异常。</li><li>应用中有使用本地缓存且占用大量内存空间。</li><li>系统吞吐量与响应性能不高或下降。</li></ul><h3 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a>常用方式</h3><ul><li>上线之前，应先考虑将机器的JVM参数设置到最优。（启动参数）</li><li>大多数导致GC问题的原因是代码层面的问题导致的（代码层面）。</li><li>减少创建对象的数量（代码层面）。</li><li>减少使用全局变量和大对象（代码层面）。</li><li>优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）。</li><li>分析GC情况优化代码比优化JVM参数更好（代码层面）。</li></ul><h4 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h4><blockquote><p>调优的最终目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。jvm调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量。</p><ul><li>延迟：GC低停顿和GC低频率。</li><li>低内存占用。</li><li>高吞吐量。</li><li>堆内存 &#x3D; Old + Eden + S0 + S1 </li><li>年轻的 &#x3D; Eden（新生代） + S0 + S1 </li><li>标准参数（-），所有JVM都必须支持这些参数的功能，而且向后兼容</li><li>非标准参数（-X），默认JVM实现这些参数的功能，但是并不保证所有JVM实现都满足，且不保证向后兼容。</li><li>非稳定参数（-XX），此类参数各个JVM实现会有所不同，将来可能会不被支持，需要慎重使用。</li></ul></blockquote><ul><li>Heap 内存使用率 &lt;&#x3D; 70%;</li><li>Old generation内存使用率&lt;&#x3D; 70%;</li><li>avgpause &lt;&#x3D; 1秒;</li><li>Full gc 次数0 或 avg pause interval &gt;&#x3D; 24小时 ;</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure><ul><li>简单介绍下参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=128m （元空间默认大小）</span><br><span class="line">-XX:MaxMetaspaceSize=128m （元空间最大大小）</span><br><span class="line">-Xms1024m （堆最大大小）</span><br><span class="line">-Xmx1024m （堆默认大小）</span><br><span class="line">-Xmn256m （新生代大小）</span><br><span class="line">-Xss256k （棧最大深度大小）</span><br><span class="line">-XX:SurvivorRatio=8 （新生代分区比例 8:2）</span><br><span class="line">-XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器）</span><br><span class="line">-XX:+PrintGCDetails （打印详细的GC日志）</span><br></pre></td></tr></table></figure><ul><li>虽然有了介绍但是依然不清楚具体是干啥的。并且Java虚拟机提供了非常多的参数命令。下面代码可以输出支持的参数数量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -XX:+UnlockDiagnosticVMOptions -version | wc -l</span><br><span class="line">openjdk version <span class="string">&quot;1.8.0_275&quot;</span></span><br><span class="line">OpenJDK Runtime <span class="title function_">Environment</span> <span class="params">(AdoptOpenJDK)</span><span class="params">(build <span class="number">1.8</span><span class="number">.0_275</span>-b01)</span></span><br><span class="line">OpenJDK <span class="number">64</span>-Bit Server <span class="title function_">VM</span> <span class="params">(AdoptOpenJDK)</span><span class="params">(build <span class="number">25.275</span>-b01, mixed mode)</span></span><br><span class="line">     <span class="number">838</span></span><br></pre></td></tr></table></figure><ul><li>堆内存大小配置</li></ul><blockquote><p>建议 -Xms &#x3D; 最大内存 * [0.6. ~0.8] 这里需要考虑系统损耗内存、和实际物理内存。</p></blockquote><ul><li><p>堆内存与堆外内存</p><ul><li>堆内存</li></ul><blockquote><p>必须是1024的倍数，且不能低于2M。</p><p>32位机器，最大1G&#x2F;4G 64位机器最大可以超过 32G&#x2F;64G</p></blockquote><ul><li>堆外内存</li></ul><blockquote><p>堆外内存一般指 Direct Memory ，不受GC控制，JVM、Netty都可能使用堆外内存。</p></blockquote></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxDirectMemorySize 限制</span><br></pre></td></tr></table></figure><h5 id="如何理解这些参数的含义？"><a href="#如何理解这些参数的含义？" class="headerlink" title="如何理解这些参数的含义？"></a>如何理解这些参数的含义？</h5><blockquote><p>首先我们需要理解java是如何运行的，为什么需要java虚拟机？</p><p>我们常用方式一般是安装java运行环境(jre)用命令行的方式启动或者直接双击jar运行。jre包含的java运行的必要环境。</p><p>Java 作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。编译出来的也不是机器可以直接直接运行代码。所以使用面向Java语言的虚拟机运行Java编译以后的特定代码。这里的特定代码指的是Java字节指令码。</p></blockquote><h5 id="JVM-内存分配性能问题"><a href="#JVM-内存分配性能问题" class="headerlink" title="JVM 内存分配性能问题"></a>JVM 内存分配性能问题</h5><ul><li>在应用服务的特定场景下，JVM 内存分配不合理带来的性能表现并不会像内存溢出问题这么突出。如果没有深入到各项性能指标中去，是很难发现其中隐藏的性能损耗。</li><li>JVM 内存分配不合理最直接的表现就是频繁的 GC，这会导致上下文切换等性能问题，从而降低系统的吞吐量、增加系统的响应时间。</li></ul><h3 id="分析-GC-日志"><a href="#分析-GC-日志" class="headerlink" title="分析 GC 日志"></a>分析 GC 日志</h3><ul><li>在进行压测的时候，我们需要对GC日志进行分析。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/log/heap.log</span><br></pre></td></tr></table></figure><ul><li>-XX:PrintGCTimeStamps：打印 GC 具体时间；</li><li>-XX:PrintGCDetails ：打印出 GC 详细日志；</li><li>-Xloggc: path：GC 日志生成路径。</li><li>JVM 内存调优通常和 GC 调优是互补的，基于以上调优，可以对年轻代和堆内存的垃圾回收算法进行调优。</li></ul><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;jvm调优是日常工作中经常会使用的技巧，整理下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;JVM调优&quot;&gt;&lt;a href=&quot;#JVM调优&quot; class=&quot;headerlink&quot; title=&quot;JVM调优&quot;&gt;&lt;/a&gt;JVM调优&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;为什么要调优，当默认配置参数不能很好的发挥程序性能的时候。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Heap内存（老年代）持续上涨达到设置的最大内存值。&lt;/li&gt;
&lt;li&gt;Full GC 次数频繁。&lt;/li&gt;
&lt;li&gt;GC 停顿时间过长（超过1秒）。&lt;/li&gt;
&lt;li&gt;应用出现OutOfMemory 等内存异常。&lt;/li&gt;
&lt;li&gt;应用中有使用本地缓存且占用大量内存空间。&lt;/li&gt;
&lt;li&gt;系统吞吐量与响应性能不高或下降。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;常用方式&quot;&gt;&lt;a href=&quot;#常用方式&quot; class=&quot;headerlink&quot; title=&quot;常用方式&quot;&gt;&lt;/a&gt;常用方式&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;上线之前，应先考虑将机器的JVM参数设置到最优。（启动参数）&lt;/li&gt;
&lt;li&gt;大多数导致GC问题的原因是代码层面的问题导致的（代码层面）。&lt;/li&gt;
&lt;li&gt;减少创建对象的数量（代码层面）。&lt;/li&gt;
&lt;li&gt;减少使用全局变量和大对象（代码层面）。&lt;/li&gt;
&lt;li&gt;优先架构调优和代码调优，JVM优化是不得已的手段（代码、架构层面）。&lt;/li&gt;
&lt;li&gt;分析GC情况优化代码比优化JVM参数更好（代码层面）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;启动参数&quot;&gt;&lt;a href=&quot;#启动参数&quot; class=&quot;headerlink&quot; title=&quot;启动参数&quot;&gt;&lt;/a&gt;启动参数&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;调优的最终目的都是为了令应用程序使用最小的硬件消耗来承载更大的吞吐。jvm调优主要是针对垃圾收集器的收集性能优化，令运行在虚拟机上的应用能够使用更少的内存以及延迟获取更大的吞吐量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;延迟：GC低停顿和GC低频率。&lt;/li&gt;
&lt;li&gt;低内存占用。&lt;/li&gt;
&lt;li&gt;高吞吐量。&lt;/li&gt;
&lt;li&gt;堆内存 &amp;#x3D; Old + Eden + S0 + S1 &lt;/li&gt;
&lt;li&gt;年轻的 &amp;#x3D; Eden（新生代） + S0 + S1 &lt;/li&gt;
&lt;li&gt;标准参数（-），所有JVM都必须支持这些参数的功能，而且向后兼容&lt;/li&gt;
&lt;li&gt;非标准参数（-X），默认JVM实现这些参数的功能，但是并不保证所有JVM实现都满足，且不保证向后兼容。&lt;/li&gt;
&lt;li&gt;非稳定参数（-XX），此类参数各个JVM实现会有所不同，将来可能会不被支持，需要慎重使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Heap 内存使用率 &amp;lt;&amp;#x3D; 70%;&lt;/li&gt;
&lt;li&gt;Old generation内存使用率&amp;lt;&amp;#x3D; 70%;&lt;/li&gt;
&lt;li&gt;avgpause &amp;lt;&amp;#x3D; 1秒;&lt;/li&gt;
&lt;li&gt;Full gc 次数0 或 avg pause interval &amp;gt;&amp;#x3D; 24小时 ;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;简单介绍下参数&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-XX:MetaspaceSize=128m （元空间默认大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-XX:MaxMetaspaceSize=128m （元空间最大大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-Xms1024m （堆最大大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-Xmx1024m （堆默认大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-Xmn256m （新生代大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-Xss256k （棧最大深度大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-XX:SurvivorRatio=8 （新生代分区比例 8:2）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-XX:+PrintGCDetails （打印详细的GC日志）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;虽然有了介绍但是依然不清楚具体是干啥的。并且Java虚拟机提供了非常多的参数命令。下面代码可以输出支持的参数数量&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java -XX:+PrintFlagsFinal -XX:+UnlockDiagnosticVMOptions -version | wc -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;openjdk version &lt;span class=&quot;string&quot;&gt;&amp;quot;1.8.0_275&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OpenJDK Runtime &lt;span class=&quot;title function_&quot;&gt;Environment&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(AdoptOpenJDK)&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(build &lt;span class=&quot;number&quot;&gt;1.8&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0_275&lt;/span&gt;-b01)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OpenJDK &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;-Bit Server &lt;span class=&quot;title function_&quot;&gt;VM&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(AdoptOpenJDK)&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(build &lt;span class=&quot;number&quot;&gt;25.275&lt;/span&gt;-b01, mixed mode)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;number&quot;&gt;838&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;堆内存大小配置&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;建议 -Xms &amp;#x3D; 最大内存 * [0.6. ~0.8] 这里需要考虑系统损耗内存、和实际物理内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;堆内存与堆外内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆内存&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;必须是1024的倍数，且不能低于2M。&lt;/p&gt;
&lt;p&gt;32位机器，最大1G&amp;#x2F;4G 64位机器最大可以超过 32G&amp;#x2F;64G&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;堆外内存&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;堆外内存一般指 Direct Memory ，不受GC控制，JVM、Netty都可能使用堆外内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-XX:MaxDirectMemorySize 限制&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h5 id=&quot;如何理解这些参数的含义？&quot;&gt;&lt;a href=&quot;#如何理解这些参数的含义？&quot; class=&quot;headerlink&quot; title=&quot;如何理解这些参数的含义？&quot;&gt;&lt;/a&gt;如何理解这些参数的含义？&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;首先我们需要理解java是如何运行的，为什么需要java虚拟机？	&lt;/p&gt;
&lt;p&gt;我们常用方式一般是安装java运行环境(jre)用命令行的方式启动或者直接双击jar运行。jre包含的java运行的必要环境。&lt;/p&gt;
&lt;p&gt;Java 作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。编译出来的也不是机器可以直接直接运行代码。所以使用面向Java语言的虚拟机运行Java编译以后的特定代码。这里的特定代码指的是Java字节指令码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;JVM-内存分配性能问题&quot;&gt;&lt;a href=&quot;#JVM-内存分配性能问题&quot; class=&quot;headerlink&quot; title=&quot;JVM 内存分配性能问题&quot;&gt;&lt;/a&gt;JVM 内存分配性能问题&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;在应用服务的特定场景下，JVM 内存分配不合理带来的性能表现并不会像内存溢出问题这么突出。如果没有深入到各项性能指标中去，是很难发现其中隐藏的性能损耗。&lt;/li&gt;
&lt;li&gt;JVM 内存分配不合理最直接的表现就是频繁的 GC，这会导致上下文切换等性能问题，从而降低系统的吞吐量、增加系统的响应时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;分析-GC-日志&quot;&gt;&lt;a href=&quot;#分析-GC-日志&quot; class=&quot;headerlink&quot; title=&quot;分析 GC 日志&quot;&gt;&lt;/a&gt;分析 GC 日志&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在进行压测的时候，我们需要对GC日志进行分析。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/log/heap.log&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;-XX:PrintGCTimeStamps：打印 GC 具体时间；&lt;/li&gt;
&lt;li&gt;-XX:PrintGCDetails ：打印出 GC 详细日志；&lt;/li&gt;
&lt;li&gt;-Xloggc: path：GC 日志生成路径。&lt;/li&gt;
&lt;li&gt;JVM 内存调优通常和 GC 调优是互补的，基于以上调优，可以对年轻代和堆内存的垃圾回收算法进行调优。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java" scheme="https://z201.cn/categories/Java/"/>
    
    
    <category term="Java" scheme="https://z201.cn/tags/Java/"/>
    
    <category term="Jvm" scheme="https://z201.cn/tags/Jvm/"/>
    
  </entry>
  
</feed>
