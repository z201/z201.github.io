<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫叶的小博客</title>
  
  <subtitle>先完成、在完美。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://z201.cn/"/>
  <updated>2021-12-20T15:43:47.748Z</updated>
  <id>https://z201.cn/</id>
  
  <author>
    <name>胖枫叶</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust基础语法</title>
    <link href="https://z201.cn/2021/11/25/Rust%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://z201.cn/2021/11/25/Rust%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2021-11-25T14:49:11.000Z</published>
    <updated>2021-12-20T15:43:47.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Rust基础语法"><a href="#Rust基础语法" class="headerlink" title="Rust基础语法"></a>Rust基础语法</h2><blockquote><p>Rust 是一种静态类型的语言。 Rust 中的每个值都是某种数据类型。 编译器可以根据分配给它的值自动推断变量的数据类型。</p></blockquote><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><blockquote><p>使用let关键字声明变量</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    println!(&quot;Rust基础语法!&quot;);</span><br><span class="line">    let str_ &#x3D; &quot;String&quot;; &#x2F;&#x2F; string 类型</span><br><span class="line">    let f_ &#x3D; 1.1; &#x2F;&#x2F; float 类型</span><br><span class="line">    let bool_ &#x3D; true; &#x2F;&#x2F; boolean 类型</span><br><span class="line">    let char_ &#x3D; &#39;a&#39;; &#x2F;&#x2F; unicode character </span><br><span class="line">    println!(&quot;string &#123;&#125;&quot;,str_); </span><br><span class="line">    println!(&quot;float &#123;&#125;&quot;,f_); </span><br><span class="line">    println!(&quot;boolean &#123;&#125;&quot;,bool_); </span><br><span class="line">    println!(&quot;icon &#123;&#125;&quot;,char_); </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rust基础语法!</span><br><span class="line">string String</span><br><span class="line"><span class="built_in">float</span> 1.1</span><br><span class="line">boolean <span class="literal">true</span></span><br><span class="line">icon a</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="println"><a href="#println" class="headerlink" title="println!"></a>println!</h3><blockquote><p>打印控制台方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#[macro_export]</span><br><span class="line">#[stable(feature &#x3D; &quot;rust1&quot;, since &#x3D; &quot;1.0.0&quot;)]</span><br><span class="line">#[allow_internal_unstable(print_internals, format_args_nl)]</span><br><span class="line">macro_rules! println &#123;</span><br><span class="line">    () &#x3D;&gt; ($crate::print!(&quot;\n&quot;));</span><br><span class="line">    ($($arg:tt)*) &#x3D;&gt; (&#123;</span><br><span class="line">        $crate::io::_print($crate::format_args_nl!($($arg)*));</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个参数是占位符 *{ }*，特别的语法</li><li>一个参数是变量或者常量</li></ul><h3 id="scalar-Types"><a href="#scalar-Types" class="headerlink" title="scalar Types"></a>scalar Types</h3><blockquote><p>Rust有四种标量类型 整型、浮点型、布尔型、字符型</p></blockquote><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><blockquote><p>整型是指没有小数部分的数字。也就是说，整型是用于表示整数的。整型可以进一步分为有符号（Signed）与无符号（Unsigned）的。可以存储正负值。</p></blockquote><table><thead><tr><th></th><th>大小</th><th>有符号Signed</th><th>无符号Unsigned</th></tr></thead><tbody><tr><td></td><td>8bit</td><td>i8</td><td>u8</td></tr><tr><td></td><td>16bit</td><td>i16</td><td>u16</td></tr><tr><td></td><td>32bit</td><td>i32</td><td>u32</td></tr><tr><td></td><td>64bit</td><td>i64</td><td>u64</td></tr><tr><td></td><td>128bit</td><td>i128</td><td>u128</td></tr><tr><td></td><td>arch</td><td>issize</td><td>Size</td></tr></tbody></table><h5 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let result &#x3D; 1;    &#x2F;&#x2F; 默认类型为i32</span><br><span class="line">let u20:u32 &#x3D; 20;</span><br><span class="line">let i32:i32 &#x3D; -15;</span><br><span class="line">let s:isize &#x3D; 10;</span><br><span class="line">let count:usize &#x3D; 30;</span><br><span class="line">println!(&quot;result value is &#123;&#125;&quot;,result);</span><br><span class="line">println!(&quot;u20 is &#123;&#125; i32 is &#123;&#125;&quot;,u20,i32);</span><br><span class="line">println!(&quot;mark is &#123;&#125; and count is &#123;&#125;&quot;,s,count);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result value is 1</span><br><span class="line">u20 is 20 i32 is -15</span><br><span class="line">mark is 10 and count is 30</span><br></pre></td></tr></table></figure><h4 id="整型溢出"><a href="#整型溢出" class="headerlink" title="整型溢出"></a>整型溢出</h4><blockquote><p>当分配给整型变量的值超出该整型在 Rust 中定义值的范围时，就会发生整型溢出</p></blockquote><h5 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let u1:u8 &#x3D; 255;</span><br><span class="line">&#x2F;&#x2F; u8数据范围为0~255</span><br><span class="line">let u2:u8 &#x3D; 256;   &#x2F;&#x2F;溢出值为 1</span><br><span class="line">let u3:u8 &#x3D; 257;   &#x2F;&#x2F;溢出值为 2</span><br><span class="line">let u4:u8 &#x3D; 258;    &#x2F;&#x2F;溢出值为 3</span><br><span class="line"></span><br><span class="line">println!(&quot;1 is &#123;&#125; &quot;,u1);</span><br><span class="line">println!(&quot;2 is &#123;&#125;&quot;,u2);</span><br><span class="line">println!(&quot;3 is &#123;&#125;&quot;,u3);</span><br><span class="line">println!(&quot;4 is &#123;&#125;&quot;,u4);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">error: literal out of range <span class="keyword">for</span> `u8`</span><br><span class="line">  --&gt; src/main.rs:24:16</span><br><span class="line">   |</span><br><span class="line">24 |    <span class="built_in">let</span> u2:u8 = 256;   //溢出值为 1</span><br><span class="line">   |                ^^^</span><br><span class="line">   |</span><br><span class="line">   = note: `<span class="comment">#[deny(overflowing_literals)]` on by default</span></span><br><span class="line">   = note: the literal `256` does not fit into the <span class="built_in">type</span> `u8` whose range is `0..=255`</span><br><span class="line"></span><br><span class="line">error: literal out of range <span class="keyword">for</span> `u8`</span><br><span class="line">  --&gt; src/main.rs:25:16</span><br><span class="line">   |</span><br><span class="line">25 |    <span class="built_in">let</span> u3:u8 = 257;   //溢出值为 2</span><br><span class="line">   |                ^^^</span><br><span class="line">   |</span><br><span class="line">   = note: the literal `257` does not fit into the <span class="built_in">type</span> `u8` whose range is `0..=255`</span><br><span class="line"></span><br><span class="line">error: literal out of range <span class="keyword">for</span> `u8`</span><br><span class="line">  --&gt; src/main.rs:26:16</span><br><span class="line">   |</span><br><span class="line">26 |    <span class="built_in">let</span> u4:u8 = 258;    //溢出值为 3</span><br><span class="line">   |                ^^^</span><br><span class="line">   |</span><br><span class="line">   = note: the literal `258` does not fit into the <span class="built_in">type</span> `u8` whose range is `0..=255`</span><br><span class="line"></span><br><span class="line">error: could not compile `learning-02` due to 3 previous errors</span><br></pre></td></tr></table></figure><ul><li>Rust的提示非常棒</li></ul><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><blockquote><p>Rust 中的浮点型可被分为 <strong>f32</strong> 和 <strong>f64</strong>。f32 是单精度浮点型，f64 是双精度浮点型。默认浮点型为 f64。</p></blockquote><h5 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let f1 &#x3D; 10.00;        &#x2F;&#x2F;默认为 f64 浮点型</span><br><span class="line">let f2:f32 &#x3D; 8.35;</span><br><span class="line">let f3:f64 &#x3D; 15000.600;  &#x2F;&#x2F;双精度浮点型</span><br><span class="line"></span><br><span class="line">println!(&quot;f1 value is &#123;&#125;&quot;,f1);</span><br><span class="line">println!(&quot;f2 is &#123;&#125;&quot;,f2);</span><br><span class="line">println!(&quot;f3 is &#123;&#125;&quot;,f3);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1 value is 10</span><br><span class="line">f2 is 8.35</span><br><span class="line">f3 is 15000.6</span><br></pre></td></tr></table></figure><h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><blockquote><p>Rust 中不支持自动类型转换</p></blockquote><h5 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let interest:f32 &#x3D; 8;   &#x2F;&#x2F; 浮点型变量被赋予整型值</span><br><span class="line">println!(&quot;interest is &#123;&#125;&quot;,interest);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: mismatched types</span><br><span class="line">  --&gt; src&#x2F;main.rs:41:23</span><br><span class="line">   |</span><br><span class="line">41 |    let interest:f32 &#x3D; 8;   &#x2F;&#x2F; 浮点型变量被赋予整型值</span><br><span class="line">   |                 ---   ^</span><br><span class="line">   |                 |     |</span><br><span class="line">   |                 |     expected &#96;f32&#96;, found integer</span><br><span class="line">   |                 |     help: use a float literal: &#96;8.0&#96;</span><br><span class="line">   |                 expected due to this</span><br></pre></td></tr></table></figure><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><blockquote><p>布尔型有两种可能的值 ——<em>true</em> 或是 <em>false</em>。使用 <strong>bool</strong> 关键字可以声明布尔型变量。</p></blockquote><h5 id="案例-4"><a href="#案例-4" class="headerlink" title="案例"></a>案例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let b:bool &#x3D; true;</span><br><span class="line">println!(&quot;boolean &#123;&#125;&quot;,b);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean true</span><br></pre></td></tr></table></figure><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><blockquote><p>Rust 中的字符型支持数字，字母，Unicode 和特殊字符。使用 char 关键字可以声明字符型变量。Rust 中的字符型用 Unicode 标量值储存，即 Rust 中的字符型可以表示比 ASCII 更多的字符。Unicode 标量值的范围包括从 U+0000 到 U+D7FF 和从 U+E000 到 U+10FFFF。</p></blockquote><h5 id="案例-5"><a href="#案例-5" class="headerlink" title="案例"></a>案例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let def_c &#x3D; &#39;@&#39;; &#x2F;&#x2F;默认为字符型</span><br><span class="line">let c:char &#x3D; &#39;Z&#39;;</span><br><span class="line">let emoji:char &#x3D; &#39;😁&#39;;</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">character is @</span><br><span class="line">alphabet is Z</span><br><span class="line">emoji is 😁</span><br></pre></td></tr></table></figure><h5 id="类型转字符串"><a href="#类型转字符串" class="headerlink" title="类型转字符串"></a>类型转字符串</h5><blockquote><p>to_String()</p></blockquote><h6 id="案例-6"><a href="#案例-6" class="headerlink" title="案例"></a>案例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let x: u32 &#x3D; 10;</span><br><span class="line">  let s: String &#x3D; x.to_string();</span><br><span class="line">  println!(&quot;&#123;&#125;&quot;, s);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h4 id="let变量"><a href="#let变量" class="headerlink" title="let变量"></a>let变量</h4><blockquote><p>变量是程序可以操纵的命名存储</p></blockquote><ul><li><p>必须以字母或下划线开头。</p></li><li><p>变量的名称可以由字母，数字和下划线字符组成。</p></li><li><p>Rust区分大小写</p></li><li><p>不可变性</p><ul><li>变量默认是不可变的，只读的。也就是说，变量的值在初始化后不可再被改变。比如</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let var &#x3D; 25_000;</span><br><span class="line"> println!(&quot;var is &#123;&#125; &quot;,var);</span><br><span class="line"> var &#x3D; 35_000;</span><br><span class="line"> println!(&quot;var changed is &#123;&#125;&quot;,var);</span><br></pre></td></tr></table></figure><p>Console</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  --&gt; src&#x2F;main.rs:57:5</span><br><span class="line">   |</span><br><span class="line">55 |     let var &#x3D; 25_000;</span><br><span class="line">   |         ---</span><br><span class="line">   |         |</span><br><span class="line">   |         first assignment to &#96;var&#96;</span><br><span class="line">   |         help: consider making this binding mutable: &#96;mut var&#96;</span><br><span class="line">56 |     println!(&quot;var is &#123;&#125; &quot;,var);</span><br><span class="line">57 |     var &#x3D; 35_000;</span><br><span class="line">   |     ^^^^^^^^^^^^ cannot assign twice to immutable variable</span><br></pre></td></tr></table></figure><ul><li>可变性<ul><li>在变量名前加上 <strong>mut</strong> 关键字可以使其可变。可变变量的值可以更改。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let mut var &#x3D; 25_000;</span><br><span class="line">  println!(&quot;var is &#123;&#125; &quot;,var);</span><br><span class="line">  var &#x3D; 35_000;</span><br><span class="line">  println!(&quot;var changed is &#123;&#125;&quot;,var);</span><br></pre></td></tr></table></figure><p>Console</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var is 25000 </span><br><span class="line">var changed is 35000</span><br></pre></td></tr></table></figure><h4 id="const常量"><a href="#const常量" class="headerlink" title="const常量"></a>const常量</h4><blockquote><p>常量一定要显式声明它的数据类型。以下是声明常量的语法：</p></blockquote><ul><li>而声明常量时一定要声明它的数据类型。<code>const VARIABLE_NAME:dataType = value;</code></li><li>使用 <strong>let</strong> 关键字声明的变量默认是不可变的。但是你可以选择使用 <strong>mut</strong> 关键字来使其可变。常量则<code>永远是不可变的</code>。</li><li>常量可以在任何范围内声明，包括全局范围。</li></ul><h5 id="案例-7"><a href="#案例-7" class="headerlink" title="案例"></a>案例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const VAR_NAME:char &#x3D; &#39;A&#39;;</span><br><span class="line">println!(&quot;VAR_NAME is &#123;&#125;&quot;,VAR_NAME);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VAR_NAME is A</span><br></pre></td></tr></table></figure><h4 id="shadowing-覆盖"><a href="#shadowing-覆盖" class="headerlink" title="shadowing 覆盖"></a>shadowing 覆盖</h4><blockquote><p>Rust 支持不同数据类型的变量之间的覆盖（隐藏 shadowing）。</p></blockquote><ul><li>变量可以被覆盖，常量不行。</li></ul><h5 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let salary &#x3D; 100.00;</span><br><span class="line">let salary &#x3D; 1.50 ; </span><br><span class="line">&#x2F;&#x2F; 读取salary变量的值</span><br><span class="line">println!(&quot;The value of salary is :&#123;&#125;&quot;,salary);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The value of salary is :1.5</span><br></pre></td></tr></table></figure><h5 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const salary2 &#x3D; 100.00;</span><br><span class="line">let salary2 &#x3D; 1.50 ; </span><br><span class="line">&#x2F;&#x2F; 读取salary变量的值</span><br><span class="line">println!(&quot;The value of salary is :&#123;&#125;&quot;,salary2);</span><br></pre></td></tr></table></figure><ul><li>Console</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  --&gt; src&#x2F;main.rs:68:11</span><br><span class="line">   |</span><br><span class="line">68 |     const salary2 &#x3D; 100.00;</span><br><span class="line">   |           ^^^^^^^ help: provide a type for the constant: &#96;salary2: f64&#96;</span><br></pre></td></tr></table></figure><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><blockquote><p>运算符（操作符）定义了对于数据的的处理。被运算符所作用的数据被称为运算数。</p></blockquote><h4 id="算数运算法"><a href="#算数运算法" class="headerlink" title="算数运算法"></a>算数运算法</h4><ul><li>加 +</li><li>减 -</li><li>乘 *</li><li>除 / </li><li>取余 %</li></ul><h4 id="操作运算符"><a href="#操作运算符" class="headerlink" title="操作运算符"></a>操作运算符</h4><ul><li><code>&gt;</code> 大于</li><li><code>&lt;</code>小于</li><li><code>&gt;=</code> 大于等于</li><li><code>&lt;=</code> 小于等于</li><li><code>==</code> 等于</li><li><code>!=</code> 不等于</li></ul><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><ul><li><code>&amp;&amp;</code> 与</li><li><code>||</code> 或</li><li><code>! </code>非</li></ul><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><ul><li>&amp; （按位与）</li><li>|（按位或）</li><li>^（按位异或）</li><li>!（按位非）</li><li>&lt;&lt;（左移）</li><li>&gt;&gt;（右移）</li><li>&gt;&gt;&gt;（无符号右移）</li></ul><h2 id="END"><a href="#END" class="headerlink" title="END"></a>END</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Rust基础语法&quot;&gt;&lt;a href=&quot;#Rust基础语法&quot; class=&quot;headerlink&quot; title=&quot;Rust基础语法&quot;&gt;&lt;/a&gt;Rust基础语法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Rust 是一种静态类型的语言。 Rust 中的每个值都是某种数据类型。 编译器可以根据分配给它的值自动推断变量的数据类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;let&quot;&gt;&lt;a href=&quot;#let&quot; class=&quot;headerlink&quot; title=&quot;let&quot;&gt;&lt;/a&gt;let&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;使用let关键字声明变量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fn main() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println!(&amp;quot;Rust基础语法!&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let str_ &amp;#x3D; &amp;quot;String&amp;quot;; &amp;#x2F;&amp;#x2F; string 类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let f_ &amp;#x3D; 1.1; &amp;#x2F;&amp;#x2F; float 类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let bool_ &amp;#x3D; true; &amp;#x2F;&amp;#x2F; boolean 类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    let char_ &amp;#x3D; &amp;#39;a&amp;#39;; &amp;#x2F;&amp;#x2F; unicode character &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println!(&amp;quot;string &amp;#123;&amp;#125;&amp;quot;,str_); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println!(&amp;quot;float &amp;#123;&amp;#125;&amp;quot;,f_); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println!(&amp;quot;boolean &amp;#123;&amp;#125;&amp;quot;,bool_); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    println!(&amp;quot;icon &amp;#123;&amp;#125;&amp;quot;,char_); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;Console&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Rust基础语法!&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;string String&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;float&lt;/span&gt; 1.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;boolean &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;icon a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Rust" scheme="https://z201.cn/categories/Rust/"/>
    
    
      <category term="Rust" scheme="https://z201.cn/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Rust入门</title>
    <link href="https://z201.cn/2021/11/24/Rust%E5%85%A5%E9%97%A8/"/>
    <id>https://z201.cn/2021/11/24/Rust%E5%85%A5%E9%97%A8/</id>
    <published>2021-11-23T18:43:39.000Z</published>
    <updated>2021-12-20T15:43:37.404Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习下Rust</p></blockquote><h2 id="为什么学习Rust"><a href="#为什么学习Rust" class="headerlink" title="为什么学习Rust"></a>为什么学习Rust</h2><blockquote><p>在知乎上看到一个人对Rust的评论。</p><p>首先，Rust 是有点反人类，否则不会一直都不火。然后，Rust 之所以反人类，是因为人类这玩意既愚蠢，又自大，破事还贼多。 你看 C++ 就很相信人类，它要求人类自己把自己 new 出来的东西给 delete 掉。 C++：“这点小事我相信你可以的！” 人类：“没问题！包在我身上！” 然后呢，内存泄漏、double free、野指针满世界飘…… C++：“……”</p><p>Java 选择不相信人类，但替人类把事办好。 Java：“别动，让我来，我有gc！” 人类：“你怎么做事这么慢呀？你怎么还 stop the world 了呀？你是不是不爱我了呀？” Java：“……”</p><p>Rust 发现唯一的办法就是既不相信人类，也不惯着人类。 Rust：“按老子说的做，不做就不编译！” 人类：“你反人类！” Rust：“滚！”</p></blockquote><ul><li>C/C++ 完全相信而且惯着程序员，让大家自行管理内存，所以可以编写很自由的代码，但一个不小心就会造成内存泄漏等问题导致程序崩溃。</li><li>Java/Golang 完全不相信程序员，但也惯着程序员。所有的内存生命周期都由 JVM 运行时统一管理。 在绝大部分场景下，你可以非常自由的写代码，而且不用关心内存到底是什么情况。 内存使用有问题的时候，我们可以通过 JVM 来信息相关的分析诊断和调整。</li><li>Rust 语言选择既不相信程序员，也不惯着程序员。 让你在写代码的时候，必须清楚明白的用 Rust 的规则管理好你的变量，好让机器能明白高效地分析和管理内存。 但是这样会导致代码不利于人的理解，写代码很不自由，学习成本也很高。</li></ul><a id="more"></a><h2 id="安装Rust开发环境"><a href="#安装Rust开发环境" class="headerlink" title="安装Rust开发环境"></a>安装Rust开发环境</h2><h3 id="安装Rust"><a href="#安装Rust" class="headerlink" title="安装Rust"></a>安装Rust</h3><blockquote><p>Rust在Mac系统上非常的友好</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure><ul><li>脚本会检测你的操作系统，然后提示你是否安装</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211124031930.png"></p><ul><li>默认选择1就好了</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211124032020.png"></p><ul><li>这样就安装好了</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="variable">$HOME</span>/.cargo/env</span><br><span class="line"><span class="comment"># 设置下Rust的环境变量</span></span><br><span class="line">rustc --version </span><br><span class="line"><span class="comment"># 如果正常显示版本说明安装成功了</span></span><br></pre></td></tr></table></figure><h3 id="创建测试项目"><a href="#创建测试项目" class="headerlink" title="创建测试项目"></a>创建测试项目</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir learning</span><br><span class="line"><span class="built_in">cd</span> learning</span><br><span class="line">cargo new learning-01</span><br><span class="line"><span class="built_in">cd</span> learning-01</span><br><span class="line">cargo run</span><br><span class="line"></span><br><span class="line">Hello, world!</span><br><span class="line"><span class="comment"># 如果变成成功并输出消息则表示测试项目通过了。</span></span><br></pre></td></tr></table></figure><h2 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h2><blockquote><p>Rust 是一个系统级编程语言，被 Mozilla 员工 “Graydon Hoare” 于 2006 年 开发。他形容 Rust 是一种线程安全的支持并发的实用型的编程语言，支持函数式编程与命令式编程。</p></blockquote><h3 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h3><blockquote><p>Cargo是Rust的构建系统和包管理工具，和Java中maven类似的功能。</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查看版本</span><br><span class="line">cargo --version</span><br></pre></td></tr></table></figure><ul><li>创建一个项目</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cargo new new_project</span><br><span class="line"><span class="built_in">cd</span> new _project</span><br><span class="line">➜  new_project git:(master) ✗ tree </span><br><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br><span class="line"></span><br><span class="line">1 directory, 2 files</span><br></pre></td></tr></table></figure><ul><li>这里的Cargo.toml就是配置文件 <a href="https://github.com/toml-lang/toml" target="_blank" rel="noopener"><em>TOML</em></a> (<em>Tom’s Obvious, Minimal Language</em>) 格式，这是 Cargo 配置文件的格式。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[package]</span><br><span class="line">name &#x3D; &quot;new_project&quot;</span><br><span class="line">version &#x3D; &quot;0.1.0&quot;</span><br><span class="line">edition &#x3D; &quot;2021&quot;</span><br><span class="line"></span><br><span class="line"># See more keys and their definitions at https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;cargo&#x2F;reference&#x2F;manifest.html</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br></pre></td></tr></table></figure><ul><li>构建并运行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br><span class="line">➜  new_project git:(master) ✗ cargo build</span><br><span class="line">   Compiling new_project v0.1.0 (/Users/z201/word/rust/learning-rust/new_project)</span><br><span class="line">    Building [                             ] 0/1: new_project(bin)                                                                                                                                                                </span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 11.12s</span><br><span class="line">    </span><br><span class="line">➜  new_project git:(master) ✗ ./target/debug/new_project </span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><ul><li>也可以直接编译加运行</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure><ul><li>快速检查是否可以编译</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo check</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;学习下Rust&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么学习Rust&quot;&gt;&lt;a href=&quot;#为什么学习Rust&quot; class=&quot;headerlink&quot; title=&quot;为什么学习Rust&quot;&gt;&lt;/a&gt;为什么学习Rust&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在知乎上看到一个人对Rust的评论。&lt;/p&gt;
&lt;p&gt;首先，Rust 是有点反人类，否则不会一直都不火。然后，Rust 之所以反人类，是因为人类这玩意既愚蠢，又自大，破事还贼多。 你看 C++ 就很相信人类，它要求人类自己把自己 new 出来的东西给 delete 掉。 C++：“这点小事我相信你可以的！” 人类：“没问题！包在我身上！” 然后呢，内存泄漏、double free、野指针满世界飘…… C++：“……”&lt;/p&gt;
&lt;p&gt;Java 选择不相信人类，但替人类把事办好。 Java：“别动，让我来，我有gc！” 人类：“你怎么做事这么慢呀？你怎么还 stop the world 了呀？你是不是不爱我了呀？” Java：“……”&lt;/p&gt;
&lt;p&gt;Rust 发现唯一的办法就是既不相信人类，也不惯着人类。 Rust：“按老子说的做，不做就不编译！” 人类：“你反人类！” Rust：“滚！”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;C/C++ 完全相信而且惯着程序员，让大家自行管理内存，所以可以编写很自由的代码，但一个不小心就会造成内存泄漏等问题导致程序崩溃。&lt;/li&gt;
&lt;li&gt;Java/Golang 完全不相信程序员，但也惯着程序员。所有的内存生命周期都由 JVM 运行时统一管理。 在绝大部分场景下，你可以非常自由的写代码，而且不用关心内存到底是什么情况。 内存使用有问题的时候，我们可以通过 JVM 来信息相关的分析诊断和调整。&lt;/li&gt;
&lt;li&gt;Rust 语言选择既不相信程序员，也不惯着程序员。 让你在写代码的时候，必须清楚明白的用 Rust 的规则管理好你的变量，好让机器能明白高效地分析和管理内存。 但是这样会导致代码不利于人的理解，写代码很不自由，学习成本也很高。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Rust" scheme="https://z201.cn/categories/Rust/"/>
    
    
      <category term="Rust" scheme="https://z201.cn/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Permission-Design</title>
    <link href="https://z201.cn/2021/09/20/Permission-design/"/>
    <id>https://z201.cn/2021/09/20/Permission-design/</id>
    <published>2021-09-20T13:38:35.000Z</published>
    <updated>2021-09-20T14:19:13.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>权限管理是一个几乎所有大中型 B 端系统都会涉及的重要组成部分，其目的是对整个系统进行权限控制，避免造成误操作及数据泄露等风险问题。</p></blockquote><h2 id="权限与权限管理"><a href="#权限与权限管理" class="headerlink" title="权限与权限管理"></a>权限与权限管理</h2><h3 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h3><blockquote><p>权限相关的基本概念：</p></blockquote><ul><li>权限：用户可操作行为的最小单位。</li><li>用户：每个用户都有唯一标识，并被授予一个或多个角色。</li><li>角色：由不同的权限组合而成，最终分配给具体用户。</li><li>权限管理：控制用户的权限，只能访问授权内容。</li></ul><h3 id="模型选择"><a href="#模型选择" class="headerlink" title="模型选择"></a>模型选择</h3><ul><li>ACL（Access Control List）：基于用户级别的权限控制。<ul><li>将系统的各种权限直接授予具体的用户。抽象来说，为每个用户维护了单独的权限列表，当需要分配权限、收回权限时，需要修改对应用户的权限信息。</li></ul></li><li>RBAC（Role Base Access Control）：基于角色级别的权限控制。<ul><li>与 ACL 对比，RBAC不用给用户单个分配权限，权限与用户之前通过角色关联。通过给不同的角色分配不同的权限，只需要将用户指向对应的角色就会有对应的权限。分配权限、收回权限只需要通过修改用户的角色即可。</li></ul></li><li>ABAC（Attribute Base Access Control）：基于属性级别的权限控制。<ul><li>不同于常见的将用户通过某种方式直接关联到权限的方式，ABAC 是通过动态计算一个或一组属性来是否满足某种条件来进行权限判断。属性一般分为四类：用户属性（自然人属性，如年龄、性别等），环境属性（物理环境，如时间、地点、气候），操作属性（读、写）和对象属性（操作对象，如资金、某张图片、某个特定的页面，又称资源属性）。</li></ul></li><li>因此理论上能够实现灵活的权限控制、将在权限与用户之前通过一组或多组属性实现关联，几乎能满足所有类型的需求。</li></ul><h3 id="权限管控"><a href="#权限管控" class="headerlink" title="权限管控"></a>权限管控</h3><blockquote><p>抽象来看权限体系可以分为如下两类：功能权限 与 数据权限 两部分。</p></blockquote><ul><li>功能权限指的是在系统中的功能可否使用，通常我们将功能权限分为查看、编辑、删除等，同时编辑、删除权限又包含了查看。通过小的权限点拆分更精细的赋予了员工能否进入某个页面查看信息、编辑信息的能力。</li><li>数据权限指数据中存在的数据是否能查看，是一个更细粒度的权限。比如一个页面，不同角色查看不同的数据就需要通过数据权限控制。<br>从管理对象维度又可以分为：企业能力 与 员工能力。</li><li>企业能力店铺维度的权限，比如开通某服务，可以通过企业能力去体现。</li><li>企业能力赋予用户的权限，比如收电子发票、资金管理等。</li><li>企业能力优先级绝对高于员工能力，所有场景的权限判断，店铺能力必须先于员工能力。简单地说，企业能力决定了“企业能做什么”，员工能力决定了“用户能做什么”。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;权限管理是一个几乎所有大中型 B 端系统都会涉及的重要组成部分，其目的是对整个系统进行权限控制，避免造成误操作及数
      
    
    </summary>
    
    
      <category term="系统设计" scheme="https://z201.cn/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="系统设计" scheme="https://z201.cn/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="权限设计" scheme="https://z201.cn/tags/%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Git-Develop-Branch</title>
    <link href="https://z201.cn/2021/09/20/Git-Develop-Branch/"/>
    <id>https://z201.cn/2021/09/20/Git-Develop-Branch/</id>
    <published>2021-09-20T13:34:52.000Z</published>
    <updated>2021-09-22T15:40:44.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="规范代码开发流程"><a href="#规范代码开发流程" class="headerlink" title="规范代码开发流程"></a>规范代码开发流程</h2><blockquote><p>git 分支分为集成分支、功能分支和修复分支，分别命名为 develop、feature 和 hotfix，均为单数。不可使用 features、future、hotfixes、hotfixs 等错误名称。</p></blockquote><p>1.git主分支(master)。它是自动建立，用于发布重大版本更新（github 现在默认是是main 因种族歧视问题）<br>2.git开发主分支(develop)。日常开发在此分支上进行<br>3.git临时性分支：用于应对一些特定目的的版本开发(验证OK后，应该删除此分支)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 功能（feature）分支：它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。可以采用feature-的形式命名。</span><br><span class="line">- 预发布（release）分支：指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从Develop分支上面分出来的，预发布结束以后，</span><br><span class="line">必须合并进Develop和Master分支。它的命名，可以采用release-的形式。</span><br><span class="line">- 修补bug（hotfix）分支：软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。修补bug分支是从Master或Develop分支上面分出来的。修补结束以后，</span><br><span class="line">再合并进Master和Develop分支。它的命名，可以采用hotfix-***的形式。</span><br></pre></td></tr></table></figure><p>开发流程</p><blockquote><p>暂定临时分支feature、hotfix两种启用。暂不启用RP、code review。</p></blockquote><p>1.基于develop生成新临时开发分支。<br>2.测试、正式环境上线通过。<br>3.合并至develop分支，并生成对应的tag版本。<br>4.完成特定功能开发后(验证OK后，应该删除此分支)。<br>5.README.md文档中记录tag版本生成时间以及具体的功能名称。</p><p>修复bug流程</p><blockquote><p>根据最新已经上线的分支代码创建hotfix分支。</p></blockquote><p>1.基于develop或者上个tag版本(根据实际情况而定)生成新临时开发分支。<br>2.测试、正式环境上线通过。<br>3.合并至develop分支，并生成对应的tag版本。<br>4.<code>若存在临时开发分支</code>-完成特定功能开发后(验证OK后，应该删除此分支)。<br>5.<code>若存在临时开发分支</code>-临时开发分支合并已经修复bug的develop代码。<br>6.<code>若存在临时开发分支</code>-临时开发分支完成特定功能开发后(验证OK后，应该删除此分支)。<br>7.README.md文档中记录tag版本生成时间以及具体的功能名称。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="开发尺码"><a href="#开发尺码" class="headerlink" title="开发尺码"></a>开发尺码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop &#x2F;&#x2F; 切换开发分支，git pull origin develop 并同步最新的develop分支代码。（强制）</span><br><span class="line">git checkout -b feature-sizeGroup &#x2F;&#x2F;基于develop分支创建新的开发分支（强制）</span><br><span class="line">git checkout develop &#x2F;&#x2F; feature-sizeGroup完成上线后develop分支准备合并分支（强制）</span><br><span class="line">git merge feature-sizeGroup &#x2F;&#x2F; 合并开发功能分支（强制）</span><br><span class="line">git tag -a v1.4 -m &quot;my version 1.4&quot; &#x2F;&#x2F; 合并完成创建标签备注中简单说明开发功能（强制）</span><br><span class="line">git push origin v1.4 &#x2F;&#x2F; 推送tag标签到远程仓库（强制）</span><br><span class="line">git branch -d feature-sizeGroup &#x2F;&#x2F;删除本地的临时开发分支(非强制)</span><br><span class="line">git push origin --delete feature-sizeGroup &#x2F;&#x2F; 删除远程的临时开发分支（强制）</span><br><span class="line">vim README.md &#x2F;&#x2F; 保存新增tag版本记录（强制）</span><br><span class="line">git add README.md &#x2F;&#x2F; 追踪README.md文件。（强制）</span><br><span class="line">git commit -m &quot;发布新的tag&quot; &#x2F;&#x2F; 将暂存区里的改动给提交到本地的版本库（强制）</span><br><span class="line">git push origin develop &#x2F;&#x2F; 推送改动后的develop（强制）</span><br></pre></td></tr></table></figure><h3 id="master-合并周期"><a href="#master-合并周期" class="headerlink" title="master 合并周期"></a>master 合并周期</h3><blockquote><p>每月月底最后几个工作日完成对master 对develop分支的合并。</p></blockquote><h3 id="tag-版本命名"><a href="#tag-版本命名" class="headerlink" title="tag 版本命名"></a>tag 版本命名</h3><blockquote><p>版本命名规范</p></blockquote><ul><li>版本: v1.1.1 ( Build 101001 )</li><li>版本格式 bigVersion.middleVersion.smallVersion</li><li>bigVersion 大版本(年度或者重大更新（强制更新，老版本存在不兼容等情况）) 取值范围 1-99</li><li>middleVersion 迭代版本 取值范围 1-99</li><li>smallVersion bug修复增强发布。 取值范围 1-999</li><li>Build为版本纯数字格式化。</li></ul><h3 id="git帮助文档"><a href="#git帮助文档" class="headerlink" title="git帮助文档"></a>git帮助文档</h3><p><a href="https://gitee.com/all-about-git" target="_blank" rel="noopener">git 大全</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;规范代码开发流程&quot;&gt;&lt;a href=&quot;#规范代码开发流程&quot; class=&quot;headerlink&quot; title=&quot;规范代码开发流程&quot;&gt;&lt;/a&gt;规范代码开发流程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;git 分支分为集成分支、功能分支和修复分支，分别命名为 deve
      
    
    </summary>
    
    
      <category term="Git" scheme="https://z201.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="https://z201.cn/tags/Git/"/>
    
      <category term="Develop" scheme="https://z201.cn/tags/Develop/"/>
    
      <category term="Branch" scheme="https://z201.cn/tags/Branch/"/>
    
  </entry>
  
  <entry>
    <title>Jvm-optimization</title>
    <link href="https://z201.cn/2021/08/19/Jvm-optimization/"/>
    <id>https://z201.cn/2021/08/19/Jvm-optimization/</id>
    <published>2021-08-19T06:09:45.000Z</published>
    <updated>2021-11-23T17:53:10.172Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jvm调优是日常工作中经常会使用的技巧，整理下。</p></blockquote><h3 id="项目启动的时候加上的参数都是些啥意思？"><a href="#项目启动的时候加上的参数都是些啥意思？" class="headerlink" title="项目启动的时候加上的参数都是些啥意思？"></a>项目启动的时候加上的参数都是些啥意思？</h3><blockquote><p>刚开始工作的时候发现同事会在jar启动的命令上增加很多参数,很长一段时间都不清楚是干啥的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=<span class="number">128</span>m -XX:MaxMetaspaceSize=<span class="number">128</span>m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=<span class="number">8</span> -XX:+UseConcMarkSweepGC</span><br></pre></td></tr></table></figure><ul><li>简单介绍下参数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=128m （元空间默认大小）</span><br><span class="line">-XX:MaxMetaspaceSize=128m （元空间最大大小）</span><br><span class="line">-Xms1024m （堆最大大小）</span><br><span class="line">-Xmx1024m （堆默认大小）</span><br><span class="line">-Xmn256m （新生代大小）</span><br><span class="line">-Xss256k （棧最大深度大小）</span><br><span class="line">-XX:SurvivorRatio=8 （新生代分区比例 8:2）</span><br><span class="line">-XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器）</span><br><span class="line">-XX:+PrintGCDetails （打印详细的GC日志）</span><br></pre></td></tr></table></figure><ul><li>虽然有了介绍但是依然不清楚具体是干啥的。并且Java虚拟机提供了非常多的参数命令。下面代码可以输出支持的参数数量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -XX:+UnlockDiagnosticVMOptions -version | wc -l</span><br><span class="line">openjdk version <span class="string">"1.8.0_275"</span></span><br><span class="line"><span class="function">OpenJDK Runtime <span class="title">Environment</span> <span class="params">(AdoptOpenJDK)</span><span class="params">(build <span class="number">1.8</span><span class="number">.0</span>_275-b01)</span></span></span><br><span class="line"><span class="function">OpenJDK 64-Bit Server <span class="title">VM</span> <span class="params">(AdoptOpenJDK)</span><span class="params">(build <span class="number">25.275</span>-b01, mixed mode)</span></span></span><br><span class="line"><span class="function">     838</span></span><br></pre></td></tr></table></figure><ul><li>堆内存大小配置</li></ul><blockquote><p>建议 -Xms = 最大内存 * [0.6. ~0.8] 这里需要考虑系统损耗内存、和实际物理内存。</p></blockquote><ul><li><p>堆内存与堆外内存</p><ul><li>堆内存</li></ul><blockquote><p>必须是1024的倍数，且不能低于2M。</p><p>32位机器，最大1G/4G 64位机器最大可以超过 32G/64G</p></blockquote><ul><li>堆外内存</li></ul><blockquote><p>堆外内存一般指 Direct Memory ，不受GC控制，JVM、Netty都可能使用堆外内存。</p></blockquote></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxDirectMemorySize 限制</span><br></pre></td></tr></table></figure><h3 id="如何理解这些参数的含义？"><a href="#如何理解这些参数的含义？" class="headerlink" title="如何理解这些参数的含义？"></a>如何理解这些参数的含义？</h3><blockquote><p>首先我们需要理解java是如何运行的，为什么需要java虚拟机？    </p><p>我们常用方式一般是安装java运行环境(jre)用命令行的方式启动或者直接双击jar运行。jre包含的java运行的必要环境。</p><p>Java 作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。编译出来的也不是机器可以直接直接运行代码。所以使用面向Java语言的虚拟机运行Java编译以后的特定代码。这里的特定代码指的是Java字节指令码。</p></blockquote><h3 id="JVM-内存分配性能问题"><a href="#JVM-内存分配性能问题" class="headerlink" title="JVM 内存分配性能问题"></a>JVM 内存分配性能问题</h3><ul><li>在应用服务的特定场景下，JVM 内存分配不合理带来的性能表现并不会像内存溢出问题这么突出。如果没有深入到各项性能指标中去，是很难发现其中隐藏的性能损耗。</li><li>JVM 内存分配不合理最直接的表现就是频繁的 GC，这会导致上下文切换等性能问题，从而降低系统的吞吐量、增加系统的响应时间。</li></ul><h3 id="分析-GC-日志"><a href="#分析-GC-日志" class="headerlink" title="分析 GC 日志"></a>分析 GC 日志</h3><ul><li>在进行压测的时候，我们需要对GC日志进行分析。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/log/heap.log</span><br></pre></td></tr></table></figure><ul><li>-XX:PrintGCTimeStamps：打印 GC 具体时间；</li><li>-XX:PrintGCDetails ：打印出 GC 详细日志；</li><li>-Xloggc: path：GC 日志生成路径。</li><li>JVM 内存调优通常和 GC 调优是互补的，基于以上调优，可以对年轻代和堆内存的垃圾回收算法进行调优。</li></ul><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;jvm调优是日常工作中经常会使用的技巧，整理下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;项目启动的时候加上的参数都是些啥意思？&quot;&gt;&lt;a href=&quot;#项目启动的时候加上的参数都是些啥意思？&quot; class=&quot;headerlink&quot; title=&quot;项目启动的时候加上的参数都是些啥意思？&quot;&gt;&lt;/a&gt;项目启动的时候加上的参数都是些啥意思？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;刚开始工作的时候发现同事会在jar启动的命令上增加很多参数,很长一段时间都不清楚是干啥的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-XX:MetaspaceSize=&lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;m -XX:MaxMetaspaceSize=&lt;span class=&quot;number&quot;&gt;128&lt;/span&gt;m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; -XX:+UseConcMarkSweepGC&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;简单介绍下参数&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-XX:MetaspaceSize=128m （元空间默认大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-XX:MaxMetaspaceSize=128m （元空间最大大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-Xms1024m （堆最大大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-Xmx1024m （堆默认大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-Xmn256m （新生代大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-Xss256k （棧最大深度大小）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-XX:SurvivorRatio=8 （新生代分区比例 8:2）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-XX:+PrintGCDetails （打印详细的GC日志）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;虽然有了介绍但是依然不清楚具体是干啥的。并且Java虚拟机提供了非常多的参数命令。下面代码可以输出支持的参数数量&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java -XX:+PrintFlagsFinal -XX:+UnlockDiagnosticVMOptions -version | wc -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;openjdk version &lt;span class=&quot;string&quot;&gt;&quot;1.8.0_275&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;OpenJDK Runtime &lt;span class=&quot;title&quot;&gt;Environment&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(AdoptOpenJDK)&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(build &lt;span class=&quot;number&quot;&gt;1.8&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;_275-b01)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;OpenJDK 64-Bit Server &lt;span class=&quot;title&quot;&gt;VM&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;(AdoptOpenJDK)&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(build &lt;span class=&quot;number&quot;&gt;25.275&lt;/span&gt;-b01, mixed mode)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;     838&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;堆内存大小配置&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;建议 -Xms = 最大内存 * [0.6. ~0.8] 这里需要考虑系统损耗内存、和实际物理内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;堆内存与堆外内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆内存&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;必须是1024的倍数，且不能低于2M。&lt;/p&gt;
&lt;p&gt;32位机器，最大1G/4G 64位机器最大可以超过 32G/64G&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;堆外内存&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;堆外内存一般指 Direct Memory ，不受GC控制，JVM、Netty都可能使用堆外内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-XX:MaxDirectMemorySize 限制&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;如何理解这些参数的含义？&quot;&gt;&lt;a href=&quot;#如何理解这些参数的含义？&quot; class=&quot;headerlink&quot; title=&quot;如何理解这些参数的含义？&quot;&gt;&lt;/a&gt;如何理解这些参数的含义？&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;首先我们需要理解java是如何运行的，为什么需要java虚拟机？    &lt;/p&gt;
&lt;p&gt;我们常用方式一般是安装java运行环境(jre)用命令行的方式启动或者直接双击jar运行。jre包含的java运行的必要环境。&lt;/p&gt;
&lt;p&gt;Java 作为一门高级程序语言，它的语法非常复杂，抽象程度也很高。编译出来的也不是机器可以直接直接运行代码。所以使用面向Java语言的虚拟机运行Java编译以后的特定代码。这里的特定代码指的是Java字节指令码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;JVM-内存分配性能问题&quot;&gt;&lt;a href=&quot;#JVM-内存分配性能问题&quot; class=&quot;headerlink&quot; title=&quot;JVM 内存分配性能问题&quot;&gt;&lt;/a&gt;JVM 内存分配性能问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在应用服务的特定场景下，JVM 内存分配不合理带来的性能表现并不会像内存溢出问题这么突出。如果没有深入到各项性能指标中去，是很难发现其中隐藏的性能损耗。&lt;/li&gt;
&lt;li&gt;JVM 内存分配不合理最直接的表现就是频繁的 GC，这会导致上下文切换等性能问题，从而降低系统的吞吐量、增加系统的响应时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;分析-GC-日志&quot;&gt;&lt;a href=&quot;#分析-GC-日志&quot; class=&quot;headerlink&quot; title=&quot;分析 GC 日志&quot;&gt;&lt;/a&gt;分析 GC 日志&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;在进行压测的时候，我们需要对GC日志进行分析。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/log/heap.log&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;-XX:PrintGCTimeStamps：打印 GC 具体时间；&lt;/li&gt;
&lt;li&gt;-XX:PrintGCDetails ：打印出 GC 详细日志；&lt;/li&gt;
&lt;li&gt;-Xloggc: path：GC 日志生成路径。&lt;/li&gt;
&lt;li&gt;JVM 内存调优通常和 GC 调优是互补的，基于以上调优，可以对年轻代和堆内存的垃圾回收算法进行调优。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Jvm" scheme="https://z201.cn/categories/Jvm/"/>
    
    
      <category term="Jvm" scheme="https://z201.cn/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>Nginx-log-format</title>
    <link href="https://z201.cn/2021/08/18/Nginx-log-format/"/>
    <id>https://z201.cn/2021/08/18/Nginx-log-format/</id>
    <published>2021-08-18T10:11:55.000Z</published>
    <updated>2021-08-19T06:07:24.818Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Ngxin 日志格式化</p></blockquote><ul><li>Nginx提供的访问日志里就蕴藏着大量有用信息。今天这篇要说的就是如果修改Nginx默认日志格式，以便于我们更好的挖掘有效指标。</li></ul><p>编辑<code>/etc/nginx.conf</code>配置文件，在日志部分添加下面两段代码，编辑完成后重启Nginx服务即可。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> main <span class="string">'<span class="variable">$host</span> - <span class="variable">$remote_addr</span> - [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                <span class="string">'<span class="variable">$status</span> <span class="variable">$upstream_response_time</span> <span class="variable">$request_time</span> "<span class="variable">$http_referer</span>"'</span></span><br><span class="line">                <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>" <span class="variable">$body_bytes_sent</span> '</span>;</span><br><span class="line"><span class="attribute">access_log</span> /var/log/nginx/access.log main;</span><br></pre></td></tr></table></figure><blockquote><p>简单罗列一下变量的含义:</p></blockquote><ul><li><code>$host</code> 访问域名</li><li><code>$remote_addr</code> 客户端IP地址</li><li><code>$time_local</code> 访问时间</li><li><code>$status</code> 访问状态码</li><li><code>$upstream_response_time</code> 应用返回到Nginx的时间</li><li><code>$request_time</code> 请求时间</li><li><code>$http_referer</code> 请求来源</li><li><code>$http_user_agent</code> 访问客户端</li><li><code>$http_x_forwarded_for</code> 客户端IP地址</li><li><code>$body_bytes_sent</code> 返回给客户端大小</li></ul><blockquote><p>在server中不生效的问题</p></blockquote><ul><li>在server中增加 <code>access_log /var/log/nginx/access.log main;</code></li></ul><blockquote><p>日期显示问题</p></blockquote><ul><li><p><code>[01/Jul/2020:03:25:17 +0800]  </code>官方默认是这种</p></li><li><p>修改默认格式</p></li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> main <span class="string">'<span class="variable">$host</span> - <span class="variable">$remote_addr</span> - [<span class="variable">$time_iso8601</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                <span class="string">'<span class="variable">$status</span> <span class="variable">$upstream_response_time</span> <span class="variable">$request_time</span> "<span class="variable">$http_referer</span>"'</span></span><br><span class="line">                <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>" <span class="variable">$body_bytes_sent</span> '</span>;</span><br><span class="line"><span class="attribute">access_log</span> /var/log/nginx/access.log main;</span><br></pre></td></tr></table></figure><ul><li>在server中增加下面代码</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line"></span><br><span class="line">if ($time_iso8601 ~ "^(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;) (\d&#123;2&#125;):(\d&#123;2&#125;):(\d&#123;2&#125;)") &#123;</span><br><span class="line"><span class="attribute">set</span> <span class="variable">$year</span> <span class="variable">$1</span>;</span><br><span class="line"><span class="attribute">set</span> <span class="variable">$month</span> <span class="variable">$2</span>;</span><br><span class="line"><span class="attribute">set</span> <span class="variable">$day</span> <span class="variable">$3</span>;</span><br><span class="line"><span class="attribute">set</span> <span class="variable">$hour</span> <span class="variable">$4</span>;</span><br><span class="line"><span class="attribute">set</span> <span class="variable">$minutes</span> <span class="variable">$5</span>;</span><br><span class="line"><span class="attribute">set</span> <span class="variable">$seconds</span> <span class="variable">$6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Ngxin 日志格式化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Nginx提供的访问日志里就蕴藏着大量有用信息。今天这篇要说的就是如果修改Nginx默认日志格式，以便于我们更好的挖掘有效指标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编辑&lt;cod
      
    
    </summary>
    
    
      <category term="Nginx" scheme="https://z201.cn/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://z201.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Centos7_jenkins部署</title>
    <link href="https://z201.cn/2021/05/25/Centos7-jenkins%E9%83%A8%E7%BD%B2/"/>
    <id>https://z201.cn/2021/05/25/Centos7-jenkins%E9%83%A8%E7%BD%B2/</id>
    <published>2021-05-25T13:20:35.000Z</published>
    <updated>2021-09-21T07:04:54.547Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录最近在Centos7上面部署jenkens。安装的方法有很多，下面采用最简单的方式安装。</p></blockquote><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>在线文档 <a href="https://jenkins.io/doc/" target="_blank" rel="noopener">https://jenkins.io/doc/</a></li><li>名词解释：<ul><li>CI</li></ul></li></ul><blockquote><p>jenkins 是一个协调者的身份，管理和协调了代码库，代码仓库，代码运行环境等。</p></blockquote><h2 id="jenkins-简介"><a href="#jenkins-简介" class="headerlink" title="jenkins 简介"></a>jenkins 简介</h2><blockquote><p>Jenkins是一个开源软件项目，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。持续集成（CI）已成为当前许多软件开发团队在整个软件开发生命周期内侧重于保证代码质量的常见做法。它是一种实践，旨在缓和和稳固软件的构建过程。并且能够帮助您的开发团队应对如下挑战：</p></blockquote><ul><li>持续、自动地构建/测试软件项目。</li><li>监控一些定时执行的任务。</li><li>高度可扩展性、全球大量团队使用，并共享代码。</li><li>基于插件、可以做出非常多有趣的事情。</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/jenkins/2.jpg"> </p><h2 id="安裝部署"><a href="#安裝部署" class="headerlink" title="安裝部署"></a>安裝部署</h2><a id="more"></a><blockquote><p>单实例部署</p></blockquote><h3 id="检查当前系统环境"><a href="#检查当前系统环境" class="headerlink" title="检查当前系统环境"></a>检查当前系统环境</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]<span class="comment"># cat /etc/os-release </span></span><br><span class="line">NAME=<span class="string">"CentOS Linux"</span></span><br><span class="line">VERSION=<span class="string">"7 (Core)"</span></span><br><span class="line">ID=<span class="string">"centos"</span></span><br><span class="line">ID_LIKE=<span class="string">"rhel fedora"</span></span><br><span class="line">VERSION_ID=<span class="string">"7"</span></span><br><span class="line">PRETTY_NAME=<span class="string">"CentOS Linux 7 (Core)"</span></span><br><span class="line">ANSI_COLOR=<span class="string">"0;31"</span></span><br><span class="line">CPE_NAME=<span class="string">"cpe:/o:centos:centos:7"</span></span><br><span class="line">HOME_URL=<span class="string">"https://www.centos.org/"</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"https://bugs.centos.org/"</span></span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">"CentOS-7"</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">"7"</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT=<span class="string">"centos"</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=<span class="string">"7"</span></span><br></pre></td></tr></table></figure><h3 id="添加源以及公钥"><a href="#添加源以及公钥" class="headerlink" title="添加源以及公钥"></a>添加源以及公钥</h3><h4 id="更新安装jenkens源"><a href="#更新安装jenkens源" class="headerlink" title="更新安装jenkens源"></a>更新安装jenkens源</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum 源导入</span></span><br><span class="line">sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入密钥</span></span><br><span class="line">sudo rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">sudo yum install jenkins</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动下载安装包安装</span></span><br><span class="line">https://pkg.jenkins.io/redhat-stable/ <span class="comment"># 这里面找</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#检查安装</span></span><br><span class="line">whereis jenkins</span><br><span class="line">&gt; jenkins: /usr/lib/jenkins</span><br><span class="line"><span class="comment"># 提示以上内容说明安装成功</span></span><br></pre></td></tr></table></figure><h3 id="修改jenkens配置信息"><a href="#修改jenkens配置信息" class="headerlink" title="修改jenkens配置信息"></a>修改jenkens配置信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编辑jenkins配置文件</span></span><br><span class="line">vim /etc/sysconfig/jenkins</span><br><span class="line"><span class="comment"># 这里主要编辑两个参数 JENKINS_USER JENKINS_JAVA_OPTIONS</span></span><br><span class="line"><span class="comment"># JENKINS_USER jenkens权限用户</span></span><br><span class="line"><span class="comment"># JENKINS_JAVA_OPTIONS jenkens启动参数，这里主要设置启动内存。</span></span><br><span class="line">JENKINS_USER=<span class="string">"root"</span></span><br><span class="line">JENKINS_JAVA_OPTIONS=<span class="string">"-server -Xms512m -Xmx1024m -XX:PermSize=256m -XX:MaxPermSize=512m  -Djava.awt.headless=true"</span></span><br><span class="line"><span class="comment"># 修改目录权限 如果你不是使用root账号,我偷下懒。</span></span><br><span class="line">chown -R root:root /var/lib/jenkins</span><br><span class="line">chown -R root:root /var/cache/jenkins</span><br><span class="line">chown -R root:root /var/<span class="built_in">log</span>/jenkins</span><br></pre></td></tr></table></figure><h3 id="启动junkets检查"><a href="#启动junkets检查" class="headerlink" title="启动junkets检查"></a>启动junkets检查</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#重载所有修改过的配置文件</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动Jenkins服务</span></span><br><span class="line">sudo systemctl start jenkins</span><br><span class="line"></span><br><span class="line"><span class="comment">#由于Jenkins不是Native Service，所以需要用chkconfig命令而不是systemctl命令</span></span><br><span class="line">sudo /sbin/chkconfig jenkins on</span><br></pre></td></tr></table></figure><h3 id="第一次启动配置"><a href="#第一次启动配置" class="headerlink" title="第一次启动配置"></a>第一次启动配置</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看密码</span></span><br><span class="line">cat /var/lib/jenkins/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure><h3 id="配置jenkens-jdk-maven环境"><a href="#配置jenkens-jdk-maven环境" class="headerlink" title="配置jenkens jdk maven环境"></a>配置jenkens jdk maven环境</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在系统环境中增加</span></span><br><span class="line"><span class="comment"># JAVA_HOME</span></span><br><span class="line"><span class="comment"># MAVEN_HOME </span></span><br><span class="line"><span class="comment"># 如果jdk是通过yum 安装需要通过ll找到jvm的安装地址</span></span><br><span class="line"><span class="comment"># ll /usr/bin/javac -&gt; /etc/alternatives/javac</span></span><br><span class="line"><span class="comment"># ll /etc/alternatives/javac -&gt; /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.292.b10-1.el7_9.x86_64/bin/javac</span></span><br><span class="line"><span class="comment">#举例子</span></span><br><span class="line">JAVA_HOME</span><br><span class="line">/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.292.b10-1.el7_9.x86_64</span><br><span class="line">MAVEN_HOME</span><br><span class="line">/opt/libhome/apache-maven-3.8.1</span><br><span class="line">PATH</span><br><span class="line"><span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$MAVEN_HOME</span>/bin</span><br></pre></td></tr></table></figure><h2 id="配置企业微信通知"><a href="#配置企业微信通知" class="headerlink" title="配置企业微信通知"></a>配置企业微信通知</h2><blockquote><p>安装插件 <a href="https://plugins.jenkins.io/qy-wechat-notification" target="_blank" rel="noopener">Qy Wechat Notification Plugin</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果无法发送通知提示javax.net.ssl.SSLHandshakeException: No appropriate protocol (protocol is disabled or cipher suites are inappropriate</span><br><span class="line">需要修改$JRE&#x2F;lib&#x2F;security&#x2F;java.security</span><br></pre></td></tr></table></figure><ul><li>去掉两个配置信息 <code>TLSv1 TLSv1.1</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jdk.tls.disabledAlgorithms&#x3D;SSLv3, TLSv1, RC4, DES, MD5withRSA, DH keySize &lt; 1024, \</span><br><span class="line">EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL</span><br></pre></td></tr></table></figure><h4 id="友情提示"><a href="#友情提示" class="headerlink" title="友情提示"></a>友情提示</h4><blockquote><p>不要选择社区推荐插件安装</p></blockquote><ul><li><p>因为 <code>Jenkins</code> 插件服务器在国外，所以速度不太理想。我们需要更换为清华大学的 <code>Jenkins</code> 插件源后，再安装插件，<strong>所以先不要点安装插件。</strong></p></li><li><p>更换方法很简单。进入服务器，将 <code>/var/lib/jenkins/updates/default.json</code> 内的插件源地址替换成清华大学的源地址，将 google 替换为 baidu 即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i 's/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g' /var/lib/jenkins/updates/default.json &amp;&amp; sed -i 's/http:\/\/www.google.com/https:\/\/www.baidu.com/g' /var/lib/jenkins/updates/default.json</span><br></pre></td></tr></table></figure></li></ul><h2 id="修改运行端口"><a href="#修改运行端口" class="headerlink" title="修改运行端口"></a>修改运行端口</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/jenkins</span><br><span class="line"></span><br><span class="line">JENKINS_PORT=<span class="string">"8080"</span> //改成 JENKINS_PORT=<span class="string">"8088"</span></span><br></pre></td></tr></table></figure><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><ul><li>启动、重启、关闭</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]<span class="comment">#  service jenkins start</span></span><br><span class="line">[root@localhost jenkins]<span class="comment">#  service jenkins restart</span></span><br><span class="line">[root@localhost jenkins]<span class="comment">#  service jenkins shutdown</span></span><br></pre></td></tr></table></figure><ul><li>错误提示</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Starting jenkins (via systemctl):  Warning: jenkins.service changed on disk. Run <span class="string">'systemctl daemon-reload'</span> to reload units.</span><br></pre></td></tr></table></figure><ul><li>若出现上述问题，执行。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]<span class="comment"># systemctl daemon-reload</span></span><br></pre></td></tr></table></figure><ul><li>启动jenkins</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]<span class="comment"># sudo service jenkins start</span></span><br></pre></td></tr></table></figure><ul><li>进入jenkins 网站；一般是8080端口。界面会让你输入密码进入。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]# cat &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;secrets&#x2F;initialAdminPassword</span><br></pre></td></tr></table></figure><ul><li>安装插件,如果出现下列错误。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An error occurred during installation: No such plugin: cloudbees-folder</span><br></pre></td></tr></table></figure><ul><li>可以直接跳过。直接创建管理帐号进入。这个时候插件列表是空的。在插件高中替换URL。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;mirror.xmission.com&#x2F;jenkins&#x2F;updates&#x2F;update-center.json</span><br></pre></td></tr></table></figure><ul><li>end.</li></ul><h2 id="修改Jenkins-工作空間目錄"><a href="#修改Jenkins-工作空間目錄" class="headerlink" title="修改Jenkins 工作空間目錄"></a>修改Jenkins 工作空間目錄</h2><ul><li>系统设置</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/jenkins/3.png"></p><ul><li>这里的工作空间目录有一个环境配置变量。${JENKINS_HOME}</li><li>在系统环境变量中配置JENKINS_HOME 指向新的工作空间。</li></ul><h2 id="Jenkins-shell权限问题。"><a href="#Jenkins-shell权限问题。" class="headerlink" title="Jenkins shell权限问题。"></a>Jenkins shell权限问题。</h2><ul><li>在执行shell 脚本的时候需要修改权限，如果不修改会导致部分权限问题。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost jenkins]<span class="comment"># vim /etc/sysconfig/jenkins</span></span><br></pre></td></tr></table></figure><ul><li>修改配置文件的 JENKINS_USER = “root”</li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="Maven-Integration-plugin"><a href="#Maven-Integration-plugin" class="headerlink" title="Maven Integration plugin"></a>Maven Integration plugin</h3><blockquote><p>用于Maven项目构建。</p></blockquote><h3 id="Monitoring"><a href="#Monitoring" class="headerlink" title="Monitoring"></a>Monitoring</h3><blockquote><p>监控Jenkins所消耗的系统资源，如内存使用等</p></blockquote><h3 id="Publish-Over-SSH"><a href="#Publish-Over-SSH" class="headerlink" title="Publish Over SSH"></a>Publish Over SSH</h3><blockquote><p>远程Shell</p></blockquote><h3 id="Email-Extersion-Plugin"><a href="#Email-Extersion-Plugin" class="headerlink" title="Email Extersion Plugin"></a><a href="https://wiki.jenkins-ci.org/display/JENKINS/Email-ext+plugin" target="_blank" rel="noopener">Email Extersion Plugin</a></h3><blockquote><p>邮件通知</p></blockquote><h4 id="邮箱配置"><a href="#邮箱配置" class="headerlink" title="邮箱配置"></a>邮箱配置</h4><blockquote><p>jenkins 自带邮箱功能，可以通过邮箱发送任务构建时的信息。</p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/jenkins/email.png"> </p><ul><li>Jenkins URL 是当前jenkins访问地址 可以是内网也可以是外网。</li></ul><h4 id="邮件通知"><a href="#邮件通知" class="headerlink" title="邮件通知"></a>邮件通知</h4><ul><li>SMTP服务器<ul><li>这个邮件帐号的运营商配置</li><li>配置完后可以测试。</li><li>如果收到邮件说明配置成功。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录最近在Centos7上面部署jenkens。安装的方法有很多，下面采用最简单的方式安装。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在线文档 &lt;a href=&quot;https://jenkins.io/doc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://jenkins.io/doc/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;名词解释：&lt;ul&gt;
&lt;li&gt;CI&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;jenkins 是一个协调者的身份，管理和协调了代码库，代码仓库，代码运行环境等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;jenkins-简介&quot;&gt;&lt;a href=&quot;#jenkins-简介&quot; class=&quot;headerlink&quot; title=&quot;jenkins 简介&quot;&gt;&lt;/a&gt;jenkins 简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Jenkins是一个开源软件项目，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。持续集成（CI）已成为当前许多软件开发团队在整个软件开发生命周期内侧重于保证代码质量的常见做法。它是一种实践，旨在缓和和稳固软件的构建过程。并且能够帮助您的开发团队应对如下挑战：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;持续、自动地构建/测试软件项目。&lt;/li&gt;
&lt;li&gt;监控一些定时执行的任务。&lt;/li&gt;
&lt;li&gt;高度可扩展性、全球大量团队使用，并共享代码。&lt;/li&gt;
&lt;li&gt;基于插件、可以做出非常多有趣的事情。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/jenkins/2.jpg&quot;&gt; &lt;/p&gt;
&lt;h2 id=&quot;安裝部署&quot;&gt;&lt;a href=&quot;#安裝部署&quot; class=&quot;headerlink&quot; title=&quot;安裝部署&quot;&gt;&lt;/a&gt;安裝部署&lt;/h2&gt;
    
    </summary>
    
    
      <category term="Linux运维" scheme="https://z201.cn/categories/Linux%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Centos7" scheme="https://z201.cn/tags/Centos7/"/>
    
      <category term="Jenkins" scheme="https://z201.cn/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>差缺补漏-Netty</title>
    <link href="https://z201.cn/2021/02/25/%E5%B7%AE%E7%BC%BA%E8%A1%A5%E6%BC%8F-Netty/"/>
    <id>https://z201.cn/2021/02/25/%E5%B7%AE%E7%BC%BA%E8%A1%A5%E6%BC%8F-Netty/</id>
    <published>2021-02-25T04:09:20.000Z</published>
    <updated>2021-12-17T06:39:46.006Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Netty是一款用于快速开发高性能的网络应用程序的Java框架，正是因为有 Netty 的存在，网络编程领域 Java 才得以与 C++ 并肩而立。</p></blockquote><ul><li>Netty 官网给出了有关 Netty 的整体功能模块结构</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211116220629.png"></p><ul><li>Core核心层</li></ul><blockquote><p>提供底层网络通信抽象和实现，其中包括了可扩展的时间模型、通信API、支持零拷贝的buf等。</p></blockquote><ul><li>Protocol Support 协议支持层</li></ul><blockquote><p>协议支持层基本上覆盖了主流协议的编解码实现，比如HTTP、SSL、WebSocket</p></blockquote><ul><li>Transport Service 传输服务层</li></ul><blockquote><p>传输服务层提供了网络传输能力的定义和实现方法，支持 Socket、HTTP 隧道等。Netty 对 TCP、UDP 等数据传输做了抽象和封装</p></blockquote><h3 id="Netty流程"><a href="#Netty流程" class="headerlink" title="Netty流程"></a>Netty流程</h3><blockquote><p>从功能上理解顺序</p></blockquote><ul><li>启动服务 -&gt; 构建连接 -&gt; 接受数据 -&gt; 业务处理 -&gt; 发送数据 -&gt; 断开连接 -&gt; 关闭服务</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ul><li>初始化线程池</li><li>初始化channel</li><li>绑定端口并启动</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Echoes back any received data from a client.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> SSL = System.getProperty(<span class="string">"ssl"</span>) != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">"port"</span>, <span class="string">"8007"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Configure SSL.</span></span><br><span class="line">        <span class="keyword">final</span> SslContext sslCtx;</span><br><span class="line">        <span class="keyword">if</span> (SSL) &#123;</span><br><span class="line">            SelfSignedCertificate ssc = <span class="keyword">new</span> SelfSignedCertificate();</span><br><span class="line">            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sslCtx = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure the server.</span></span><br><span class="line">        <span class="comment">// 在官方的example中默认是Reactor主从多线程模式</span></span><br><span class="line">        <span class="comment">// 1.配置线程池</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>) // 2.初始化<span class="title">channel</span>类型</span></span><br><span class="line"><span class="class">             .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 100) // 2.1.设置<span class="title">channel</span>参数</span></span><br><span class="line"><span class="class">             .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">              // 注册<span class="title">channelhandler</span>，在<span class="title">netty</span>中通过<span class="title">ChannelPipeline</span> 去注册多个 <span class="title">ChannelHandler</span></span></span><br><span class="line"><span class="class">             .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     ChannelPipeline p = ch.pipeline();</span><br><span class="line">                     <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">                     p.addLast(serverHandler);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start the server. </span></span><br><span class="line">            <span class="comment">// 3.启动 通过bind() 方法会真正触发启动，sync() 方法则会阻塞</span></span><br><span class="line">            ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line">            <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="bind方法"><a href="#bind方法" class="headerlink" title="bind方法"></a>bind方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.调用 initAndRegister()方法初始化Channel,接受返回到ChannelFuture。</span></span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">  <span class="comment">// 2.调用 ChannelFuture.channel方法，返回Channel。</span></span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">  <span class="comment">// 3.调用 ChannelFuture.cause方法判断 initAndRegister()是否存在异常。存在异常则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.调用 ChannelFuture.isDone方法，判断initAndRegister()方法是否执行完成。</span></span><br><span class="line">    <span class="comment">//  如果执行完成则调用bind0方法，如果没有执行完成，ChannelFuture 添加一个ChannelFutureListener回调监听，当initAndRegister()方法执行完成后回调operationComplete方法，调用调用 ChannelFuture.cause()方法判断initAndRegister()是否存在异常，无异常在执行bind0方法。</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="comment">// At this point we know that the registration was complete and successful.</span></span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Registration future is almost always fulfilled already, but just in case it's not.</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></span><br><span class="line">                    <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line">                    <span class="comment">// See https://github.com/netty/netty/issues/2586</span></span><br><span class="line">                    promise.registered();</span><br><span class="line"></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><blockquote><p>Netty网络通信组件、用于执行网络I/O操作。</p></blockquote><ul><li><p>提供网络相关配置信息</p></li><li><p>Channel参数</p><ul><li><p>SO_KEEPALIVE </p><ul><li>设置为 true 代表启用了 TCP SO_KEEPALIVE 属性，TCP 会主动探测连接状态，即连接保活</li></ul></li><li><p>SO_BACKLOG </p><ul><li>已完成三次握手的请求队列最大长度，同一时刻服务端可能会处理多个连接，在高并发海量连接的场景下，该参数应适当调大</li></ul></li><li><p>TCP_NODELAY </p><ul><li>Netty 默认是 true，表示立即发送数据。如果设置为 false 表示启用 Nagle 算法，该算法会将 TCP 网络数据包累积到一定量才会发送，虽然可以减少报文发送的数量，但是会造成一定的数据延迟。Netty 为了最小化数据传输的延迟，默认禁用了 Nagle 算法</li></ul></li><li><p>SO_SNDBUF TCP </p><ul><li>数据发送缓冲区大小</li></ul></li><li><p>SO_RCVBUF </p><ul><li>TCP数据接收缓冲区大小，TCP数据接收缓冲区大小</li></ul></li><li><p>SO_LINGER </p><ul><li>设置延迟关闭的时间，等待缓冲区中的数据发送完成 </li></ul></li><li><p>CONNECT_TIMEOUT_MILLIS  </p><ul><li>连接超时时间</li></ul></li></ul></li><li><p>常用的Channel类型</p><ul><li><p>NioSocketChannel，异步的客户端 TCP Socket 连接。</p></li><li><p>NioServerSocketChannel，异步的服务器端 TCP Socket 连接。</p></li><li><p>NioDatagramChannel，异步的 UDP 连接。</p></li><li><p>NioSctpChannel，异步的客户端 Sctp 连接。</p></li><li><p>NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。</p></li></ul></li></ul><h4 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h4><blockquote><p>EventLoop并不是Netty独有的，它是一种<strong>事件等待和处理的程序模型</strong>，可以解决多线程资源消耗高的问题。</p></blockquote><ul><li>在 Netty 中 EventLoop 可以理解为 Reactor 线程模型的事件处理引擎，每个 EventLoop 线程都维护一个 Selector 选择器和任务队列 taskQueue。它主要负责处理 I/O 事件、普通任务和定时任务。Netty 中推荐使用 NioEventLoop 作为实现类。</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211213143517.png"></p><ul><li>上图是EventLoop常见模型<ul><li>每次出现事件的时候，Eventloop会将事件存放在Event Queue事件队列中，通过轮询取出事件执行或者将事件分发给响应的事件监听执行，事件执行的方式通常分为立即执行、延后执行、定期执行几种。</li></ul></li></ul><h5 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line">                        <span class="comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.SELECT: <span class="comment">// 处理select事件</span></span><br><span class="line">                        <span class="comment">// 轮训io事件</span></span><br><span class="line">                        select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 'wakenUp.compareAndSet(false, true)' is always evaluated</span></span><br><span class="line">                        <span class="comment">// before calling 'selector.wakeup()' to reduce the wake-up</span></span><br><span class="line">                        <span class="comment">// overhead. (Selector.wakeup() is an expensive operation.)</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="comment">// However, there is a race condition in this approach.</span></span><br><span class="line">                        <span class="comment">// The race condition is triggered when 'wakenUp' is set to</span></span><br><span class="line">                        <span class="comment">// true too early.</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="comment">// 'wakenUp' is set to true too early if:</span></span><br><span class="line">                        <span class="comment">// 1) Selector is waken up between 'wakenUp.set(false)' and</span></span><br><span class="line">                        <span class="comment">//    'selector.select(...)'. (BAD)</span></span><br><span class="line">                        <span class="comment">// 2) Selector is waken up between 'selector.select(...)' and</span></span><br><span class="line">                        <span class="comment">//    'if (wakenUp.get()) &#123; ... &#125;'. (OK)</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="comment">// In the first case, 'wakenUp' is set to true and the</span></span><br><span class="line">                        <span class="comment">// following 'selector.select(...)' will wake up immediately.</span></span><br><span class="line">                        <span class="comment">// Until 'wakenUp' is set to false again in the next round,</span></span><br><span class="line">                        <span class="comment">// 'wakenUp.compareAndSet(false, true)' will fail, and therefore</span></span><br><span class="line">                        <span class="comment">// any attempt to wake up the Selector will fail, too, causing</span></span><br><span class="line">                        <span class="comment">// the following 'selector.select(...)' call to block</span></span><br><span class="line">                        <span class="comment">// unnecessarily.</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        <span class="comment">// To fix this problem, we wake up the selector again if wakenUp</span></span><br><span class="line">                        <span class="comment">// is true immediately after selector.select(...).</span></span><br><span class="line">                        <span class="comment">// It is inefficient in that it wakes up the selector for both</span></span><br><span class="line">                        <span class="comment">// the first case (BAD - wake-up required) and the second case</span></span><br><span class="line">                        <span class="comment">// (OK - no wake-up required).</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                            selector.wakeup();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// fall through</span></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="comment">// If we receive an IOException here its because the Selector is messed up. Let's rebuild</span></span><br><span class="line">                    <span class="comment">// the selector and retry. https://github.com/netty/netty/issues/8566</span></span><br><span class="line">                    rebuildSelector0();</span><br><span class="line">                    handleLoopException(e);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cancelledKeys = <span class="number">0</span>;</span><br><span class="line">                needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">                <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        processSelectedKeys(); <span class="comment">// 处理io事件</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                        runAllTasks(); <span class="comment">// 处理所有任务</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        processSelectedKeys(); <span class="comment">// 处理io事件</span></span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                        runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                handleLoopException(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                    closeAll();</span><br><span class="line">                    <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                handleLoopException(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="EventLoop良好的实践"><a href="#EventLoop良好的实践" class="headerlink" title="EventLoop良好的实践"></a>EventLoop良好的实践</h5><ul><li>网络连接建立过程中三次握手、安全认证的过程会消耗不少时间。建议使用Reactor混合模式采用 Boss 和 Worker 两个 EventLoopGroup。</li><li>Reactor 线程模式适合处理耗时短的任务场景，耗时较长的 ChannelHandler 可以考虑维护一个业务线程池。避免 ChannelHandler 阻塞而造成 EventLoop 不可用。</li><li>如果业务逻辑执行时间较短，建议直接在 ChannelHandler 中执行。减少系统复杂度。</li><li>尽量少的ChannelHandler，尽量将业务独立出去。</li></ul><h4 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h4><blockquote><p>实际编码过程中，业务处理逻辑是 ChannelPipeline 中所定义的 ChannelHandler 完成的，Netty 服务编排层的核心组件 ChannelPipeline 和 ChannelHandler 为用户提供了 I/O 事件管理。</p></blockquote><ul><li>从ChannelPipeline注释上面抓的图</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211213213842.png"></p><ul><li>channelPipeline采用责任链没事，Inbound入站、outbound出站。</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211213220334.png"></p><ul><li>每个 Channel 会绑定一个 ChannelPipeline，每一个 ChannelPipeline 都包含多个ChannelHandlerContext，所有 ChannelHandlerContext 之间组成了双向链表。ChannelPipeline 的双向链表分别维护了 HeadContext 和 TailContext 的头尾节点。自定义的 ChannelHandler 会插入到 Head 和 Tail 之间。</li><li>ChannelHandlerContext包含了ChannelHandler 生命周期的所有事件。入站的时候是从headContext往tailContext执行，出站的时候tailContext往headContext执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span></span>&#123;</span><br><span class="line">             ChannelPipeline channelPipeline = ch.pipeline();</span><br><span class="line">             channelPipeline.addLast(<span class="string">"idleHandler"</span>, <span class="keyword">new</span> ServerIdleCheckHandler());</span><br><span class="line">             channelPipeline.addLast(<span class="string">"frameDecoder"</span>,<span class="keyword">new</span> FrameDecoder());</span><br><span class="line">             channelPipeline.addLast(<span class="string">"frameEncoder"</span>,<span class="keyword">new</span> FrameEncoder());</span><br><span class="line">             channelPipeline.addLast(<span class="string">"protocolDecoder"</span>,<span class="keyword">new</span> ProtocolDecoder());</span><br><span class="line">             channelPipeline.addLast(<span class="string">"protocolEncoder"</span>,<span class="keyword">new</span> ProtocolEncoder());</span><br><span class="line">             channelPipeline.addLast(<span class="string">"loggingHandler"</span>,<span class="keyword">new</span> LoggingHandler(LogLevel.INFO));</span><br><span class="line">             channelPipeline.addLast(<span class="string">"protocolProcessHandler"</span>,<span class="keyword">new</span> ServerProtocolProcessHandler());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure><ul><li>运行效果</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">22:10:57 [work-3-1] FrameDecoder: running</span><br><span class="line">22:10:57 [work-3-1] FrameEncoder: running</span><br><span class="line">22:10:57 [work-3-1] ProtocolDecoder: running</span><br><span class="line">22:10:57 [work-3-1] ServerProtocolProcessHandler: running</span><br><span class="line">22:10:57 [work-3-1] ProtocolEncoder: running</span><br></pre></td></tr></table></figure><h5 id="ChannelPipeline异常处理"><a href="#ChannelPipeline异常处理" class="headerlink" title="ChannelPipeline异常处理"></a>ChannelPipeline异常处理</h5><ul><li>pipleline是责任链模式，推荐在自定义handler末端添加同一的异常处理器。根据异常信息处理逻辑。</li></ul><h4 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h4><blockquote><p>Netty中的数据容器，Java Nio中也提供了ByteBuffer但是使用复杂。</p></blockquote><h4 id="Zero-Copy"><a href="#Zero-Copy" class="headerlink" title="Zero-Copy"></a>Zero-Copy</h4><blockquote><p><strong>Netty</strong> 的<code>Zero-copy</code> ,零拷贝是一个耳熟能详的词语，在 Linux、Kafka、RocketMQ 等知名的产品中都有使用，通常用于提升 I/O 性能。</p></blockquote><h4 id="Keepalive"><a href="#Keepalive" class="headerlink" title="Keepalive"></a>Keepalive</h4><blockquote><p>keepalive就是心跳，一个人的心跳证明人还活着，那么在网络通信的双方如何证明对端还活着着，两个服务之间使用心跳来检测对方是否还活着。</p></blockquote><h4 id="Netty中的设计模式"><a href="#Netty中的设计模式" class="headerlink" title="Netty中的设计模式"></a>Netty中的设计模式</h4><ul><li>单例  ReadTimeoutException#INSTANCE</li><li>工厂 ReflectiveChannelFactory</li><li>策略 EventExecutorChooserFactory</li><li>装饰器 WrappedByteBuf</li><li>模版 AbstractTrafficShapingHandler</li><li>责任链 ChannelPipeline  ChannelHandler</li><li>观察者 ChannelFuture#addListener</li></ul><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="良好的实践"><a href="#良好的实践" class="headerlink" title="良好的实践"></a>良好的实践</h4><ul><li>通过修改<code>线程名</code>方便我们在debug或者异常追踪,通过NioEventLoopGroup的构造方法来修改名称</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">0</span>,<span class="keyword">new</span> DefaultThreadFactory(<span class="string">"boss"</span>));</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(,<span class="keyword">new</span> DefaultThreadFactory(<span class="string">"work"</span>));</span><br></pre></td></tr></table></figure><ul><li>修改<code>Handler</code>名称，如果不设置Handler的名称，会使用默认的类名。添加到pipleline到时候指定名字。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> channelPipeline.addLast(<span class="string">"idleHandler"</span>, <span class="keyword">new</span> ServerIdleCheckHandler());</span><br><span class="line">channelPipeline.addLast(<span class="string">"frameDecoder"</span>,<span class="keyword">new</span> FrameDecoder());</span><br><span class="line"> channelPipeline.addLast(<span class="string">"frameEncoder"</span>,<span class="keyword">new</span> FrameEncoder());</span><br></pre></td></tr></table></figure><ul><li>日志,这里从Netty自带的LoggingHandler跟踪源码,这里可以看到优先使用的是SLF4J。但是需要手动引入相应的jar依赖。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalLoggerFactory <span class="title">newDefaultFactory</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        InternalLoggerFactory f;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            f = <span class="keyword">new</span> Slf4JLoggerFactory(<span class="keyword">true</span>);</span><br><span class="line">            f.newInstance(name).debug(<span class="string">"Using SLF4J as the default logging framework"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore1) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                f = Log4JLoggerFactory.INSTANCE;</span><br><span class="line">                f.newInstance(name).debug(<span class="string">"Using Log4J as the default logging framework"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f = Log4J2LoggerFactory.INSTANCE;</span><br><span class="line">                    f.newInstance(name).debug(<span class="string">"Using Log4J2 as the default logging framework"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ignore3) &#123;</span><br><span class="line">                    f = JdkLoggerFactory.INSTANCE;</span><br><span class="line">                    f.newInstance(name).debug(<span class="string">"Using java.util.logging as the default logging framework"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>在不同的平台切换Nio native实现,这里需要注意开发环境和生产环境。在生产环境还需要注意权限问题、并且准好号native的库。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mac </span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> KQueueEventLoopGroup(<span class="number">0</span>,<span class="keyword">new</span> DefaultThreadFactory(<span class="string">"boss"</span>));</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> KQueueEventLoopGroup(<span class="number">0</span>,<span class="keyword">new</span> DefaultThreadFactory(<span class="string">"work"</span>));</span><br><span class="line"><span class="comment">// linxu </span></span><br><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> EpollEventLoopGroup(<span class="number">0</span>,<span class="keyword">new</span> DefaultThreadFactory(<span class="string">"boss"</span>));</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> EpollEventLoopGroup(<span class="number">0</span>,<span class="keyword">new</span> DefaultThreadFactory(<span class="string">"work"</span>));</span><br><span class="line"><span class="comment">// 注意开发环境与生产环境,</span></span><br></pre></td></tr></table></figure><h4 id="为什么要使用netty而不使用Jdk自带的NIO"><a href="#为什么要使用netty而不使用Jdk自带的NIO" class="headerlink" title="为什么要使用netty而不使用Jdk自带的NIO"></a>为什么要使用netty而不使用Jdk自带的NIO</h4><blockquote><p>更好的api、更加稳定、可扩展性</p></blockquote><ul><li>相比nio,netty做的更多，做的更好。</li><li>使用jdk nio，我们使用 JDK NIO 编程需要了解很多复杂的概念，比如 Channels、Selectors、Sockets、Buffers 等、还需要解决沾包、半包的问题，还需要做大量的定制化需求。网络本身就很复杂，比如短线重连、心跳。</li><li>netty解决了大量nio的bug,比如select空转导致cpu 100%，使用netty可以很好的规避大量存在的问题，毕竟jdk也是人写的。</li><li>netty在扩展性上，在线程模型可以通过参数配置选择线程模型。</li><li>JDK的NIO默认是水平触发，Netty是边缘触发（默认）和水平触发可以切换。</li><li>Netty实现的垃圾回收更少、性能更好。</li></ul><h4 id="经典的三种I-O模式"><a href="#经典的三种I-O模式" class="headerlink" title="经典的三种I/O模式"></a>经典的三种I/O模式</h4><blockquote><p>BIO（阻塞I/O）、NIO(非阻塞I/O)、AIO(异步I/O)</p></blockquote><ul><li>阻塞于非阻塞<ul><li>阻塞情况下，没有数据传输过来时，读操作会阻塞一直等待到有数据，缓冲区写满的时候，写做操也会阻塞。非阻塞遇到这种情况都是直接返回。</li></ul></li><li>同步于异步<ul><li>数据准备就绪需要自己去读取就是同步，数据就绪直接读取好回调给程序就是异步。</li></ul></li></ul><h5 id="netty如何实现三种I-O模式"><a href="#netty如何实现三种I-O模式" class="headerlink" title="netty如何实现三种I/O模式"></a>netty如何实现三种I/O模式</h5><ul><li>BIO在netty中也叫OIO和AIO一起曾经都支持过。现在Netty仅支持NIO。</li></ul><h5 id="nio一定优于bio吗"><a href="#nio一定优于bio吗" class="headerlink" title="nio一定优于bio吗"></a>nio一定优于bio吗</h5><ul><li>在连接数少、并发低的场景下，BIO性能并不输NIO。</li></ul><h5 id="什么是水平触发、什么是边缘触发"><a href="#什么是水平触发、什么是边缘触发" class="headerlink" title="什么是水平触发、什么是边缘触发"></a>什么是水平触发、什么是边缘触发</h5><blockquote><p>边缘触发相当于高速模式，理论上效率更高，但是复杂度也高，所以现在大多应用（Redis等）还是默认水平触发，如果追求要更好的性能、同时有信心编码好，可以尝试使用边缘触发，例如nginx。边缘触发只支持非阻塞模式。</p></blockquote><ul><li>当被监控的文件有可读写事件发生时，epoll_wait()会通知处理程序去读写，如果这次没有把数据一次性全部读写完的话，水平触发：那么下次调用 epoll_wait()时通知你上次没读写完，如果一直不处理它会一直通知你；边缘触发：下次调用 epoll_wait()的时候不会通知你，也就是只通知一次，知道该文件上出现第二次可读写事件才会通知，效率比水平触发要高</li></ul><h4 id="Netty对Reactor的支持"><a href="#Netty对Reactor的支持" class="headerlink" title="Netty对Reactor的支持"></a>Netty对Reactor的支持</h4><blockquote><p>nio在netty中的是由reactor实现的，Reactor是一种开发模式,在netty中Reactor有三种模式。</p></blockquote><ul><li><strong>单线程模型</strong>：EventLoopGroup只包含一个EventLoop，Boss和Worker使用同一个EventLoopGroup</li><li><strong>多线程模型</strong>：EventLoopGroup包含多个EventLoop，Boss和Worker使用同一个EventLoopGroup</li><li><strong>主从多线程模型</strong>：EventLoopGroup包含多个EventLoop，Boss是主Reactor，Worker是从Reactor，它们分别使用不同的EventLoopGroup，主Reactor负责新的网络连接Channel创建，然后把Channel注册到从Reactor</li></ul><h5 id="Reactor单线程模式"><a href="#Reactor单线程模式" class="headerlink" title="Reactor单线程模式"></a>Reactor单线程模式</h5><ul><li>Reactor单线程模式所有的I/O操作都由一个线程完成。仅需要启动一个NioEventLoopGroup。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">b.group(group)</span><br></pre></td></tr></table></figure><p>![image-20211120161222982](/Users/zengqingfeng/Library/Application Support/typora-user-images/image-20211120161222982.png)</p><ul><li>一个线程支持的连接数是有限的，性能方面cpu容易跑满。</li><li>当多个事件同时触发的时候，容易出现柱塞的情况，会导致消息的积压、客户端请求超时。</li><li>线程在处理I/O事件，Select无法处理其他操作，比如建立连接、事件分发等操作。长时间的线程满负载，容易导致服务节点不可用。</li></ul><h5 id="非主从Reactor多线程模式"><a href="#非主从Reactor多线程模式" class="headerlink" title="非主从Reactor多线程模式"></a>非主从Reactor多线程模式</h5><ul><li>由于Reactor出现的严重的性能问题，因此出现了多线程模型，在创建NioEventLoopGroup的时候可以不指定大小，默认是2 * cpu的线程数量，也可以手动设置固定的线程数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">b.group(group)</span><br></pre></td></tr></table></figure><p>![image-20211120161554909](/Users/zengqingfeng/Library/Application Support/typora-user-images/image-20211120161554909.png)</p><h5 id="主从Reactor多线程模式"><a href="#主从Reactor多线程模式" class="headerlink" title="主从Reactor多线程模式"></a>主从Reactor多线程模式</h5><ul><li>现在主流的开发主要采用主从多线程模式,Boos是主Reactor,worker是从Reactor。它们分别使用不同的NioEventLoopGroup，主Reactor负责处理ON_ACCEPT,然后把Channel注册到Reactor上面，从Reactor负责Channel生命周期内的IO事件。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">EventLoopGroup workerGroup &#x3D; new NioEventLoopGroup();</span><br><span class="line">ServerBootstrap b &#x3D; new ServerBootstrap();</span><br><span class="line">b.group(bossGroup, workerGroup)</span><br></pre></td></tr></table></figure><p>![image-20211120161838884](/Users/zengqingfeng/Library/Application Support/typora-user-images/image-20211120161838884.png)</p><h4 id="c10k"><a href="#c10k" class="headerlink" title="c10k"></a>c10k</h4><blockquote><p>它的意思是一台机器要维护 1 万个连接，就要创建 1 万个进程或者线程，那么操作系统是无法承受的。</p></blockquote><h4 id="select、poll、epoll"><a href="#select、poll、epoll" class="headerlink" title="select、poll、epoll"></a>select、poll、epoll</h4><table><thead><tr><th></th><th>Select</th><th>Poll</th><th>Poll</th></tr></thead><tbody><tr><td>底层实现</td><td>数组</td><td>链表</td><td>哈希表</td></tr><tr><td>I/O</td><td>每次调用线性遍历、时间复杂度O(n)</td><td>每次调用线性遍历、时间复杂度O(n)</td><td>时间通知方式、时间复杂度O(1)</td></tr><tr><td>最大连接数</td><td>1024(x86)、2048(x64)</td><td>无上限</td><td>无上限</td></tr></tbody></table><h4 id="Netty通用模式下NIO实现多路复用器是如何跨平台的"><a href="#Netty通用模式下NIO实现多路复用器是如何跨平台的" class="headerlink" title="Netty通用模式下NIO实现多路复用器是如何跨平台的"></a>Netty通用模式下NIO实现多路复用器是如何跨平台的</h4><blockquote><p>netty在不同平台单独实现了NIO，据说性能更好。windows iocp 、mac kqueue 、linux epool</p></blockquote><ul><li>Netty通用模式一般指的是NioEnventLoopGroup、NioEventLoop、NioSelectSocketChannel、NioSocketChannel的使用场景下，实际上针对Linux和mac单独做了NIO的实现。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法在不同的平台上返回不同的类型。</span></span><br><span class="line">sun.nio.ch.DefaultSelectorProvider.create()</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">package</span> sun.nio.ch;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.spi.SelectorProvider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSelectorProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultSelectorProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在mac/bsd的环境下返回KQueue</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KQueueSelectorProvider();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Netty-是如何解决-epoll-空轮询的-Bug"><a href="#Netty-是如何解决-epoll-空轮询的-Bug" class="headerlink" title="Netty 是如何解决 epoll 空轮询的 Bug"></a>Netty 是如何解决 epoll 空轮询的 Bug</h4><blockquote><p>在 JDK 中， Epoll 的实现是存在漏洞的，即使 Selector 轮询的事件列表为空，NIO 线程一样可以被唤醒，导致 CPU 100% 占用。这就是臭名昭著的 JDK epoll 空轮询的 Bug</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每次执行 Select 操作之前记录当前时间 currentTimeNanos。</span></span><br><span class="line">           <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">           <span class="comment">// time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos，</span></span><br><span class="line">           <span class="comment">// 如果事件轮询的持续时间大于等于 timeoutMillis，那么说明是正常的，否则表明阻塞时间并未达到预期，可能触发了空轮询的 Bug。</span></span><br><span class="line">           <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">               <span class="comment">// timeoutMillis elapsed without anything selected.</span></span><br><span class="line">               selectCnt = <span class="number">1</span>;</span><br><span class="line">               <span class="comment">// 计数变量 selectCnt。在正常情况下，selectCnt 会重置，</span></span><br><span class="line">               <span class="comment">// 否则会对 selectCnt 自增计数。当 selectCnt 达到 SELECTOR_AUTO_REBUILD_THRESHOLD（默认512） 阈值时，</span></span><br><span class="line">               <span class="comment">// 会触发重建 Selector 对象。</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                   selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">               <span class="comment">// The code exists in an extra method to ensure the method is not too big to inline as this</span></span><br><span class="line">               <span class="comment">// branch is not very likely to get hit very frequently.</span></span><br><span class="line">               selector = selectRebuildSelector(selectCnt);</span><br><span class="line">               selectCnt = <span class="number">1</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           currentTimeNanos = time;</span><br></pre></td></tr></table></figure><h4 id="TCP-IP中粘包、半包"><a href="#TCP-IP中粘包、半包" class="headerlink" title="TCP/IP中粘包、半包"></a>TCP/IP中粘包、半包</h4><blockquote><p>TCP是流式协议，数据是无清晰边界的。拆包/粘包问题的存在，数据接收方很难界定数据包的边界在哪里，很难识别出一个完整的数据包。所以需要提供一种机制来识别数据包的界限，这也是解决拆包/粘包的唯一方法：定义应用层的通信协议。</p></blockquote><h5 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h5><ul><li>数据发送方每次写入数据大小小于套接字缓存区大小。合并发送数据的时候。</li></ul><h5 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h5><ul><li>发送方时写入数据大小小于套接字缓存区大小。(发送的数据大于TCP协议中MTU最大传输单位)必须拆包。</li></ul><h5 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h5><blockquote><p>封装成帧(framing)</p></blockquote><ul><li><p>消息长度固定</p><ul><li>每个数据报文都需要一个固定的长度。当接收方累计读取到固定长度的报文后，就认为已经获得一个完整的消息。当发送方的数据小于固定长度时，则需要空位补齐。</li></ul></li><li><p>特定分隔符</p><ul><li>发送报文时尾部需要添加特定分隔符，推荐的做法是将消息进行编码，例如 base64 编码，然后可以选择 64 个编码字符之外的字符作为特定分隔符。Redis 在通信过程中采用的就是换行分隔符 <code>\n </code>、<code>\r\n</code>。</li></ul></li><li><p>消息长度 + 消息内容</p><ul><li>先解析固定长度的字段获取长度，然后读取后续的内容。长度理论上有限制，需要提前预知可能的最大长度。</li></ul></li></ul><h4 id="Netty-对三种常用封帧方式的支持"><a href="#Netty-对三种常用封帧方式的支持" class="headerlink" title="Netty 对三种常用封帧方式的支持"></a>Netty 对三种常用封帧方式的支持</h4><blockquote><p>Netty中解决粘包半包的编解码叫做一次解码器。</p></blockquote><ul><li><p>固定长度  <code>FixedLengthFrameDecoder</code> </p></li><li><p>分隔符   <code>DelimiterBasedFrameDecoder</code></p></li><li><p>固定长度字段存个内容的长度信息 <code>LengthFieldBasedFrameDecoder</code> <code>LengthFieldPrepender</code></p><ul><li>LengthFieldBasedFrameDecoder按照指定的包长度偏移量对接受的数据进行编码。</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211123154642.png"></p><ul><li>LengthFieldPrepender 在响应数据的时候从封装数据，在数据前面增加数据的长度。</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211123154934.png"></p></li></ul><h4 id="二次编解码方式"><a href="#二次编解码方式" class="headerlink" title="二次编解码方式"></a>二次编解码方式</h4><blockquote><p>Netty内置编解码器在实际工作中需要二次编解码，比如我们业务数据是json格式，就需要将原始数据转换成用户数据</p></blockquote><ul><li>在netty源码中内置了很多二次解码器java序列化、XML、JSON等等，都在codec包下。</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211122162837.png"></p><ul><li>比如使用protobuf二次解码器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ProtobufVarint32FrameDecoder());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ProtobufDecoder(PersonOuterClass.Person.getDefaultInstance()));</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ProtobufVarint32LengthFieldPrepender());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> ProtobufEncoder());</span><br></pre></td></tr></table></figure><h4 id="Linux系统参数"><a href="#Linux系统参数" class="headerlink" title="Linux系统参数"></a>Linux系统参数</h4><ul><li>修改linux对单一进程打开的文件句柄数量限制<ul><li><code>ulimit -n [xxx]</code>尽量不要做临时的设置。</li></ul></li></ul><h4 id="有TCP的keepalive，为什么还需要应用层的keepalive"><a href="#有TCP的keepalive，为什么还需要应用层的keepalive" class="headerlink" title="有TCP的keepalive，为什么还需要应用层的keepalive"></a>有TCP的keepalive，为什么还需要应用层的keepalive</h4><blockquote><p>TCP中的keepalive默认是关闭，因此探测包在传递中可能丢失，默认的超时时间太长，默认是7200+9*75秒，也就是2个多小时。TCP是一个传输层的协议，传输层的数据畅通并不一定操作系统进程所对应的服务畅通。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Netty是一款用于快速开发高性能的网络应用程序的Java框架，正是因为有 Netty 的存在，网络编程领域 Java 才得以与 C++ 并肩而立。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Netty 官网给出了有关 Netty 的整体功能模块结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211116220629.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Core核心层&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;提供底层网络通信抽象和实现，其中包括了可扩展的时间模型、通信API、支持零拷贝的buf等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Protocol Support 协议支持层&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;协议支持层基本上覆盖了主流协议的编解码实现，比如HTTP、SSL、WebSocket&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Transport Service 传输服务层&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;传输服务层提供了网络传输能力的定义和实现方法，支持 Socket、HTTP 隧道等。Netty 对 TCP、UDP 等数据传输做了抽象和封装&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Netty流程&quot;&gt;&lt;a href=&quot;#Netty流程&quot; class=&quot;headerlink&quot; title=&quot;Netty流程&quot;&gt;&lt;/a&gt;Netty流程&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;从功能上理解顺序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;启动服务 -&amp;gt; 构建连接 -&amp;gt; 接受数据 -&amp;gt; 业务处理 -&amp;gt; 发送数据 -&amp;gt; 断开连接 -&amp;gt; 关闭服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;案例&quot;&gt;&lt;a href=&quot;#案例&quot; class=&quot;headerlink&quot; title=&quot;案例&quot;&gt;&lt;/a&gt;案例&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;初始化线程池&lt;/li&gt;
&lt;li&gt;初始化channel&lt;/li&gt;
&lt;li&gt;绑定端口并启动&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Sharable&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;EchoServerHandler&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ChannelInboundHandlerAdapter&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;channelRead&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ChannelHandlerContext ctx, Object msg)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ctx.write(msg);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;channelReadComplete&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ChannelHandlerContext ctx)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ctx.flush();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;exceptionCaught&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ChannelHandlerContext ctx, Throwable cause)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Close the connection when an exception is raised.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        cause.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ctx.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Echoes back any received data from a client.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;EchoServer&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; SSL = System.getProperty(&lt;span class=&quot;string&quot;&gt;&quot;ssl&quot;&lt;/span&gt;) != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; PORT = Integer.parseInt(System.getProperty(&lt;span class=&quot;string&quot;&gt;&quot;port&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;8007&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Configure SSL.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; SslContext sslCtx;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (SSL) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            SelfSignedCertificate ssc = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SelfSignedCertificate();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            sslCtx = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Configure the server.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 在官方的example中默认是Reactor主从多线程模式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 1.配置线程池&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        EventLoopGroup bossGroup = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NioEventLoopGroup(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        EventLoopGroup workerGroup = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NioEventLoopGroup();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; EchoServerHandler serverHandler = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; EchoServerHandler();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ServerBootstrap b = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ServerBootstrap();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            b.group(bossGroup, workerGroup)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             .channel(NioServerSocketChannel&lt;span class=&quot;class&quot;&gt;.&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;) // 2.初始化&lt;span class=&quot;title&quot;&gt;channel&lt;/span&gt;类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;             .&lt;span class=&quot;title&quot;&gt;option&lt;/span&gt;(&lt;span class=&quot;title&quot;&gt;ChannelOption&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;SO_BACKLOG&lt;/span&gt;, 100) // 2.1.设置&lt;span class=&quot;title&quot;&gt;channel&lt;/span&gt;参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;             .&lt;span class=&quot;title&quot;&gt;handler&lt;/span&gt;(&lt;span class=&quot;title&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LoggingHandler&lt;/span&gt;(&lt;span class=&quot;title&quot;&gt;LogLevel&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;INFO&lt;/span&gt;))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;              // 注册&lt;span class=&quot;title&quot;&gt;channelhandler&lt;/span&gt;，在&lt;span class=&quot;title&quot;&gt;netty&lt;/span&gt;中通过&lt;span class=&quot;title&quot;&gt;ChannelPipeline&lt;/span&gt; 去注册多个 &lt;span class=&quot;title&quot;&gt;ChannelHandler&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;             .&lt;span class=&quot;title&quot;&gt;childHandler&lt;/span&gt;(&lt;span class=&quot;title&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ChannelInitializer&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;SocketChannel&lt;/span&gt;&amp;gt;() &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;initChannel&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(SocketChannel ch)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     ChannelPipeline p = ch.pipeline();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (sslCtx != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                         p.addLast(sslCtx.newHandler(ch.alloc()));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     &lt;span class=&quot;comment&quot;&gt;//p.addLast(new LoggingHandler(LogLevel.INFO));&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     p.addLast(serverHandler);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// Start the server. &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// 3.启动 通过bind() 方法会真正触发启动，sync() 方法则会阻塞&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ChannelFuture f = b.bind(PORT).sync();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// Wait until the server socket is closed.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            f.channel().closeFuture().sync();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// Shut down all event loops to terminate all threads.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            bossGroup.shutdownGracefully();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            workerGroup.shutdownGracefully();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="https://z201.cn/categories/Netty/"/>
    
    
      <category term="Netty" scheme="https://z201.cn/tags/Netty/"/>
    
      <category term="NIO" scheme="https://z201.cn/tags/NIO/"/>
    
      <category term="IO" scheme="https://z201.cn/tags/IO/"/>
    
      <category term="Reactor" scheme="https://z201.cn/tags/Reactor/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins-local-deployment-level</title>
    <link href="https://z201.cn/2021/02/21/Jenkins-local-deployment-level/"/>
    <id>https://z201.cn/2021/02/21/Jenkins-local-deployment-level/</id>
    <published>2021-02-21T06:40:48.000Z</published>
    <updated>2021-11-23T15:43:02.635Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>整理下Jenkins本地部署程序的过程。</p></blockquote><ul><li><p>在开发阶段，许多编译工具会将我们的源码编译可使用的文件。例如 <code>vue-cli</code> 的项目会被 <code>webpack</code> 打包编译为浏览器的文件，<code>Java</code> 项目会被编译为 <code>.class/jar</code> 文件以供服务器使用。</p><ol><li><p>开发人员将源代码，经过编译、压缩等一系列流程打包</p></li><li><p>上传到服务器。</p></li><li><p>在服务器将编译后的文件，手动可用的容器服务内（例如 <code>Nginx，Tomcat，Apache</code> 等服务）</p></li></ol></li></ul><h3 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h3><blockquote><p>在jenkins所在的机器上部署程序</p></blockquote><ol><li><a href="https://z201.cn/2021/05/25/Centos7-jenkins%E9%83%A8%E7%BD%B2/">部署jenkins</a>并配置环境</li><li>设置jenkins-credentials (后续用于从git仓库中获取代码)</li><li>创建任务<ol><li>设置仓库地址</li><li>设置程序部署shell脚本</li></ol></li></ol><ul><li><p>jenkins shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -Dmaven.test.skip=true</span><br><span class="line">cp x x x/target/xxx-1.0.0-SNAPSHOT.jar /opt/xxx/upgrade</span><br><span class="line">cd /opt/xxx</span><br><span class="line">BUILD_ID=dontKillMe sh xxx.sh</span><br></pre></td></tr></table></figure></li><li><p>编写程序运行shell脚本。</p></li><li><p>部署java</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">app=xxx</span><br><span class="line">appName=$&#123;app&#125;-1.0.0-SNAPSHOT</span><br><span class="line">projPath=/opt/xxx</span><br><span class="line">upgradePath=$&#123;projPath&#125;/upgrade</span><br><span class="line">backPath=$&#123;projPath&#125;/backup</span><br><span class="line">logFile=$&#123;projPath&#125;/data/logs/$&#123;app&#125;.log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查升级文件是否存在</span></span><br><span class="line">echo "checking upgrade file..."</span><br><span class="line">if [ ! -f $&#123;upgradePath&#125;/$&#123;appName&#125;.jar ]; then</span><br><span class="line">    echo "cann't found file $&#123;upgradePath&#125;/$&#123;appName&#125;.jar!"</span><br><span class="line">    exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结束进程</span></span><br><span class="line">pid=`ps aux | grep $&#123;projPath&#125;/$&#123;appName&#125;.jar | grep -v grep | grep -v kill | awk '&#123;print $2&#125;'`</span><br><span class="line">if [ $&#123;pid&#125; ]; then</span><br><span class="line">    echo "kill $&#123;appName&#125;!"</span><br><span class="line">    kill -9 $pid</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 备份原升级文件,如果存在的话</span></span><br><span class="line">if [ -f $&#123;projPath&#125;/$&#123;appName&#125;.jar ]; then</span><br><span class="line">    timeStr=`date +%Y%m%d%H%M%S`</span><br><span class="line">    mv $&#123;projPath&#125;/$&#123;appName&#125;.jar $&#123;backPath&#125;/$&#123;appName&#125;.jar.bak_$&#123;timeStr&#125;</span><br><span class="line">    echo "load $&#123;appName&#125; success!"</span><br><span class="line">    echo "backup $&#123;appName&#125; success!"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝升级文件</span></span><br><span class="line">echo "copy $&#123;appName&#125;.jar..."</span><br><span class="line">cp $&#123;upgradePath&#125;/$&#123;appName&#125;.jar $&#123;projPath&#125;/$&#123;appName&#125;.jar</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动进程</span></span><br><span class="line">echo "start $&#123;appName&#125;..."</span><br><span class="line">nohup java -Djava.security.egd=file:/dev/./urandom -Xms512m -Xmx512m -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=256m -jar $&#123;projPath&#125;/$&#123;appName&#125;.jar --spring.profiles.active=test &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看日志</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断当天日志文件是否存在</span></span><br><span class="line">if [ ! -f $&#123;logFile&#125; ]; then</span><br><span class="line">    # 文件不存在则创建文件，再执行tail命令</span><br><span class="line">    touch $&#123;logFile&#125;</span><br><span class="line">fi</span><br><span class="line">echo "tail -f $&#123;logFile&#125;"</span><br></pre></td></tr></table></figure><ul><li>部署vue</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> git revert</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git restore .</span></span><br><span class="line"></span><br><span class="line">applicationPath=/opt/view/xxxx</span><br><span class="line"></span><br><span class="line">echo 'delete old files...'</span><br><span class="line">rm -rf $&#123;applicationPath&#125;/*</span><br><span class="line"></span><br><span class="line">echo 'copy files after npm build!'</span><br><span class="line">cp -rf dist/* $&#123;applicationPath&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;整理下Jenkins本地部署程序的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在开发阶段，许多编译工具会将我们的源码编译可使用的文件。例如 &lt;code&gt;vue-cli&lt;/code&gt; 的项目会被 &lt;code&gt;webpack&lt;/
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.cn/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="工程化" scheme="https://z201.cn/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Mac安装neo4j和jupyter</title>
    <link href="https://z201.cn/2021/02/19/Mac%E5%AE%89%E8%A3%85neo4j%E5%92%8Cjupyter/"/>
    <id>https://z201.cn/2021/02/19/Mac%E5%AE%89%E8%A3%85neo4j%E5%92%8Cjupyter/</id>
    <published>2021-02-18T16:39:21.000Z</published>
    <updated>2021-10-15T03:05:33.438Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>准备学习下neo4j记录在mac下安装neo4j的坑。</p></blockquote><h2 id="neo4j官网网站下载失败"><a href="#neo4j官网网站下载失败" class="headerlink" title="neo4j官网网站下载失败"></a>neo4j官网网站下载失败</h2><blockquote><p>国内只能从镜像地址下载</p></blockquote><p><a href="http://doc.we-yun.com:1008/" target="_blank" rel="noopener">http://doc.we-yun.com:1008/</a> </p><h2 id="配置jdk11"><a href="#配置jdk11" class="headerlink" title="配置jdk11"></a>配置jdk11</h2><blockquote><p>可以查看我上面内容实用Jenv管理多个版本。</p></blockquote><h2 id="启动neo4j"><a href="#启动neo4j" class="headerlink" title="启动neo4j"></a>启动neo4j</h2><blockquote><p>下载完成后解压</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">./neo4j  start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭</span></span><br><span class="line">./neo4j  stop</span><br></pre></td></tr></table></figure><h2 id="neo4j界面"><a href="#neo4j界面" class="headerlink" title="neo4j界面"></a>neo4j界面</h2><ul><li>在浏览器中输入localhost:7474</li><li>初始用户名、密码均为neo4j， 第一次登录需要修改密码</li></ul><h2 id="安装jupyter"><a href="#安装jupyter" class="headerlink" title="安装jupyter"></a>安装jupyter</h2><blockquote><p>注意提前安装python环境</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter notebook -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host=mirrors.aliyun.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查版本</span></span><br><span class="line">jupyter --version</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;准备学习下neo4j记录在mac下安装neo4j的坑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;neo4j官网网站下载失败&quot;&gt;&lt;a href=&quot;#neo4j官网网站下载失败&quot; class=&quot;headerlink&quot; title=&quot;neo4
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.cn/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="Neo4j" scheme="https://z201.cn/tags/Neo4j/"/>
    
      <category term="Jupiter" scheme="https://z201.cn/tags/Jupiter/"/>
    
  </entry>
  
  <entry>
    <title>Mac下OpenJdk11-JavaFx开发环境配置</title>
    <link href="https://z201.cn/2021/02/15/Mac%E4%B8%8BOpenJdk11-JavaFx%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>https://z201.cn/2021/02/15/Mac%E4%B8%8BOpenJdk11-JavaFx%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2021-02-14T19:12:07.000Z</published>
    <updated>2021-11-21T07:37:26.768Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>OpenJdk 11 环境下JavaFx开发环境设置</p></blockquote><ul><li><a href="https://www.coder.work/article/884639" target="_blank" rel="noopener">https://www.coder.work/article/884639</a></li><li><a href="https://stackoverflow.com/questions/54291958/javafx-11-illegalaccesserror-when-creating-label" target="_blank" rel="noopener">https://stackoverflow.com/questions/54291958/javafx-11-illegalaccesserror-when-creating-label</a></li><li><a href="https://gluonhq.com/products/javafx/" target="_blank" rel="noopener">https://gluonhq.com/products/javafx/</a></li></ul><h2 id="pom依赖"><a href="#pom依赖" class="headerlink" title="pom依赖"></a>pom依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjfx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javafx-controls<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjfx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javafx-fxml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="idea设置"><a href="#idea设置" class="headerlink" title="idea设置"></a>idea设置</h3><blockquote><p>下载javafx版本，然后引入依赖。项目lib中引入。启动的时候在vm中添加启动参数</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--module-path</span><br><span class="line"><span class="meta">/Users/$</span><span class="bash">USER/word/libhome/javafx-sdk-11.0.2/lib</span></span><br><span class="line">--add-modules</span><br><span class="line">javafx.controls</span><br><span class="line">--add-modules</span><br><span class="line">javafx.base</span><br><span class="line">--add-modules</span><br><span class="line">javafx.graphics</span><br><span class="line">--add-modules</span><br><span class="line">javafx.fxml</span><br><span class="line">--add-modules</span><br><span class="line">javafx.media</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;OpenJdk 11 环境下JavaFx开发环境设置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.coder.work/article/884639&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.cn/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="openJdk11" scheme="https://z201.cn/tags/openJdk11/"/>
    
  </entry>
  
  <entry>
    <title>Mac使用Jenv管理多版本Jdk</title>
    <link href="https://z201.cn/2021/02/15/Mac%E4%BD%BF%E7%94%A8Jenv%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%ACJdk/"/>
    <id>https://z201.cn/2021/02/15/Mac%E4%BD%BF%E7%94%A8Jenv%E7%AE%A1%E7%90%86%E5%A4%9A%E7%89%88%E6%9C%ACJdk/</id>
    <published>2021-02-14T17:09:36.000Z</published>
    <updated>2021-09-21T14:50:27.796Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单记录下mac下多版本jdk管理 </p></blockquote><ul><li><a href="https://adoptopenjdk.net/" target="_blank" rel="noopener">https://adoptopenjdk.net/</a></li><li><a href="https://www.jianshu.com/p/1a147d5515f0" target="_blank" rel="noopener">https://www.jianshu.com/p/1a147d5515f0</a></li></ul><h2 id="检查环境"><a href="#检查环境" class="headerlink" title="检查环境"></a>检查环境</h2><h3 id="查看当前安装的jdk版本"><a href="#查看当前安装的jdk版本" class="headerlink" title="查看当前安装的jdk版本"></a>查看当前安装的jdk版本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/java_home -V</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果有安装过jdk版本这里会输出信息</span></span><br></pre></td></tr></table></figure><h3 id="使用brew-安装jenv"><a href="#使用brew-安装jenv" class="headerlink" title="使用brew 安装jenv"></a>使用brew 安装jenv</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew install jenv</span><br><span class="line"><span class="meta">#</span><span class="bash">检查</span></span><br><span class="line">jenv doctor </span><br><span class="line"><span class="meta">#</span><span class="bash"> 刚安装会提示很多信息</span></span><br></pre></td></tr></table></figure><h3 id="初始化jenv"><a href="#初始化jenv" class="headerlink" title="初始化jenv"></a>初始化jenv</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install jenv</span><br><span class="line">jenv init -</span><br><span class="line">echo 'eval "$(jenv init -)"' &gt;&gt; ~/.bash_profile</span><br><span class="line">echo 'eval "$(jenv init -)"' &gt;&gt; ~/.zprofile</span><br><span class="line">jenv add &lt;path-to-java8-Home-Dir&gt; # 这里从/usr/libexec/java_home -V 获取javaHome</span><br></pre></td></tr></table></figure><h3 id="切换jdk"><a href="#切换jdk" class="headerlink" title="切换jdk"></a>切换jdk</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ jenv versions</span><br><span class="line">* system (set by /Users/zengqingfeng/.jenv/version)</span><br><span class="line">  1.8</span><br><span class="line">  1.8.0.275</span><br><span class="line">  openjdk64-1.8.0.275</span><br><span class="line">  </span><br><span class="line">➜  ~ jenv local system # 切换版本</span><br></pre></td></tr></table></figure><h3 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h3><ul><li>使用 jenv 过程可能会发现，当切换 JDK 版本之后， <code>${JAVA_HOME}</code> 环境变量没有改变，还是上一个 JDK 版本配置。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这时可以运行 exec $SHELL -l ， $&#123;JAVA_HOME&#125; 将会变成当前版本。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;简单记录下mac下多版本jdk管理 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://adoptopenjdk.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ado
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.cn/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="openJdk11" scheme="https://z201.cn/tags/openJdk11/"/>
    
      <category term="jenv" scheme="https://z201.cn/tags/jenv/"/>
    
  </entry>
  
  <entry>
    <title>查缺补漏-网络协议</title>
    <link href="https://z201.cn/2021/01/02/%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>https://z201.cn/2021/01/02/%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-01-01T16:00:01.000Z</published>
    <updated>2021-12-13T10:24:55.282Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章是整理知识内容，为强化知识长期更新。</p></blockquote><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><blockquote><p>网络协议是一组确定的规则，这些规则确定如何在同一网络中的不同设备之间传输数据。本质上，它允许连接的设备彼此通信，而不管其内部过程，结构或设计是否有差异。（两个端点都需要了解协议才能进行交流）。</p></blockquote><h3 id="OSI网络模型"><a href="#OSI网络模型" class="headerlink" title="OSI网络模型"></a>OSI网络模型</h3><blockquote><p>OSI英文全称叫做(Open System Interconnection Model). 中文全称叫做开放式系统互联模型. 也叫做网络7层模型，从下到上依次为，物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。</p></blockquote><ul><li>OIS概念模型<strong>实际上并没有真正实现过，但是我们需要参考这个分层来理解网络协议</strong>一般来说把5-7层叫做上层，1-4层叫做下层。</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211123214245.png"></p><ul><li>7-应用层 -&gt; 网络流程应用（表示的是用户界面，例如Telnet，HTTP、FTP、TFTP、SMTP、SNMP、DNS、TELNET、HTTPS、POP3、DHCP）</li><li>6-表示层 -&gt; 数据表示 (数据如何呈现，特殊处理-&gt;例如加密，比如JPEG、ASCLL、EBCDIC、加密格式等）</li><li>5-会话层 -&gt; 主机间的通信（将不同应用程序的数据分开。建立，管理和终止应用之间的会话）</li><li>4-传输层 -&gt; 端到端连接（可靠或不可靠的传递，例如TCP，UDP)</li><li>3-网络层 -&gt; 地址和最佳路径（提供路由器用于路径的逻辑寻址，比如ICMP IGMP IP(IPV4 IPV6)）</li><li>2-数据链路层 -&gt; 媒体访问（将位组合成字节，将字节组合成帧，使用MAC地址访问，错误检测-比如HDLC）</li><li>1-物理层 -&gt; 二进制传输（在设备之间移动bits。例如V.35）</li></ul><h3 id="TCP-IP网络模型"><a href="#TCP-IP网络模型" class="headerlink" title="TCP/IP网络模型"></a>TCP/IP网络模型</h3><blockquote><p>TCP/IP 模型和OSI相比会简单一点，只有四层，分别为数据链路层，网络层，传输层和应用层。</p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211123214318.png"></p><h3 id="OSI模型与TCP-IP模型"><a href="#OSI模型与TCP-IP模型" class="headerlink" title="OSI模型与TCP/IP模型"></a>OSI模型与TCP/IP模型</h3><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211123215305.png"></p><ul><li>4-应用层 -&gt; 对应于OSI的5-7层</li><li>3-传输层 -&gt; 这个是和OSI的第四层想同的</li><li>2-网络层 -&gt; 这个是和OSI的第3网络层对应的</li><li>1-网络访问层 -&gt; 这个是和OSI的第1-2层所对应的</li></ul><a id="more"></a><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><blockquote><p>TCP/IP的前身APPA:NCP协议。</p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211123220629.png"></p><ul><li>TCP：<strong>面向连接的、可靠的、拥塞控制、基于字节流的、有状态服务</strong>传输层通信协议。</li><li>UDP：<strong>面向无连接、基于数据包、无状态服务</strong></li><li>IP：根据IP地址穿透网络传输数据。</li></ul><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><blockquote><p>TCP的全称是Transmission Control Protocol，在IP协议之上，解决网络通信可依赖的问题。TCP基本上被以上大多数的协议所使用。</p></blockquote><ul><li><strong>面向连接</strong>，也就是建立连接。为了客户端与服务端维护的连接，而建立一定的数据结构维护互相交互的状态。通过这种数据结构来保证所谓的面相连接的特性。</li><li><strong>可靠性</strong>，通过TCP连接传输的数据，无差错、不丢失、不重复、按顺序到达。使用校验、确认和重传机制来保证可靠传输。</li><li><strong>阻塞控制</strong>，TCP自己决定何时停止和发送数据。</li><li><strong>基于字节流</strong>，发送的时候是一个流，没头没尾，消息是<strong>有序</strong>的，会对<strong>重复</strong>的消息丢弃。</li><li><strong>状态服务</strong>，自身维护了状态</li></ul><h5 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h5><blockquote><p>TCP报文中有端口相关信息，穿插下。端口号的范围从0到65535，通过端口号被分为三个不同的类别。</p></blockquote><ul><li>公认端口（Well-Known）0-1023 是经过实践检验的协议，所以称为公认端口。诸如Http使用端口80，https使用443<ul><li>HTTP - 80</li><li>HTTPS - 443</li><li>FTP - 20,21</li><li>SSH - 22</li><li>Telnet - 23</li></ul></li><li>注册端口（Registered）1024-49151</li><li>临时端口（Ephemeral）49152-65535</li></ul><h5 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h5><blockquote><p>TCP 报文是 TCP 层传输的数据单元，也称为报文段。TCP 报文中每个字段如图所示。</p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211123230635.png"></p><h5 id="报文字段含义"><a href="#报文字段含义" class="headerlink" title="报文字段含义"></a>报文字段含义</h5><blockquote><p>固定首部长度为20字节,可变部分0~40字节</p></blockquote><ul><li><p><em>Source Prot</em> 源端口 16bit 范围 0 ~ 56625</p></li><li><p><em>Destination Port</em> 目标端口 16bit 范围 0 ~ 56625</p></li><li><p><em>Sequence Number</em> 序列号字段 32bit </p><ul><li>它表示本报文段所发送数据的第一个字节的编号。在 TCP 连接中，所传送的字节流的每一个字节都会按顺序编号。当SYN标记不为1时，这是当前数据分段第一个字母的序列号；如果SYN的值是1时，这个字段的值就是初始序列值（ISN），用于对序列号进行同步。这时，第一个字节的序列号比这个字段的值大1，也就是ISN加1。<strong>解决网络包乱序问题</strong></li></ul></li><li><p><em>Acknowledgment Number，ACK Number</em>  确认号字段</p><ul><li>TCP 确认号（Acknowledgment Number，ACK Number）：占 32 位。它表示接收方期望收到发送方下一个报文段的第一个字节数据的编号。其值是接收计算机即将接收到的下一个序列号，也就是下一个接收到的字节的序列号加1。<strong>解决网络不丢包问题</strong></li></ul></li><li><p><em>Header Length</em> 数据偏移字段 </p><ul><li>TCP 首部长度（Header Length）：数据偏移是指数据段中的“数据”部分起始处距离 TCP 数据段起始处的字节偏移量，占 4 位。其实这里的“数据偏移”也是在确定 TCP 数据段头部分的长度，告诉接收端的应用程序，数据从何处开始。</li></ul></li><li><p><em>Reserved</em> 保留字段 4bit 为 TCP 将来的发展预留空间，目前必须全部为 0。</p></li><li><p>标志位字段</p><blockquote><p>SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN结束连接。注意这几个标志位。</p></blockquote><ul><li>CWR（Congestion Window Reduce）：拥塞窗口减少标志，用来表明它接收到了设置 ECE 标志的 TCP 包。并且，发送方收到消息之后，通过减小发送窗口的大小来降低发送速率。</li><li>ECE（ECN Echo）：用来在 TCP 三次握手时表明一个 TCP 端是具备 ECN 功能的。在数据传输过程中，它也用来表明接收到的 TCP 包的 IP 头部的 ECN 被设置为 11，即网络线路拥堵。</li><li>URG（Urgent）：表示本报文段中发送的数据是否包含紧急数据。URG=1 时表示有紧急数据。当 URG=1 时，后面的紧急指针字段才有效。</li><li><strong>ACK</strong>：表示前面的确认号字段是否有效。ACK=1 时表示有效。只有当 ACK=1 时，前面的确认号字段才有效。TCP 规定，连接建立后，ACK 必须为 1。</li><li>PSH（Push）：告诉对方收到该报文段后是否立即把数据推送给上层。如果值为 1，表示应当立即把数据提交给上层，而不是缓存起来。</li><li><strong>RST</strong>：表示是否重置连接。如果 RST=1，说明 TCP 连接出现了严重错误（如主机崩溃），必须释放连接，然后再重新建立连接。</li><li><strong>SYN</strong>：在建立连接时使用，用来同步序号。当 SYN=1，ACK=0 时，表示这是一个请求建立连接的报文段；当 SYN=1，ACK=1 时，表示对方同意建立连接。SYN=1 时，说明这是一个请求建立连接或同意建立连接的报文。只有在前两次握手中 SYN 才为 1。</li><li><strong>FIN</strong>：标记数据是否发送完毕。如果 FIN=1，表示数据已经发送完成，当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位置为 1 的 TCP 段。</li></ul></li><li><p><em>Window Size</em> 窗口大小字段 16bit </p><ul><li>它表示从 Ack Number 开始还可以接收多少字节的数据量，也表示当前接收端的接收窗口还有多少剩余空间。该字段可以用于 <strong>TCP 的流量控制</strong>。</li></ul></li><li><p><em>TCP Checksum</em> TCP 校验字段 16bit</p><ul><li>它用于<strong>确认传输的数据是否有损坏</strong>。发送端基于数据内容校验生成一个数值，接收端根据接收的数据校验生成一个值。两个值必须相同，才能证明数据是有效的。如果两个值不同，则丢掉这个数据包。Checksum 是根据伪头 + TCP 头 + TCP 数据三部分进行计算的。</li></ul></li><li><p><em>Urgent Pointer</em> 紧急指针字段 </p><ul><li>仅当前面的 URG 控制位为 1 时才有意义。它指出本数据段中为紧急数据的字节数，占 16 位。当所有紧急数据处理完后，TCP 就会告诉应用程序恢复到正常操作。即使当前窗口大小为 0，也是可以发送紧急数据的，因为紧急数据无须缓存。</li></ul></li><li><p><em>Option</em> 可选项字段</p><ul><li>长度不定，但长度必须是 32bits 的整数倍。</li></ul></li></ul><h5 id="TCP状态"><a href="#TCP状态" class="headerlink" title="TCP状态"></a>TCP状态</h5><blockquote><p>TCP的状态变迁图更细致的描述了TCP连接建立和连接终止中的各个状态</p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211123232928.png"></p><h5 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h5><blockquote><p>握手的主要行为 SYN 同步 ACK 确认 </p><ol><li><p>同步Sequence序列号，初始化序列号ISN（Inital Sequence Number）</p></li><li><p>交换TCP通讯参数，比如MSS、窗口比例因子、选择性确认、指定校验算法</p></li><li><p>防止失效的连接请求访问到服务器端，让服务器误认为要建立连接。</p></li></ol></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211208200222.png"></p><ul><li><p>过程</p><ul><li>Client 发送 自身的SYN 到 Server ，并包含初始化序列号</li><li>Server 发送一个 SYN 和 ACK 在同一个报文中 给Client  ， </li><li>Client 发送一个 ACK 给 Server</li></ul></li><li><p>实践过程</p><ul><li>准备一台linxu Centos 且安装好 tcpdump </li><li><code>yum install tcpdump</code></li><li><code>tcpdump -i eth0 -w out_3.pcap tcp port 80 -c 3 -S</code>  监听eth0网卡、将内容输出到out_3.pacp 方便 Wireshark 分析 、监听tcp 协议 端口 80 只保留前3个包，用绝对序列号代替相对序列化。在客户端使用 curl命令访问对于服务即可。</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211203154224.png"></p><ul><li>第一次握手客户端发送自身序列号 2883770579 并且 将 syn 设置为 1  </li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211203155019.png"></p><pre><code>- 第二次握手 将 syn设置为 1 、ack 设置为 1， 并且返回确认报文ack 2883770579 + 1 = 2883770580 。</code></pre><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211203155507.png"></p><ul><li>第三次握手 将ACK设置成1 ， 确认报文ack 2054592687 + 1 = 2054592689 。</li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211208200251.png"></p></li></ul><h5 id="四次挥手关闭连接"><a href="#四次挥手关闭连接" class="headerlink" title="四次挥手关闭连接"></a>四次挥手关闭连接</h5><blockquote><p>TCP是全双工的，且存在半关闭(half-close)状态的存在，所以终止TCP协议需要4次握手。连接双方都需要关闭连接。</p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211203152951.png"></p><ul><li><p>过程</p><ul><li>Clinet 发送自身 FIN M到 Server </li><li>Server 发送一个ACK 切 M + 1 给 Client</li><li>Server 发送 FIN N 到 Client </li><li>Client 发送 ACK N + 1 到 Server</li></ul></li><li><p>实践过程</p><ul><li><code>tcpdump -i eth0 -w out_3.pcap tcp port 80  -S</code></li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211203165015.png"></p><ul><li>不知道为什么不是四次，在客户端发送完请求后，不会立刻关闭连接，仍然处于establish状态，短连接会经过fin-wait1 fin wait2 time_wait</li></ul></li></ul><h5 id="MSS分段"><a href="#MSS分段" class="headerlink" title="MSS分段"></a>MSS分段</h5><blockquote><p>客户端与服务器之间的通信是一个数据传输过程。通信的消息将以数据包形式进行传输。TCP 协议在数据进行数据传输时，使用滑动窗口机制来同时发送多个数据包。当数据包丢失时，TCP 协议利用数据重发功能重新发送数据包。因接收端接收数据包的能力不同，TCP 流控制会根据接收端的能力发送适当数量的数据包。</p></blockquote><ul><li>数据分片<ul><li>数据在传输的过程中，会经过很多的物理设备，这些设备处理的数据都有一些限制，因此在发送数据都是好不能超过最大的字节数。这个最大的字节数就是（Maximum Segment Size，MSS）。当要发送的数据超过该值的时候，就需要将数据拆分为多个包，依次发送。</li></ul></li></ul><h5 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h5><h5 id="TCP阻塞控制"><a href="#TCP阻塞控制" class="headerlink" title="TCP阻塞控制"></a>TCP阻塞控制</h5><h5 id="TCP的RST"><a href="#TCP的RST" class="headerlink" title="TCP的RST"></a>TCP的RST</h5><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><blockquote><p>DNS,SNMP和TFTP都是使用UDP，实际上DNS和SNMP既可以使用TCP也可以使用UDP。相比TCP，UDP提供了效率，TCP在使用过程中有太多的开销，实际上并不是所有的场景都需要TCP可靠的通信机制，比如DNS</p></blockquote><ul><li><strong>无连接</strong> 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务</li><li>协议真的非常简洁，头部只有 <code>8</code> 个字节（ 64 位）</li></ul><h5 id="UDP报文格式"><a href="#UDP报文格式" class="headerlink" title="UDP报文格式"></a>UDP报文格式</h5><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211124012658.png"></p><h5 id="报文字段含义-1"><a href="#报文字段含义-1" class="headerlink" title="报文字段含义"></a>报文字段含义</h5><ul><li><em>Source Prot</em> 源端口 16bit 范围 0 ~ 56625</li><li><em>Destination Port</em> 目标端口 16bit 范围 0 ~ 56625</li><li><em>Length</em> 长度 16bit 表示 UDP 数据报长度，包含 UDP 报文头和 UDP 数据长度。因为 UDP 报文头长度是 8 个字节，所以这个值最小为 8。</li><li><em>checksum</em> 校验值 16bit 可以检验数据在传输过程中是否被损坏。</li></ul><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><blockquote><p>IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。</p></blockquote><ul><li>无连接、非可靠、无确认。</li><li>IP协议提供了一种分层、与硬件无关的寻址系统，它可以在复杂的路由式网络中传输数据服务。</li><li>IP协议可以将多个网络连接起来，在源地址和目的地址之间传输数据，以适应不同网络对数据包的要求。</li></ul><h3 id="HTTP-HTTPS"><a href="#HTTP-HTTPS" class="headerlink" title="HTTP/HTTPS"></a>HTTP/HTTPS</h3><blockquote><p>HTTP 就是超文本传输协议，也就是 HyperText Transfer Protocol。HTTP over SSL/TLS 也就是运行在 SSL/TLS 协议上的 HTTP。</p></blockquote><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211206141044.png"></p><ul><li><p>HTTP重要里程碑的时间点</p><ul><li>Http0.9 -&gt; 1991</li></ul></li><li><p>Http1.0 -&gt;1996</p><ul><li>Http 1.1 -&gt; 1999</li></ul></li><li><p>Http2 -&gt; 2015</p></li><li><p>HTML 超文本标记语言</p></li></ul><h4 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h4><blockquote><p>1995 年，网景的 Netscape Navigator 和微软的 Internet Explorer 开始了著名的“浏览器大战”，都希望在互联网上占据主导地位。</p></blockquote><h4 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h4><blockquote><p>HTTP/2 基于 Google 的 SPDY 协议，注重性能改善。</p></blockquote><h4 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h4><blockquote><p>HTTP/3 基于 Google 的 QUIC 协议，是将来的发展方向。</p></blockquote><h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><blockquote><p>Http Proxy是Http协议中的一个环节，中转站可以转发客户端请求也可以转发服务端应答。</p></blockquote><ul><li>匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器。</li><li>透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端。</li><li>正向代理：靠近客户端，代表客户端向服务器发送请求。</li><li>反向代理：靠近服务器端，代表服务器响应客户端的请求。</li></ul><h4 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h4><blockquote><p><em>TLS</em> 是<em>SSL</em> 的改良版本</p></blockquote><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="描述下GET与POST的区别。"><a href="#描述下GET与POST的区别。" class="headerlink" title="描述下GET与POST的区别。"></a>描述下GET与POST的区别。</h4><ul><li>GET和POST是HTTP请求的两种基本方法。<ul><li>GET：特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。理论上没有长度限制，其限制取决于操作系 统的支持。所以GET提交时，传输数据就会受到URL长度的限制。</li><li>POST：由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制。</li></ul></li><li>GET和POST本质上没有区别,只是在浏览器上直观体现方式不同。GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</li><li>GET产生一个TCP数据包;POST产生两个TCP数据包。<ul><li>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据);</li><li>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</li><li>在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点，一般的浏览POST会发送两次，但是Firefox就发送一次。</li></ul></li><li>安全性<ul><li>在没有加密的情况安全性是一样的,在浏览器调试模式下可以看到所有数据的。</li></ul></li></ul><h4 id="描述下HTTP-Cookie。"><a href="#描述下HTTP-Cookie。" class="headerlink" title="描述下HTTP Cookie。"></a>描述下HTTP Cookie。</h4><ul><li>一个cookie就是存储在用户主机浏览器中的一小段文本文件。Cookies是纯文本形式，它们不包含任何可执行代码。一个Web页面或服务器告之浏览器来将这些信息存储并且基于一系列规则在之后的每个请求中都将该信息返回至服务器。Web服务器之后可以利用这些信息来标识用户。多数需要登录的站点通常会在你的认证信息通过后来设置一个cookie，之后只要这个cookie存在并且合法，就可以自由的浏览这个站点的所有部分。再次，cookie只是包含了数据。在后续的http 请求中，浏览器会将cookie带回给Web Server。同时在浏览器允许脚本执行的情况下，Cookie是可以被JavaScript等脚本设置的。</li><li>Cookie的类别。<ul><li>Session Cookie这个类型的cookie只在会话期间内有效，即当关闭浏览器的时候，它会被浏览器删除。设置session cookie的办法是：在创建cookie不设置Expires即可。</li><li>Persistent Cookie持久型cookie顾名思义就是会长期在用户会话中生效。当你设置cookie的属性Max-Age为1个月的话，那么在这个月里每个相关URL的http请求中都会带有这个cookie。所以它可以记录很多用户初始化或自定义化的信息，比如什么时候第一次登录及弱登录态等。</li><li>Secure cookie安全cookie是在https访问下的cookie形态，以确保cookie在从客户端传递到Server的过程中始终加密的。但是必须是在HTTPS的情况才有效果。</li><li>HttpOnly 属性，这个数据设置为true后，客户端通过JS是无法获取到cookie信息的（暂时的）。</li></ul></li></ul><h4 id="描述下Servlet-Cookie-与Session。"><a href="#描述下Servlet-Cookie-与Session。" class="headerlink" title="描述下Servlet Cookie 与Session。"></a>描述下Servlet Cookie 与Session。</h4><ul><li><p>具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。</p><ul><li>服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的。</li></ul></li><li><p>Session是以cookie为基础的。在一些web开发的书中，往往只是简单的把Session和cookie作为两种并列的http传送信息的方式，session cookies位于服务器端，persistent cookie位于客户端。</p></li></ul><ul><li>Cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗考虑到安全应当使用session。</li><li>Session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。</li><li>单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li><li>关闭浏览器不会导致服务端session被删除，服务器为session设置了一个失效时间，当距离客户上一次使用session的时间超过了这个失效时间时，服务器就可以认为客户端已经停止了活动，才会把session删除以节省存储空间。</li><li>关闭浏览器，只会是浏览器端内存里的session cookie消失，但不会使保存在服务器端的session对象消失，同样也不会使已经保存到硬盘上的持久化cookie消失。</li></ul><h4 id="URI与URL的区别"><a href="#URI与URL的区别" class="headerlink" title="URI与URL的区别"></a>URI与URL的区别</h4><h5 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h5><ul><li>RFC1738 (1994.12) Uniform Resource Locator 表示资源的位置，期望提提供查找资源的方法。</li><li>它是可以对互联网上资源位置访问方式对一种简洁表达。通常的表现格式如下。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scheme://host[:port<span class="comment">#]/path/…/[;url-params][?query-string][#anchor]</span></span><br><span class="line"></span><br><span class="line">scheme //有我们很熟悉的http、https、ftp以及著名的ed2k，迅雷的thunder等。</span><br><span class="line">host   //HTTP服务器的IP地址或者域名</span><br><span class="line">port<span class="comment">#  //HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，</span></span><br><span class="line">例如tomcat的默认端口是8080  http://localhost:8080/</span><br><span class="line">path   //访问资源的路径</span><br><span class="line">url-params  //所带参数 </span><br><span class="line">query-string    //发送给http服务器的数据</span><br><span class="line">anchor //锚点定位</span><br></pre></td></tr></table></figure><h5 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h5><ul><li>RFC2141 (1997.5) Uniform Resource Name ，资源映射名称。比如</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mailto: xxxxx@qq.com</span><br></pre></td></tr></table></figure><h5 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h5><ul><li>RFC1630 (1994.6) Uniform Resource Identifier 用于区分资源 , 是 URL 和 URN 的超集，用于取代URL 和 URN概念。</li><li>URI 属于父类，而 URL 属于 URI 的子类。URL 是 URI 的一个子集。<strong>URI：统一资源标识 URL：统一资源定位 URN：统一资源名称。</strong></li></ul><p><img src="https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211123132409.png"></p><h4 id="TCP安全问题"><a href="#TCP安全问题" class="headerlink" title="TCP安全问题"></a>TCP安全问题</h4><h5 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h5><blockquote><p>在三次握手过程中，服务端收到SYN-ACK之后，收到客户端的ACK之前TCP连接成为半连接(half-open connect) ，这个时候服务器处于SYN_REVD状态，收到ACK之后服务器才能转入ESTABLISHED状态。</p></blockquote><ul><li>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</li></ul><h5 id="SYN检测"><a href="#SYN检测" class="headerlink" title="SYN检测"></a>SYN检测</h5><ul><li>在Linux/Unix上可以使用系统自带的netstats命令来检测SYN攻击。</li></ul><h5 id="SYN攻击防范"><a href="#SYN攻击防范" class="headerlink" title="SYN攻击防范"></a>SYN攻击防范</h5><h6 id="设置超时时间与缓存列队。"><a href="#设置超时时间与缓存列队。" class="headerlink" title="设置超时时间与缓存列队。"></a>设置超时时间与缓存列队。</h6><ul><li><p>应用层connect超时时间调整。</p></li><li><p>操作系统内核限制调整。</p><ul><li>服务器端SYN_RCV状态</li><li>net.ipv4.tcp_max_syn_backlog:  SYN_RCVD状态的最大连接数。</li><li>net.ipv4.tcp_synack_retries: 被动建立时,发SYN/ACK的重试次数。</li><li>客户端SYN_SENT状态</li><li>net.ipv4.tcp_syn_retries = 6 主动建立连接时，发SYN的重试次数。</li><li>net.ipv4.ip_local_port_range = 32768 60999 建立连接时的本地端口可用范围。</li><li>ACCEPT列队设置</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本章是整理知识内容，为强化知识长期更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;网络协议&quot;&gt;&lt;a href=&quot;#网络协议&quot; class=&quot;headerlink&quot; title=&quot;网络协议&quot;&gt;&lt;/a&gt;网络协议&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;网络协议是一组确定的规则，这些规则确定如何在同一网络中的不同设备之间传输数据。本质上，它允许连接的设备彼此通信，而不管其内部过程，结构或设计是否有差异。（两个端点都需要了解协议才能进行交流）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;OSI网络模型&quot;&gt;&lt;a href=&quot;#OSI网络模型&quot; class=&quot;headerlink&quot; title=&quot;OSI网络模型&quot;&gt;&lt;/a&gt;OSI网络模型&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;OSI英文全称叫做(Open System Interconnection Model). 中文全称叫做开放式系统互联模型. 也叫做网络7层模型，从下到上依次为，物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;OIS概念模型&lt;strong&gt;实际上并没有真正实现过，但是我们需要参考这个分层来理解网络协议&lt;/strong&gt;一般来说把5-7层叫做上层，1-4层叫做下层。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211123214245.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;7-应用层 -&amp;gt; 网络流程应用（表示的是用户界面，例如Telnet，HTTP、FTP、TFTP、SMTP、SNMP、DNS、TELNET、HTTPS、POP3、DHCP）&lt;/li&gt;
&lt;li&gt;6-表示层 -&amp;gt; 数据表示 (数据如何呈现，特殊处理-&amp;gt;例如加密，比如JPEG、ASCLL、EBCDIC、加密格式等）&lt;/li&gt;
&lt;li&gt;5-会话层 -&amp;gt; 主机间的通信（将不同应用程序的数据分开。建立，管理和终止应用之间的会话）&lt;/li&gt;
&lt;li&gt;4-传输层 -&amp;gt; 端到端连接（可靠或不可靠的传递，例如TCP，UDP)&lt;/li&gt;
&lt;li&gt;3-网络层 -&amp;gt; 地址和最佳路径（提供路由器用于路径的逻辑寻址，比如ICMP IGMP IP(IPV4 IPV6)）&lt;/li&gt;
&lt;li&gt;2-数据链路层 -&amp;gt; 媒体访问（将位组合成字节，将字节组合成帧，使用MAC地址访问，错误检测-比如HDLC）&lt;/li&gt;
&lt;li&gt;1-物理层 -&amp;gt; 二进制传输（在设备之间移动bits。例如V.35）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;TCP-IP网络模型&quot;&gt;&lt;a href=&quot;#TCP-IP网络模型&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP网络模型&quot;&gt;&lt;/a&gt;TCP/IP网络模型&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;TCP/IP 模型和OSI相比会简单一点，只有四层，分别为数据链路层，网络层，传输层和应用层。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211123214318.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;OSI模型与TCP-IP模型&quot;&gt;&lt;a href=&quot;#OSI模型与TCP-IP模型&quot; class=&quot;headerlink&quot; title=&quot;OSI模型与TCP/IP模型&quot;&gt;&lt;/a&gt;OSI模型与TCP/IP模型&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://z201.oss-cn-shanghai.aliyuncs.com/JavaNote/20211123215305.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4-应用层 -&amp;gt; 对应于OSI的5-7层&lt;/li&gt;
&lt;li&gt;3-传输层 -&amp;gt; 这个是和OSI的第四层想同的&lt;/li&gt;
&lt;li&gt;2-网络层 -&amp;gt; 这个是和OSI的第3网络层对应的&lt;/li&gt;
&lt;li&gt;1-网络访问层 -&amp;gt; 这个是和OSI的第1-2层所对应的&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="知识点" scheme="https://z201.cn/categories/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
      <category term="Http" scheme="https://z201.cn/tags/Http/"/>
    
      <category term="Tcp" scheme="https://z201.cn/tags/Tcp/"/>
    
      <category term="Udp" scheme="https://z201.cn/tags/Udp/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础（四）</title>
    <link href="https://z201.cn/2020/12/29/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://z201.cn/2020/12/29/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2020-12-29T01:43:58.000Z</published>
    <updated>2021-11-24T10:25:05.937Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章是整理知识内容，为强化知识长期更新。</p></blockquote><h2 id="练手项目"><a href="#练手项目" class="headerlink" title="练手项目"></a>练手项目</h2><h3 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h3><h4 id="准备一个mysql-5-7的数据库"><a href="#准备一个mysql-5-7的数据库" class="headerlink" title="准备一个mysql 5.7的数据库"></a>准备一个mysql 5.7的数据库</h4><h4 id="配置本地数据库"><a href="#配置本地数据库" class="headerlink" title="配置本地数据库"></a>配置本地数据库</h4><ul><li><p><a href="https://launchpad.net/test-db/employees-db-1/1.0.6" target="_blank" rel="noopener">https://launchpad.net/test-db/employees-db-1/1.0.6</a> 下载文件 <strong>employees_db-full-1.0.6.tar.bz2</strong></p></li><li><p>解压文件</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">➜  employees_db tree </span><br><span class="line">.</span><br><span class="line">├── Changelog</span><br><span class="line">├── README</span><br><span class="line">├── employees.sql</span><br><span class="line">├── employees_partitioned.sql</span><br><span class="line">├── employees_partitioned2.sql</span><br><span class="line">├── employees_partitioned3.sql</span><br><span class="line">├── load_departments.dump</span><br><span class="line">├── load_dept_emp.dump</span><br><span class="line">├── load_dept_manager.dump</span><br><span class="line">├── load_employees.dump</span><br><span class="line">├── load_salaries.dump</span><br><span class="line">├── load_titles.dump</span><br><span class="line">├── objects.sql</span><br><span class="line">├── test_employees_md5.sql</span><br><span class="line">└── test_employees_sha.sql</span><br></pre></td></tr></table></figure><ul><li>在将文件导入数据库</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p -t &lt; employees.sql</span><br></pre></td></tr></table></figure><h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><ul><li>employees.sql 修改内容</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 38行 set storage_engine = InnoDB; 替换</span></span><br><span class="line"><span class="keyword">set</span> default_storage_engine = <span class="keyword">InnoDB</span>;</span><br><span class="line"><span class="comment"># 44行 select CONCAT('storage engine: ', @@storage_engine) as INFO; 替换</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">CONCAT</span>(<span class="string">'storage engine: '</span>, @@default_storage_engine) <span class="keyword">as</span> INFO;</span><br></pre></td></tr></table></figure><ul><li>注意导入的时候会出现文件打不开的问题</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">'LOADING departments'</span> <span class="keyword">as</span> <span class="string">'INFO'</span>;</span><br><span class="line">source /home/employees_db/load_departments.dump ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">'LOADING employees'</span> <span class="keyword">as</span> <span class="string">'INFO'</span>;</span><br><span class="line">source /home/employees_db/load_employees.dump ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">'LOADING dept_emp'</span> <span class="keyword">as</span> <span class="string">'INFO'</span>;</span><br><span class="line">source /home/employees_db/load_dept_emp.dump ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">'LOADING dept_manager'</span> <span class="keyword">as</span> <span class="string">'INFO'</span>;</span><br><span class="line">source /home/employees_db/load_dept_manager.dump ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">'LOADING titles'</span> <span class="keyword">as</span> <span class="string">'INFO'</span>;</span><br><span class="line">source /home/employees_db/load_titles.dump ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">'LOADING salaries'</span> <span class="keyword">as</span> <span class="string">'INFO'</span>;</span><br><span class="line">source /home/employees_db/load_salaries.dump ;</span><br></pre></td></tr></table></figure><ul><li><p>这里要将文件正确的路径写进去。</p></li><li><p>如果是本地的docker环境部署mysql，可以使用docker cp 命令将文件复制到容器中。在登陆到容器执行导入脚本</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 从宿主机器拷贝到容器中</span><br><span class="line">docker cp ~/Downloads/employees_db laughing_black:/home</span><br><span class="line">// laughing_black 是容器的名称</span><br><span class="line"></span><br><span class="line">// 从容器中拷贝会宿主机器中</span><br><span class="line">docker cp laughing_black:/employees_db.sql .</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本章是整理知识内容，为强化知识长期更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;练手项目&quot;&gt;&lt;a href=&quot;#练手项目&quot; class=&quot;headerlink&quot; title=&quot;练手项目&quot;&gt;&lt;/a&gt;练手项目&lt;/h2&gt;&lt;h3 id=&quot;牛客
      
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.cn/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="MySQL" scheme="https://z201.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Tcpdump入门</title>
    <link href="https://z201.cn/2020/12/20/Tcpdump%E5%85%A5%E9%97%A8/"/>
    <id>https://z201.cn/2020/12/20/Tcpdump%E5%85%A5%E9%97%A8/</id>
    <published>2020-12-20T13:30:25.000Z</published>
    <updated>2021-12-20T17:12:02.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><blockquote><p>dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install tcpdump</span><br><span class="line">[root@~]<span class="comment"># tcpdump --v</span></span><br><span class="line">tcpdump version 4.9.2</span><br><span class="line">libpcap version 1.5.3</span><br><span class="line">OpenSSL 1.0.2k-fips  26 Jan 2017</span><br></pre></td></tr></table></figure><h4 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install tcpdump</span><br><span class="line">➜  ~ tcpdump --v</span><br><span class="line">tcpdump version 4.99.1</span><br><span class="line">libpcap version 1.10.1</span><br><span class="line">OpenSSL 1.1.1k  25 Mar 2021</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li><code>-A  </code>  以ASCII格式打印出所有分组，并将链路层的头最小化</li><li><code>-d </code>   将匹配信息包的代码以人们能够理解的汇编格式给出</li><li><code>-D </code>   打印出系统中所有可以用tcpdump截包的网络接口</li><li><code>-ddd</code>    将匹配信息包的代码以十进制的形式输出</li><li><code>-e</code>    在输出行打印出数据链路层的头部信息</li><li><code>-f  </code>  将外部的Internet地址以数字的形式打印出来</li><li><code>-l </code>   使标准输出变为缓冲行形式</li><li><code>-L</code>    列出网络接口的已知数据链路</li><li><code>-n</code>    不把网络地址转换成名字</li><li><code>-N</code>    不输出主机名中的域名部分，如“kongove.ubuntu.cn”只输出“kongove”</li><li><code>-O</code>    不运行分组分组匹配（packet-matching）代码优化程序</li><li><code>-p </code>   不将网络接口设置成混杂模式</li><li><code>-q </code>   快速输出，只输出较少的协议信息</li><li><code>-S </code>   将tcp的序列号以绝对值形式输出，而不是相对值</li><li><code>-t</code>    在输出的每一行不打印时间戳</li><li><code>-u</code>    输出未解码的NFS句柄</li><li><code>-v </code>   输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息</li><li><code>-vv </code>   输出详细的报文信息</li><li><code>-c count </code>   指定监听数据包数量，当收到指定的包的数目后，tcpdump就会停止</li><li><code>-C file_size</code>    限定数据包写入文件大小</li><li><code>-F file</code>    从指定的文件中读取表达式,忽略其它的表达式</li><li><code>-i interface</code>    指定监听网络接口</li><li><code>-m module</code>    打开指定的SMI MIB组件</li><li><code>-M secret </code>   如果tcp报文中存在TCP-MD5选项，则需要用secret作为共享的验证码用于验证TCP-MD5选选项摘要（详见RFC 2385）<br>-r file    从指定的文件中读取包(这些包一般通过-w选项产生)</li><li><code>-s snaplen</code>    从每个分组中读取最开始的snaplen个字节，而不是默认的68个字节</li><li><code>-T type </code>   将截取的数据包直接解释为指定类型的报文，常见类型有rpc（远程过程调用）和snmp（简单网络管理协议），还包括aodv、cnfp、rpc、rtp、rtcp、snmp、tftp、vat、wb等<br>-w file    指定将监听到的数据包写入文件，不分析和打印数据包</li><li><code>-W filecount </code>   限定能写入文件数据包的数量</li><li><code>-E </code>spi@ipaddr algo:secret,…    用spi@ipaddr algo:secret解密那些以addr作为地址，并且包含了安全参数索引值spi的IPsec ESP分组</li></ul><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><blockquote><p>tcpdump采用命令行方式，它的命令格式为：</p></blockquote><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump [ -adeflnNOpqStvx ] [ -c 数量 ] [ -F 文件名 ] [ -i 网络接口 ] [ -r 文件名] [ -s snaplen ]  [ -T 类型 ] [ -w 文件名 ] [表达式 ]</span><br></pre></td></tr></table></figure><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="指定运行时间"><a href="#指定运行时间" class="headerlink" title="指定运行时间"></a>指定运行时间</h4><blockquote><p>tcpdump通常都是手动运行，需要使用类似Ctrl+C都方式终结，想控制运行时间不用手动停止程序。</p></blockquote><ul><li>方法一 超时</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeout 5400 tcpdump -i eth0 <span class="string">'port 8080'</span> -w myfile</span><br></pre></td></tr></table></figure><ul><li>方法二 组合 <code>-G {sec}</code> (每 x 秒轮换转储文件)和 <code>-W {count}</code> (限制转储文件的数量),将运行 15 秒然后停止。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -G 15 -W 1 -w myfile.pcap -i eth0 <span class="string">'port 8080'</span></span><br></pre></td></tr></table></figure><h4 id="指定间隔保存"><a href="#指定间隔保存" class="headerlink" title="指定间隔保存"></a>指定间隔保存</h4><ul><li>方法一 -G 600 600s保存一次 -i 指定网卡 -s -w 保存文件的格式</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i lo -s0 -G 600  -w %Y_%m%d_%H%M_%S.pcap</span><br></pre></td></tr></table></figure><ul><li>方法二 -C 5 每5M保存一个包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i lo -s0 -C 5 -Z root -w eth0.pcap</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tcpdump&quot;&gt;&lt;a href=&quot;#tcpdump&quot; class=&quot;headerlink&quot; title=&quot;tcpdump&quot;&gt;&lt;/a&gt;tcpdump&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;h4 id=&quot;linux&quot;&gt;&lt;a href=&quot;#linux&quot; class=&quot;headerlink&quot; title=&quot;linux&quot;&gt;&lt;/a&gt;linux&lt;/h4&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum install tcpdump&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@~]&lt;span class=&quot;comment&quot;&gt;# tcpdump --v&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcpdump version 4.9.2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;libpcap version 1.5.3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OpenSSL 1.0.2k-fips  26 Jan 2017&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;Mac&quot;&gt;&lt;a href=&quot;#Mac&quot; class=&quot;headerlink&quot; title=&quot;Mac&quot;&gt;&lt;/a&gt;Mac&lt;/h4&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;brew install tcpdump&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;➜  ~ tcpdump --v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tcpdump version 4.99.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;libpcap version 1.10.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;OpenSSL 1.1.1k  25 Mar 2021&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://z201.cn/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="网络通信" scheme="https://z201.cn/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
      <category term="抓包软件" scheme="https://z201.cn/tags/%E6%8A%93%E5%8C%85%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>查缺补漏-Zookeeper</title>
    <link href="https://z201.cn/2020/12/09/%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-Zookeeper/"/>
    <id>https://z201.cn/2020/12/09/%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F-Zookeeper/</id>
    <published>2020-12-09T04:10:31.000Z</published>
    <updated>2021-12-13T14:25:21.124Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Zookeeper概述"><a href="#Zookeeper概述" class="headerlink" title="Zookeeper概述"></a>Zookeeper概述</h3><blockquote><p>Zookeeper可以让企业的IT架构逐步从集中式向分布式过度，所谓的分布式是指：把一个计算任务分解成若干个计算单元，并且分派到若干不同的计算机中去执行，然后汇总计算结果的过程。</p></blockquote><ul><li><p>Zookeeper介绍</p><ul><li>Zookeeper是源代码开放的分布式协调服务，由雅虎创建，是Google Chubby开源实现。Zookeeper是一个高性能的分布式数据一致性解决方案，它将那些复杂、容易出错的分布式一致性服务封装起来，构成一个搞笑可靠的原语集，并提供一系列简单易用的接口给用户使用。</li></ul></li><li><p>Zookeeper的典型应用场景</p><ul><li>数据发布/订阅 顾名思义就是一方把数据发布出来，另一方通过某种手动可以得到这些数据。<ul><li>通常数据订阅有两种方式：推模式和拉模式，推模式一般是服务器主动向客户端推送消息，拉模式是客户端主动去服务端获取数据（通常采用的是轮询的方式）。</li><li>Zookeeper采用两种方式的结合。<ul><li>发布者将数据发布到Zookeeper集群节点上，订阅者通过一定的方法告诉服务器，我对那个节点的数据感兴趣，那个服务器在这些节点的数据发送变化时，就通知客户端，客户端得到通知后可以去服务器获取数据信息。</li><li>分布式协调/通知<ul><li>心跳检测：在分布式系统中，通常需要机器是否可以用，Zookeeper中我们让所有的机器都注册一个临时节点，所以只需要判断这个节点是否存在就可以了，不需要直接去连接需要检查的机器，降低系统的负载度（节点分为临时和持久）。</li></ul></li></ul></li></ul></li></ul></li><li><p>Zookpeeper重量级使用</p><ul><li>Hadoop、HBase、Storm、Solr。</li></ul></li><li><p>集群角色</p><ul><li>Leader、Follower、Observer<ul><li>Leader服务器是整个Zookeeper集群工作机制的核心</li><li>Follower服务器是Zookeeper集群状态的跟随者</li><li>Oserver服务器充当一个观察者的角色</li><li>Leader、Follower设计模式，Observer观察者模式</li></ul></li></ul></li><li><p>会话</p><ul><li>会话是指客户端Zookeeper服务器的连接，Zookeeper中的会话叫Session，客户端与服务器建立TCP的长连接来维持一个Session,客户端在启动的时候首先会与服务器建立一个TCP连接,通过这个连接客户端能够通过心跳检测与服务器保持有效的会话，也能向Zookeeper服务器发送请求并获得响应。</li></ul></li><li><p>数据节点</p><ul><li>Zookeeper中的节点有两类<ul><li>集群中的一台机器称为一个节点</li><li>数据模型中的数据单元Znode，分别为持久节点和临时节点。（其实数据节点就是一个tree节点就是Znode）</li></ul></li></ul></li><li><p>版本</p><ul><li>Zookeeper中的版本<ul><li>version<ul><li>当前数据节点数据内容版本</li></ul></li><li>cversion<ul><li>当前数据节点子节点的版本号</li></ul></li><li>aversion<ul><li>当前数据节点ACL变更版本号</li></ul></li></ul></li></ul></li><li><p>watcher（事件监听器）</p><ul><li>Zookeeper允许用户在指定节点上注册一些Watcher，当数据节点发生变化的时候，Zookeeper服务器会把这个变化通知发送给感兴趣的客户端。</li></ul></li><li><p>ACL权限控制</p><ul><li>ACL是Access Contril Lists 的缩写,Zookeeper采用ACL策略来进行权限控制,有以下权限：<ul><li>CREATE：创建子节点</li><li>READ：获取子节点</li><li>WRITE:更新子节点数据权限</li><li>DELETE:删除子节点权限</li><li>ADMIN：设置节点ACL权限</li></ul></li></ul></li></ul><h3 id="Zoopeeper环境搭建（集群、单机、伪集群）"><a href="#Zoopeeper环境搭建（集群、单机、伪集群）" class="headerlink" title="Zoopeeper环境搭建（集群、单机、伪集群）"></a>Zoopeeper环境搭建（集群、单机、伪集群）</h3><ul><li>单机模式（设备环境有限暂时单机）<ul><li>准备工作<ul><li>下载Zookeeper（此处自行处理）</li><li>解压 tar xzvf xxx.gz 解压</li><li>重命名文件夹 Zookeeper 命令mv xxx xxx 后面的参数是新名字（可以不做）</li><li>进入文件夹中/conf/</li><li>复制配置文件zoo_sample.cfg（样例文件） 并重命名 zoo.cfg</li></ul></li><li>编辑zoo.cfg内容（仅供参考,具体环境自行修改）</li><li>tickTime = 2000<ul><li>tickTime：基本事件单元，以毫秒为单位。这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。</li></ul></li><li>initLimit= 5<ul><li>initLimit:这个配置项用来配置Zookeeper接受客户端初始化连接时最长能忍受多少个心跳时间间隔数，当已超过5个心跳的时间（也就是tickTime）长度后Zookeeper服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度是5 * 2000=4s。</li></ul></li><li>dataDir = D:\zookeeper\data<ul><li>顾名思义就是 Zookeeper 保存数据快照的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里）。</li></ul></li><li>dataLogDir= D:\zookeeper\log<ul><li>顾名思义就是 Zookeeper 保存日志的目录。</li></ul></li><li>synclimit = 5<ul><li>这个配置项表示Leader与Follower之间发送消息，请求和应答时间长长度，最长不能超过多少个tickTime的时间长度,总的时间长度是2 * 2000 = 4s。</li></ul></li><li>clientPort = 2181<ul><li>这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</li></ul></li><li>Server（待续）<ul><li>格式：server.id=host:port:port（两个port保证可以正常使用就行）<ul><li>id：通常为整数，并且不能重复使用整数。</li><li>host：服务器的IP地址。</li><li>port: Follower端口</li><li>port: Leader选举投票。</li></ul></li><li>ZooKeeper建议使用hostname，而非ip。这需要对主机的/etc/hostname和/etc/hosts做host绑定(不用的OS不同修改方式)。</li><li>创建一个myid文件（放在 dataDir文件下面）</li><li>写入一行数据（请查阅zoo.cfg文件）<ul><li>写入id位置的数据即可。表示当前系统环境Zookeeper是哪一个Server（通讯用的）。</li></ul></li></ul></li><li>启动服务与停止服务</li><li>进入bin/文件</li><li>执行zkServer.cmd 或则 <a href="http://zkserver.sh/" target="_blank" rel="noopener">zkServer.sh</a></li><li>CMD直接双击运行 ,SH则 sudo sh ./zkServer.sh start 启动 stop 关闭</li><li>验证 使用telnet来测试(自行安装)<ul><li>telnet ip port 敲命令 stat 若返回数据表示当前服务器不能对外提供服务表明集群下其他服务器未启动（在Zookeeper中只要有半数的服务器正常工作就可以向外提供服务）。</li></ul></li><li>在此简单说明下何为伪集群就是在一台服务器上的多个Zookeeper的集群叫伪集群（伪集群 两个port不能与其他zookeeper的port一样）。</li><li>单机模式就删除其他服务器运行的时候就是单机模式。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Zookeeper概述&quot;&gt;&lt;a href=&quot;#Zookeeper概述&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper概述&quot;&gt;&lt;/a&gt;Zookeeper概述&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Zookeeper可以让企业的IT架构逐步
      
    
    </summary>
    
    
      <category term="未分类" scheme="https://z201.cn/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker-Compose-Redis5.0+Mysql5.7</title>
    <link href="https://z201.cn/2020/11/20/Docker-Compose-Redis5-0-Mysql5-7/"/>
    <id>https://z201.cn/2020/11/20/Docker-Compose-Redis5-0-Mysql5-7/</id>
    <published>2020-11-20T07:58:13.000Z</published>
    <updated>2021-01-13T06:46:29.352Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录下使用docker-compose构建管理Redis、mysql。</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>创建工作目录</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p docker docker/mysql docker/mysql/data docker/redis docker/redis/data</span><br><span class="line"><span class="comment"># 使用 tree docker 查看目录结构 yum -y install tree 安装</span></span><br><span class="line">$ tree docker</span><br><span class="line">docker</span><br><span class="line">├── mysql</span><br><span class="line">│   └── data</span><br><span class="line">└── redis</span><br><span class="line">    └── data</span><br><span class="line">$ touch docker/mysql/my.cnf docker/redis/redis.conf </span><br><span class="line">$ tree docker</span><br><span class="line">docker</span><br><span class="line">├── mysql</span><br><span class="line">│   ├── data</span><br><span class="line">│   └── my.cnf</span><br><span class="line">└── redis</span><br><span class="line">    ├── data</span><br><span class="line">    └── redis.conf</span><br></pre></td></tr></table></figure><ol start="2"><li>准备my.conf 、redis.conf<ol><li>my.conf</li></ol></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line"> port = 3306</span><br><span class="line"> socket = /var/lib/mysql/data/mysql.sock</span><br><span class="line">[mysqld]</span><br><span class="line"> <span class="comment"># 针对5.7版本执行group by字句出错问题解决</span></span><br><span class="line">sql_mode=<span class="string">'STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'</span></span><br><span class="line"> <span class="comment"># 一般配置选项</span></span><br><span class="line"> basedir = /var/lib/mysql</span><br><span class="line"> datadir = /var/lib/mysql/data</span><br><span class="line"> port = 3306</span><br><span class="line"> socket = /var/lib/mysql/data/mysql.sock</span><br><span class="line"> lc-messages-dir = /usr/share/mysql <span class="comment"># 务必配置此项，否则执行sql出错时，只能显示错误代码而不显示具体错误消息</span></span><br><span class="line"> character-set-server=utf8</span><br><span class="line"> back_log = 300</span><br><span class="line"> max_connections = 3000</span><br><span class="line"> max_connect_errors = 50</span><br><span class="line"> table_open_cache = 4096</span><br><span class="line"> max_allowed_packet = 32M</span><br><span class="line"> <span class="comment">#binlog_cache_size = 4M</span></span><br><span class="line"> max_heap_table_size = 128M</span><br><span class="line"> read_rnd_buffer_size = 16M</span><br><span class="line"> sort_buffer_size = 16M</span><br><span class="line"> join_buffer_size = 16M</span><br><span class="line"> thread_cache_size = 16</span><br><span class="line"> query_cache_size = 64M</span><br><span class="line"> query_cache_limit = 4M</span><br><span class="line"> ft_min_word_len = 8</span><br><span class="line"> thread_stack = 512K</span><br><span class="line"> transaction_isolation = REPEATABLE-READ</span><br><span class="line"> tmp_table_size = 64M</span><br><span class="line"> <span class="comment">#log-bin=mysql-bin</span></span><br><span class="line"> long_query_time = 6</span><br><span class="line"> server_id=1</span><br><span class="line"> innodb_buffer_pool_size = 256M</span><br><span class="line"> innodb_thread_concurrency = 16</span><br><span class="line"> innodb_log_buffer_size = 16M</span><br></pre></td></tr></table></figure><ol start="2"><li>redis.conf 可以去这里下载 <a href="https://redis.io/topics/config" target="_blank" rel="noopener">官网</a></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/redis/redis/5.0/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改内容</span></span><br><span class="line">daemonize no     <span class="comment">## 若使用开机启动，生成pid，该项必须设置为诶yes，否则redis将不能够正常执行开机启动(systemctl start redis,执行后一直卡着，直到超时)</span></span><br><span class="line"><span class="comment">#bind 127.0.0.1  ##注释掉，允许所有其他ip访问，真实使用最好坐下限制，只允许某些主机访问</span></span><br><span class="line">protected-mode no  <span class="comment">## 允许其他机器上的客户端连接当前redis，配置文件设置该项，则开机启动处就可以去掉--protected no </span></span><br><span class="line">requirepass root  <span class="comment">##设置密码</span></span><br><span class="line"><span class="comment"># daemonize yes，他的作用是开启守护进程模式，在该模式下，redis会在后台运行，并将进程pid号写入至redis.conf选项pidfile设置的文件中，此时redis将一直运行，除非手动kill该进程。但是在后面的命令中“-d”选项也是开启daemonize，这是docker自家的方式。</span></span><br></pre></td></tr></table></figure><h2 id="编写Docker-Compose文件"><a href="#编写Docker-Compose文件" class="headerlink" title="编写Docker-Compose文件"></a>编写Docker-Compose文件</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">version : <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    image: mysql/mysql-server:<span class="number">5.7</span>.<span class="number">18</span></span><br><span class="line">    container_name: mysql5.<span class="number">7.18</span>-dev</span><br><span class="line">    networks:</span><br><span class="line">      - net-shop-db</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"3306:3306"</span></span><br><span class="line">    volumes:</span><br><span class="line">      - /opt/docker/mysql/my.cnf:/etc/my.cnf <span class="comment"># 映射数据库配置文件</span></span><br><span class="line">      - /opt/docker/mysql/data:/var/lib/mysql/data  <span class="comment"># 映射数据库保存目录到宿主机，防止数据丢失</span></span><br><span class="line">      - /opt/docker/mysql/log:/var/log/mysql <span class="comment"># 日志文件</span></span><br><span class="line">      - /etc/localtime:/etc/localtime:ro <span class="comment"># 设置容器时区与宿主机保持一致</span></span><br><span class="line">    restart: always <span class="comment"># 设置容器自启模式</span></span><br><span class="line">    command: [</span><br><span class="line">      <span class="string">'--character-set-server=utf8mb4'</span>,</span><br><span class="line">      <span class="string">'--collation-server=utf8mb4_unicode_ci'</span>,</span><br><span class="line">      <span class="string">'--lower_case_table_names=1'</span>,</span><br><span class="line">      <span class="string">'--default-time-zone=+8:00'</span>]</span><br><span class="line">    environment:</span><br><span class="line">      - TZ=Asia/Shanghai <span class="comment"># 设置容器时区与宿主机保持一致</span></span><br><span class="line">      - MYSQL_ROOT_PASSWORD=root <span class="comment"># 设置root密码</span></span><br><span class="line">  redis:</span><br><span class="line">    image: redis:<span class="number">5.0</span>.<span class="number">5</span></span><br><span class="line">    container_name: redis5.<span class="number">0.6</span>-dev</span><br><span class="line">    networks:</span><br><span class="line">      - net-shop-db</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">"6379:6379"</span></span><br><span class="line">    volumes:</span><br><span class="line">      - /etc/localtime:/etc/localtime:ro <span class="comment"># 设置容器时区与宿主机保持一致</span></span><br><span class="line">      - /opt/docker/redis/data:/data</span><br><span class="line">      - /opt/docker/redis/redis.conf:/etc/redis.conf</span><br><span class="line">    command: redis-server /etc/redis.conf <span class="comment"># 启动redis命令</span></span><br><span class="line">    environment:</span><br><span class="line">      - TZ=Asia/Shanghai <span class="comment"># 设置容器时区与宿主机保持一致</span></span><br><span class="line">    restart: always <span class="comment"># 设置容器自启模式</span></span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  net-shop-db:</span><br><span class="line">    driver: bridge</span><br></pre></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><blockquote><p>注意需要提前启动docker</p></blockquote><ol><li>创建并启动容器 <code>docker-compose -f docker-compose.yml up -d</code></li><li>批量停止容器并清除容器 <code>docker-compose -f docker-compose.yml down</code></li><li>重新构建容器 <code>docker-compose -f docker-compose.yml up --build -d</code></li><li>启动失败，可以查看容器日志信息获取帮助 <code>docker logs 容器名词或容器ID # 既docker-compose.yml文件参数container_name指定的值</code></li></ol><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ol><li>docker-compose 命令不存在、未找到命令。直接从github上下载，国内下载巨慢。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意查看docker 版本 和 docker-compose 的版本</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"></span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.27.4/docker-compose-`uname -s`-`uname -m` -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"><span class="comment">#。直接用国内的镜像</span></span><br><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.27.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://yefeihonours.github.io/post/docker/docker_compose/" target="_blank" rel="noopener">docker-compose 命令不存在、未找到命令</a></p><p><a href="https://zhuanlan.zhihu.com/p/43654441" target="_blank" rel="noopener">使用 docker-compose 在 Docker 中启动有密码的 Redis 容器</a></p><p><a href="https://cloud.tencent.com/developer/article/1678769" target="_blank" rel="noopener">Docker-Compose搭建mysql、redis、zookeeper、rabbitmq、consul、elasticsearch环境</a></p><p><a href="https://juejin.cn/post/6844903655389265927" target="_blank" rel="noopener">Docker Compose多容器部署</a></p><p><a href="https://colobu.com/2018/05/15/Stop-and-remove-all-docker-containers-and-images/" target="_blank" rel="noopener">停止、删除所有的docker容器和镜像</a></p><p><a href="https://my.oschina.net/u/4362704/blog/3308004" target="_blank" rel="noopener">宿主机连接docker中的mysql</a></p><p><a href="https://developer.aliyun.com/article/618035" target="_blank" rel="noopener">Docker Compose 安装 on centos7</a></p><p><a href="https://cloud.tencent.com/developer/article/1678769" target="_blank" rel="noopener">Docker-Compose搭建mysql、redis、zookeeper、rabbitmq、consul、elasticsearch环境</a></p><p><a href="https://zhuanlan.zhihu.com/p/140732202" target="_blank" rel="noopener">docker-compose一键安装redis+mysql+rabbitmq</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;记录下使用docker-compose构建管理Redis、mysql。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://z201.cn/categories/Docker/"/>
    
    
      <category term="Mysql" scheme="https://z201.cn/tags/Mysql/"/>
    
      <category term="Redis" scheme="https://z201.cn/tags/Redis/"/>
    
      <category term="Docker" scheme="https://z201.cn/tags/Docker/"/>
    
      <category term="Docker-Compose" scheme="https://z201.cn/tags/Docker-Compose/"/>
    
  </entry>
  
  <entry>
    <title>Centos7.*-Docker部署</title>
    <link href="https://z201.cn/2020/11/20/Centos7-Docker%E9%83%A8%E7%BD%B2/"/>
    <id>https://z201.cn/2020/11/20/Centos7-Docker%E9%83%A8%E7%BD%B2/</id>
    <published>2020-11-20T06:26:04.000Z</published>
    <updated>2021-01-12T07:16:48.615Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录下自己在阿里云部署docker记录。</p></blockquote><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li>准备一台ESC服务器，并可以使用控制台登录。</li><li>检查ESC是否安装了docker，可以选择是否卸载重装。<ol><li>检查docker是否安装,<code>docker 显示相关信息则表示安装</code></li><li>卸载docker，若不重装直接忽略，<code>yum list installed | grep docker</code>查看安装内容</li></ol></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ yum list installed | grep docker</span><br><span class="line">containerd.io.x86_64                1.3.7-3.1.el7                   @docker-ce-stable</span><br><span class="line">docker-ce.x86_64                    3:19.03.13-3.el7                @docker-ce-stable</span><br><span class="line">docker-ce-cli.x86_64                1:19.03.13-3.el7                @docker-ce-stable</span><br><span class="line"><span class="comment"># 依次卸载</span></span><br><span class="line">$ yum -y remove docker-ce.x86_64</span><br><span class="line">$ yum -y remove docker-ce-cli.x86_64</span><br><span class="line">$ yum -y remove containerd.io.x86_64</span><br><span class="line"><span class="comment"># 检查卸载结果</span></span><br><span class="line">$ yum list installed | grep docker</span><br><span class="line"><span class="comment"># 无输出内容</span></span><br><span class="line">$ docker </span><br><span class="line"><span class="comment"># -bash: docekr: 未找到命令 则表示卸载干净了</span></span><br></pre></td></tr></table></figure><ol start="3"><li>安装docker<ol><li>更新yum <code>yum update</code></li><li>获取官方源<code>wget -P /etc/yum.repos.d/ https://download.docker.com/linux/centos/docker-ce.repo</code></li><li>查看可以安装的版本<code>yum list docker-ce --showduplicates | sort -r</code></li><li>选择安装 <code>yum install -y docker-ce-18.03.0.ce-1.el7.centos</code></li><li>安装docker <code>yum install docker -y</code><ol><li>检查<code>docker -v</code>输出版本信息</li></ol></li></ol></li></ol><h2 id="设置docker相关信息"><a href="#设置docker相关信息" class="headerlink" title="设置docker相关信息"></a>设置docker相关信息</h2><ol><li>设置docker开机启动项<code>systemctl enable docker.service</code></li><li>关闭docker开机启动项 <code>systemctl stop docker.service</code></li><li>检查docker当前运行情况 <code>systemctl status docker</code></li><li>若未启动则启动docker <code>systemctl start docker</code> ,若启动了可以重启<code>systemctl restart docker</code></li><li>检查docker运行情况<code>service docker status</code></li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.aliyun.com/article/336442" target="_blank" rel="noopener">阿里云CentOS 7上安装配置Docker</a></p><p><a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-compose-on-centos-7" target="_blank" rel="noopener">How To Install and Use Docker Compose on CentOS 7</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;记录下自己在阿里云部署docker记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;准
      
    
    </summary>
    
    
      <category term="Linux运维" scheme="https://z201.cn/categories/Linux%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Centos7" scheme="https://z201.cn/tags/Centos7/"/>
    
      <category term="Linux" scheme="https://z201.cn/tags/Linux/"/>
    
      <category term="Docker" scheme="https://z201.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>源码分析-netty源码环境搭建</title>
    <link href="https://z201.cn/2020/10/17/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-netty%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://z201.cn/2020/10/17/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-netty%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2020-10-16T17:28:40.000Z</published>
    <updated>2021-11-22T08:28:51.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-阅读源代码"><a href="#0x00-阅读源代码" class="headerlink" title="0x00 阅读源代码"></a>0x00 阅读源代码</h2><h3 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h3><ul><li>阅读版本号 <code>netty-4.1.33.Final</code><ul><li>由于github下载速度是在太慢了，这里用gitee克隆一个镜像。</li><li>下载版本<code>git clone -b netty-4.1.33.Final git@gitee.com:Z201/netty.git</code></li></ul></li></ul><h3 id="查看源代码结构"><a href="#查看源代码结构" class="headerlink" title="查看源代码结构"></a>查看源代码结构</h3><ul><li>查看项目主要文件夹</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">tree -d  -L 1    </span><br><span class="line">├── all</span><br><span class="line">├── bom</span><br><span class="line">├── buffer (Core netty定制的buffer)</span><br><span class="line">├── codec (Protocol Support)</span><br><span class="line">├── codec-dns (Protocol Support)</span><br><span class="line">├── codec-haproxy (Protocol Support)</span><br><span class="line">├── codec-http (Protocol Support)</span><br><span class="line">├── codec-http2 (Protocol Support)</span><br><span class="line">├── codec-memcache (Protocol Support)</span><br><span class="line">├── codec-mqtt (Protocol Support 物联网)</span><br><span class="line">├── codec-redis (Protocol Support )</span><br><span class="line">├── codec-smtp (Protocol Support 邮件)</span><br><span class="line">├── codec-socks (Protocol Support)</span><br><span class="line">├── codec-stomp (Protocol Support ws)</span><br><span class="line">├── codec-xml (Protocol Support)</span><br><span class="line">├── common (Core)</span><br><span class="line">├── dev-tools</span><br><span class="line">├── docker</span><br><span class="line">├── example （抄代码的地方）</span><br><span class="line">├── handler  (Protocol Support)</span><br><span class="line">├── handler-proxy (Protocol Support)</span><br><span class="line">├── license</span><br><span class="line">├── microbench (测试用的)</span><br><span class="line">├── resolver(Core)</span><br><span class="line">├── resolver-dns (Core)</span><br><span class="line">├── tarball</span><br><span class="line">├── target</span><br><span class="line">├── testsuite</span><br><span class="line">├── testsuite-autobahn</span><br><span class="line">├── testsuite-http2</span><br><span class="line">├── testsuite-osgi</span><br><span class="line">├── testsuite-shading</span><br><span class="line">├── transport (Transport Services)</span><br><span class="line">├── transport-native-epoll  (Transport Servicesnative omitted - reserved keyword <span class="keyword">in</span> Java)</span><br><span class="line">├── transport-native-kqueue (Transport Servicesnative omitted - reserved keyword <span class="keyword">in</span> Java)</span><br><span class="line">├── transport-native-unix-common Transport Services native omitted - reserved keyword <span class="keyword">in</span> Java)</span><br><span class="line">├── transport-native-unix-common-tests </span><br><span class="line">├── transport-rxtx (Transport Services 串口编程 作废)</span><br><span class="line">├── transport-sctp (Transport Services )</span><br><span class="line">└── transport-udt  (Transport Services 作废)</span><br></pre></td></tr></table></figure><ul><li>将项目导入idea中，笔者采用mac系统。这里需要注意需要安装部分软件。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">brew install autoconf automake libtool</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果安装了国内的镜像出现Error opening archive: Failed to open</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> HOMEBREW_BOTTLE_DOMAIN=<span class="string">''</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参考文档 https://zhuanlan.zhihu.com/p/383707713</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果是mac系统需要手动将pom文件tcnative.classifier修改成对应系统的。</span></span><br><span class="line">mvn install -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><h2 id="0x01-根据官方文档快速入门"><a href="#0x01-根据官方文档快速入门" class="headerlink" title="0x01 根据官方文档快速入门"></a>0x01 根据官方文档快速入门</h2><blockquote><p>强烈推荐认真阅读netty的官方文档。</p></blockquote><ul><li>官方文档地址 ：<a href="https://netty.io/wiki/index.html" target="_blank" rel="noopener">https://netty.io/wiki/index.html</a></li></ul><h3 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h3><ul><li>netty-common模块是 Netty 的核心基础包，其他模块都需要依赖它。常用的包括通用工具类和自定义并发包。</li><li>netty-buffer 模块中Netty自己实现了的一个更加完备的ByteBuf 工具类，用于网络通信中的数据载体。</li><li>netty-resover模块主要提供了一些有关基础设施的解析工具，包括 IP Address、Hostname、DNS 等。</li></ul><h3 id="Protocol-Support"><a href="#Protocol-Support" class="headerlink" title="Protocol Support"></a>Protocol Support</h3><ul><li>netty-codec模块主要负责编解码工作，提供主流协议的编辑码，还提供了抽象编解码类 ByteToMessageDecoder 和 MessageToByteEncoder，通过继承这两个类我们可以轻松实现自定义的编解码逻辑。</li></ul><h3 id="Transport-Service"><a href="#Transport-Service" class="headerlink" title="Transport Service"></a>Transport Service</h3><ul><li>netty-transport 模块可以说是 Netty 提供数据处理和传输的核心模块，如 Bootstrap、Channel、ChannelHandler、EventLoop、EventLoopGroup、ChannelPipeline 等。其中 Bootstrap 负责客户端或服务端的启动工作，包括创建、初始化 Channel 等；EventLoop 负责向注册的 Channel 发起 I/O 读写操作；ChannelPipeline 负责 ChannelHandler 的有序编排，这些组件在介绍 Netty 逻辑架构的时候都有所涉及。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-阅读源代码&quot;&gt;&lt;a href=&quot;#0x00-阅读源代码&quot; class=&quot;headerlink&quot; title=&quot;0x00 阅读源代码&quot;&gt;&lt;/a&gt;0x00 阅读源代码&lt;/h2&gt;&lt;h3 id=&quot;下载源代码&quot;&gt;&lt;a href=&quot;#下载源代码&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="源码分析" scheme="https://z201.cn/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Netty" scheme="https://z201.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础（三）</title>
    <link href="https://z201.cn/2020/09/29/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://z201.cn/2020/09/29/MySQL%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2020-09-29T01:43:58.000Z</published>
    <updated>2021-09-29T01:47:53.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL-常见用法"><a href="#SQL-常见用法" class="headerlink" title="SQL 常见用法"></a>SQL 常见用法</h2><h3 id="1-查找数据的查询"><a href="#1-查找数据的查询" class="headerlink" title="1. 查找数据的查询"></a>1. 查找数据的查询</h3><h4 id="SELECT-用于从数据库中选择数据"><a href="#SELECT-用于从数据库中选择数据" class="headerlink" title="SELECT: 用于从数据库中选择数据"></a><strong>SELECT</strong>: 用于从数据库中选择数据</h4><ul><li><code>SELECT</code> * <code>FROM</code> table_name;</li></ul><h4 id="DISTINCT-用于过滤掉重复的值并返回指定列的行"><a href="#DISTINCT-用于过滤掉重复的值并返回指定列的行" class="headerlink" title="DISTINCT: 用于过滤掉重复的值并返回指定列的行"></a><strong>DISTINCT</strong>: 用于过滤掉重复的值并返回指定列的行</h4><ul><li><code>SELECT DISTINCT</code> column_name;</li></ul><h4 id="WHERE-用于过滤记录-行"><a href="#WHERE-用于过滤记录-行" class="headerlink" title="WHERE: 用于过滤记录/行"></a><strong>WHERE</strong>: 用于过滤记录/行</h4><ul><li><code>SELECT</code> column1, column2 <code>FROM</code> table_name <code>WHERE</code> condition;</li><li><code>SELECT</code> * <code>FROM</code> table_name <code>WHERE</code> condition1 <code>AND</code> condition2;</li><li><code>SELECT</code> * <code>FROM</code> table_name <code>WHERE</code> condition1 <code>OR</code> condition2;</li><li><code>SELECT</code> * <code>FROM</code> table_name <code>WHERE NOT</code> condition;</li><li><code>SELECT</code> * <code>FROM</code> table_name <code>WHERE</code> condition1 <code>AND</code> (condition2 <code>OR</code> condition3);</li><li><code>SELECT</code> * <code>FROM</code> table_name <code>WHERE EXISTS</code> (<code>SELECT</code> column_name <code>FROM</code> table_name <code>WHERE</code> condition);</li></ul><h4 id="ORDER-BY-用于结果集的排序，升序（ASC）或者降序（DESC）"><a href="#ORDER-BY-用于结果集的排序，升序（ASC）或者降序（DESC）" class="headerlink" title="ORDER BY: 用于结果集的排序，升序（ASC）或者降序（DESC）"></a><strong>ORDER BY</strong>: 用于结果集的排序，升序（ASC）或者降序（DESC）</h4><ul><li><code>SELECT</code> * <code>FROM</code> table_name <code>ORDER BY</code> column;</li><li><code>SELECT</code> * <code>FROM</code> table_name <code>ORDER BY</code> column <code>DESC</code>;</li><li><code>SELECT</code> * <code>FROM</code> table_name <code>ORDER BY</code> column1 <code>ASC</code>, column2 <code>DESC</code>;</li></ul><h4 id="SELECT-TOP-用于指定从表顶部返回的记录数"><a href="#SELECT-TOP-用于指定从表顶部返回的记录数" class="headerlink" title="SELECT TOP: 用于指定从表顶部返回的记录数"></a><strong>SELECT TOP</strong>: 用于指定从表顶部返回的记录数</h4><ul><li><code>SELECT TOP</code> number columns_names <code>FROM</code> table_name <code>WHERE</code> condition;</li><li><code>SELECT TOP</code> percent columns_names <code>FROM</code> table_name <code>WHERE</code> condition;</li><li>并非所有数据库系统都支持<code>SELECT TOP</code>。 MySQL 中是<code>LIMIT</code>子句</li><li><code>SELECT</code> column_names <code>FROM</code> table_name <code>LIMIT</code> offset, count;</li></ul><h4 id="LIKE-用于搜索列中的特定模式，WHERE-子句中使用的运算符"><a href="#LIKE-用于搜索列中的特定模式，WHERE-子句中使用的运算符" class="headerlink" title="LIKE: 用于搜索列中的特定模式，WHERE 子句中使用的运算符"></a><strong>LIKE</strong>: 用于搜索列中的特定模式，WHERE 子句中使用的运算符</h4><ul><li>% (percent sign) 是一个表示零个，一个或多个字符的通配符</li><li>_ (underscore) 是一个表示单个字符通配符</li><li><code>SELECT</code> column_names <code>FROM</code> table_name <code>WHERE</code> column_name <code>LIKE</code> pattern;</li><li><code>LIKE</code> ‘a%’    （查找任何以“a”开头的值）</li><li><code>LIKE</code> ‘%a’    （查找任何以“a”结尾的值）</li><li><code>LIKE</code> ‘%or%’  （查找任何包含“or”的值）</li><li><code>LIKE</code> ‘_r%’   （查找任何第二位是“r”的值）</li><li><code>LIKE</code> ‘a_%_%’ （查找任何以“a”开头且长度至少为3的值）</li><li><code>LIKE</code> ‘[a-c]%’（查找任何以“a”或“b”或“c”开头的值）</li></ul><h4 id="IN-用于在-WHERE-子句中指定多个值的运算符"><a href="#IN-用于在-WHERE-子句中指定多个值的运算符" class="headerlink" title="IN: 用于在 WHERE 子句中指定多个值的运算符"></a><strong>IN</strong>: 用于在 WHERE 子句中指定多个值的运算符</h4><ul><li>本质上，IN运算符是多个OR条件的简写</li><li><code>SELECT</code> column_names <code>FROM</code> table_name <code>WHERE</code> column_name <code>IN</code> (value1, value2, …);</li><li><code>SELECT</code> column_names <code>FROM</code> table_name <code>WHERE</code> column_name <code>IN</code> (<code>SELECT STATEMENT</code>);</li></ul><h4 id="BETWEEN-用于过滤给定范围的值的运算符"><a href="#BETWEEN-用于过滤给定范围的值的运算符" class="headerlink" title="BETWEEN: 用于过滤给定范围的值的运算符"></a><strong>BETWEEN</strong>: 用于过滤给定范围的值的运算符</h4><ul><li><code>SELECT</code> column_names <code>FROM</code> table_name <code>WHERE</code> column_name <code>BETWEEN</code> value1 <code>AND</code> value2;</li><li><code>SELECT</code> * <code>FROM</code> Products <code>WHERE</code> (column_name <code>BETWEEN</code> value1 <code>AND</code> value2) <code>AND NOT</code> column_name2 <code>IN</code> (value3, value4);</li><li><code>SELECT</code> * <code>FROM</code> Products <code>WHERE</code> column_name <code>BETWEEN</code> #01/07/1999# AND #03/12/1999#;</li></ul><h4 id="NULL-代表一个字段没有值"><a href="#NULL-代表一个字段没有值" class="headerlink" title="NULL: 代表一个字段没有值"></a><strong>NULL</strong>: 代表一个字段没有值</h4><ul><li><code>SELECT</code> * <code>FROM</code> table_name <code>WHERE</code> column_name <code>IS NULL</code>;</li><li><code>SELECT</code> * <code>FROM</code> table_name <code>WHERE</code> column_name <code>IS NOT NULL</code>;</li></ul><h4 id="AS-用于给表或者列分配别名"><a href="#AS-用于给表或者列分配别名" class="headerlink" title="AS: 用于给表或者列分配别名"></a><strong>AS</strong>: 用于给表或者列分配别名</h4><ul><li><code>SELECT</code> column_name <code>AS</code> alias_name <code>FROM</code> table_name;</li><li><code>SELECT</code> column_name <code>FROM</code> table_name <code>AS</code> alias_name;</li><li><code>SELECT</code> column_name <code>AS</code> alias_name1, column_name2 <code>AS</code> alias_name2;</li><li><code>SELECT</code> column_name1, column_name2 + ‘, ‘ + column_name3 <code>AS</code> alias_name;</li></ul><h4 id="UNION-用于组合两个或者多个-SELECT-语句的结果集的运算符"><a href="#UNION-用于组合两个或者多个-SELECT-语句的结果集的运算符" class="headerlink" title="UNION: 用于组合两个或者多个 SELECT 语句的结果集的运算符"></a><strong>UNION</strong>: 用于组合两个或者多个 SELECT 语句的结果集的运算符</h4><ul><li>每个 SELECT 语句必须拥有相同的列数</li><li>列必须拥有相似的数据类型</li><li>每个 SELECT 语句中的列也必须具有相同的顺序</li><li><code>SELECT</code> columns_names <code>FROM</code> table1 <code>UNION SELECT</code> column_name <code>FROM</code> table2;</li><li><code>UNION</code> 仅允许选择不同的值, <code>UNION ALL</code> 允许重复</li></ul><h4 id="ANY-ALL-用于检查-WHERE-或-HAVING-子句中使用的子查询条件的运算符"><a href="#ANY-ALL-用于检查-WHERE-或-HAVING-子句中使用的子查询条件的运算符" class="headerlink" title="ANY|ALL: 用于检查 WHERE 或 HAVING 子句中使用的子查询条件的运算符"></a><strong>ANY|ALL</strong>: 用于检查 WHERE 或 HAVING 子句中使用的子查询条件的运算符</h4><ul><li><code>ANY</code> 如果任何子查询值满足条件，则返回 true。</li><li><code>ALL</code> 如果所有子查询值都满足条件，则返回 true。</li><li><code>SELECT</code> columns_names <code>FROM</code> table1 <code>WHERE</code> column_name operator (<code>ANY</code>|<code>ALL</code>) (<code>SELECT</code> column_name <code>FROM</code> table_name <code>WHERE</code> condition);</li></ul><h4 id="GROUP-BY-通常与聚合函数（COUNT，MAX，MIN，SUM，AVG）一起使用，用于将结果集分组为一列或多列"><a href="#GROUP-BY-通常与聚合函数（COUNT，MAX，MIN，SUM，AVG）一起使用，用于将结果集分组为一列或多列" class="headerlink" title="GROUP BY: 通常与聚合函数（COUNT，MAX，MIN，SUM，AVG）一起使用，用于将结果集分组为一列或多列"></a><strong>GROUP BY</strong>: 通常与聚合函数（COUNT，MAX，MIN，SUM，AVG）一起使用，用于将结果集分组为一列或多列</h4><ul><li><code>SELECT</code> column_name1, COUNT(column_name2) <code>FROM</code> table_name <code>WHERE</code> condition <code>GROUP BY</code> column_name1 <code>ORDER BY</code> COUNT(column_name2) DESC;</li></ul><h4 id="HAVING-HAVING-子句指定-SELECT-语句应仅返回聚合值满足指定条件的行。它被添加到-SQL-语言中，因为WHERE关键字不能与聚合函数一起使用。"><a href="#HAVING-HAVING-子句指定-SELECT-语句应仅返回聚合值满足指定条件的行。它被添加到-SQL-语言中，因为WHERE关键字不能与聚合函数一起使用。" class="headerlink" title="HAVING: HAVING 子句指定 SELECT 语句应仅返回聚合值满足指定条件的行。它被添加到 SQL 语言中，因为WHERE关键字不能与聚合函数一起使用。"></a><strong>HAVING</strong>: HAVING 子句指定 SELECT 语句应仅返回聚合值满足指定条件的行。它被添加到 SQL 语言中，因为WHERE关键字不能与聚合函数一起使用。</h4><ul><li><code>SELECT</code> <code>COUNT</code>(column_name1), column_name2 <code>FROM</code> table <code>GROUP BY</code> column_name2 <code>HAVING</code> <code>COUNT(</code>column_name1<code>)</code> &gt; 5;</li></ul><a id="more"></a><h3 id="2-修改数据的查询"><a href="#2-修改数据的查询" class="headerlink" title="2. 修改数据的查询"></a>2. 修改数据的查询</h3><h4 id="INSERT-INTO-用于在表中插入新记录-行"><a href="#INSERT-INTO-用于在表中插入新记录-行" class="headerlink" title="INSERT INTO: 用于在表中插入新记录/行"></a><strong>INSERT INTO</strong>: 用于在表中插入新记录/行</h4><ul><li><code>INSERT INTO</code> table_name (column1, column2) <code>VALUES</code> (value1, value2);</li><li><code>INSERT INTO</code> table_name <code>VALUES</code> (value1, value2 …);</li></ul><h4 id="UPDATE-用于修改表中的现有记录-行"><a href="#UPDATE-用于修改表中的现有记录-行" class="headerlink" title="UPDATE: 用于修改表中的现有记录/行"></a><strong>UPDATE</strong>: 用于修改表中的现有记录/行</h4><ul><li><code>UPDATE</code> table_name <code>SET</code> column1 = value1, column2 = value2 <code>WHERE</code> condition;</li><li><code>UPDATE</code> table_name <code>SET</code> column_name = value;</li></ul><h4 id="DELETE-用于删除表中的现有记录-行"><a href="#DELETE-用于删除表中的现有记录-行" class="headerlink" title="DELETE: 用于删除表中的现有记录/行"></a><strong>DELETE</strong>: 用于删除表中的现有记录/行</h4><ul><li><code>DELETE FROM</code> table_name <code>WHERE</code> condition;</li><li><code>DELETE</code> * <code>FROM</code> table_name;</li></ul><h3 id="3-聚合查询"><a href="#3-聚合查询" class="headerlink" title="3. 聚合查询"></a>3. 聚合查询</h3><h4 id="COUNT-返回出现次数"><a href="#COUNT-返回出现次数" class="headerlink" title="COUNT: 返回出现次数"></a><strong>COUNT</strong>: 返回出现次数</h4><ul><li><code>SELECT COUNT (DISTINCT</code> column_name<code>)</code>;</li></ul><h4 id="MIN-and-MAX-返回所选列的最小-最大值"><a href="#MIN-and-MAX-返回所选列的最小-最大值" class="headerlink" title="MIN() and MAX(): 返回所选列的最小/最大值"></a><strong>MIN() and MAX()</strong>: 返回所选列的最小/最大值</h4><ul><li><code>SELECT MIN (</code>column_names<code>) FROM</code> table_name <code>WHERE</code> condition;</li><li><code>SELECT MAX (</code>column_names<code>) FROM</code> table_name <code>WHERE</code> condition;</li></ul><h4 id="AVG-返回数字列的平均值"><a href="#AVG-返回数字列的平均值" class="headerlink" title="AVG(): 返回数字列的平均值"></a><strong>AVG()</strong>: 返回数字列的平均值</h4><ul><li><code>SELECT AVG (</code>column_name<code>) FROM</code> table_name <code>WHERE</code> condition;</li></ul><h4 id="SUM-返回数值列的总和"><a href="#SUM-返回数值列的总和" class="headerlink" title="SUM(): 返回数值列的总和"></a><strong>SUM()</strong>: 返回数值列的总和</h4><ul><li><code>SELECT SUM (</code>column_name<code>) FROM</code> table_name <code>WHERE</code> condition;</li></ul><h3 id="4-连接查询"><a href="#4-连接查询" class="headerlink" title="4. 连接查询"></a>4. 连接查询</h3><h4 id="INNER-JOIN-内连接，返回在两张表中具有匹配值的记录"><a href="#INNER-JOIN-内连接，返回在两张表中具有匹配值的记录" class="headerlink" title="INNER JOIN: 内连接，返回在两张表中具有匹配值的记录"></a><strong>INNER JOIN</strong>: 内连接，返回在两张表中具有匹配值的记录</h4><ul><li><code>SELECT</code> column_names <code>FROM</code> table1 <code>INNER JOIN</code> table2 <code>ON</code> table1.column_name=table2.column_name;</li><li><code>SELECT</code> table1.column_name1, table2.column_name2, table3.column_name3 <code>FROM</code> ((table1 <code>INNER JOIN</code> table2 <code>ON</code> relationship) <code>INNER JOIN</code> table3 <code>ON</code> relationship);</li></ul><h4 id="LEFT-OUTER-JOIN-左外连接，返回左表（table1）中的所有记录，以及右表中的匹配记录（table2）"><a href="#LEFT-OUTER-JOIN-左外连接，返回左表（table1）中的所有记录，以及右表中的匹配记录（table2）" class="headerlink" title="LEFT (OUTER) JOIN: 左外连接，返回左表（table1）中的所有记录，以及右表中的匹配记录（table2）"></a><strong>LEFT (OUTER) JOIN</strong>: 左外连接，返回左表（table1）中的所有记录，以及右表中的匹配记录（table2）</h4><ul><li><code>SELECT</code> column_names <code>FROM</code> table1 <code>LEFT JOIN</code> table2 <code>ON</code> table1.column_name=table2.column_name;</li></ul><h4 id="RIGHT-OUTER-JOIN-右外连接，返回右表（table2）中的所有记录，以及左表（table1）中匹配的记录"><a href="#RIGHT-OUTER-JOIN-右外连接，返回右表（table2）中的所有记录，以及左表（table1）中匹配的记录" class="headerlink" title="RIGHT (OUTER) JOIN: 右外连接，返回右表（table2）中的所有记录，以及左表（table1）中匹配的记录"></a><strong>RIGHT (OUTER) JOIN</strong>: 右外连接，返回右表（table2）中的所有记录，以及左表（table1）中匹配的记录</h4><ul><li><code>SELECT</code> column_names <code>FROM</code> table1 <code>RIGHT JOIN</code> table2 <code>ON</code> table1.column_name=table2.column_name;</li></ul><h4 id="FULL-OUTER-JOIN-全外连接，全连接是左右外连接的并集-连接表包含被连接的表的所有记录-如果缺少匹配的记录-以-NULL-填充。"><a href="#FULL-OUTER-JOIN-全外连接，全连接是左右外连接的并集-连接表包含被连接的表的所有记录-如果缺少匹配的记录-以-NULL-填充。" class="headerlink" title="FULL (OUTER) JOIN: 全外连接，全连接是左右外连接的并集. 连接表包含被连接的表的所有记录, 如果缺少匹配的记录, 以 NULL 填充。"></a><strong>FULL (OUTER) JOIN</strong>: 全外连接，全连接是左右外连接的并集. 连接表包含被连接的表的所有记录, 如果缺少匹配的记录, 以 NULL 填充。</h4><ul><li><code>SELECT</code> column_names <code>FROM</code> table1 <code>FULL OUTER JOIN</code> table2 <code>ON</code> table1.column_name=table2.column_name;</li></ul><h4 id="Self-JOIN-自连接，表自身连接"><a href="#Self-JOIN-自连接，表自身连接" class="headerlink" title="Self JOIN: 自连接，表自身连接"></a><strong>Self JOIN</strong>: 自连接，表自身连接</h4><ul><li><code>SELECT</code> column_names <code>FROM</code> table1 T1, table1 T2 <code>WHERE</code> condition;</li></ul><h3 id="5-视图查询"><a href="#5-视图查询" class="headerlink" title="5. 视图查询"></a>5. 视图查询</h3><h4 id="CREATE-创建视图"><a href="#CREATE-创建视图" class="headerlink" title="CREATE: 创建视图"></a><strong>CREATE</strong>: 创建视图</h4><ul><li><code>CREATE VIEW</code> view_name <code>AS SELECT</code> column1, column2 <code>FROM</code> table_name <code>WHERE</code> condition;</li></ul><h4 id="SELECT-检索视图"><a href="#SELECT-检索视图" class="headerlink" title="SELECT: 检索视图"></a><strong>SELECT</strong>: 检索视图</h4><ul><li><code>SELECT</code> * <code>FROM</code> view_name;</li></ul><h4 id="DROP-删除视图"><a href="#DROP-删除视图" class="headerlink" title="DROP: 删除视图"></a><strong>DROP</strong>: 删除视图</h4><ul><li><code>DROP VIEW</code> view_name;</li></ul><h3 id="6-修改表的查询"><a href="#6-修改表的查询" class="headerlink" title="6. 修改表的查询"></a>6. 修改表的查询</h3><h4 id="ADD-添加字段"><a href="#ADD-添加字段" class="headerlink" title="ADD: 添加字段"></a><strong>ADD</strong>: 添加字段</h4><ul><li><code>ALTER TABLE</code> table_name <code>ADD</code> column_name column_definition;</li></ul><h4 id="MODIFY-修改字段数据类型"><a href="#MODIFY-修改字段数据类型" class="headerlink" title="MODIFY: 修改字段数据类型"></a><strong>MODIFY</strong>: 修改字段数据类型</h4><ul><li><code>ALTER TABLE</code> table_name <code>MODIFY</code> column_name column_type;</li></ul><h4 id="DROP-删除字段"><a href="#DROP-删除字段" class="headerlink" title="DROP: 删除字段"></a><strong>DROP</strong>: 删除字段</h4><ul><li><code>ALTER TABLE</code> table_name <code>DROP COLUMN</code> column_name;</li></ul><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ABS(x)         <span class="comment">--返回x的绝对值</span></span><br><span class="line">BIN(x)         <span class="comment">--返回x的二进制（OCT返回八进制，HEX返回十六进制）</span></span><br><span class="line">CEILING(x)     <span class="comment">--返回大于x的最小整数值</span></span><br><span class="line">EXP(x)         <span class="comment">--返回值e（自然对数的底）的x次方</span></span><br><span class="line">FLOOR(x)       <span class="comment">--返回小于x的最大整数值</span></span><br><span class="line">GREATEST(x1,x2,...,xn)</span><br><span class="line">                <span class="comment">--返回集合中最大的值</span></span><br><span class="line">LEAST(x1,x2,...,xn)   </span><br><span class="line">                <span class="comment">--返回集合中最小的值</span></span><br><span class="line">LN(x)           <span class="comment">--返回x的自然对数</span></span><br><span class="line">LOG(x,y)        <span class="comment">--返回x的以y为底的对数</span></span><br><span class="line">MOD(x,y)        <span class="comment">--返回x/y的模（余数）</span></span><br><span class="line">PI()            <span class="comment">--返回pi的值（圆周率）</span></span><br><span class="line">RAND()          <span class="comment">--返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。</span></span><br><span class="line">ROUND(x,y)      <span class="comment">--返回参数x的四舍五入的有y位小数的值</span></span><br><span class="line">SIGN(x)         <span class="comment">--返回代表数字x的符号的值</span></span><br><span class="line">SQRT(x)         <span class="comment">--返回一个数的平方根</span></span><br><span class="line"><span class="keyword">TRUNCATE</span>(x,y)   <span class="comment">--返回数字x截短为y位小数的结果</span></span><br></pre></td></tr></table></figure><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AVG(X)            <span class="comment">--返回指定列的平均值</span></span><br><span class="line">COUNT(X)          <span class="comment">--返回指定列中非NULL值的个数</span></span><br><span class="line">MIN(X)            <span class="comment">--返回指定列的最小值</span></span><br><span class="line">MAX(X)            <span class="comment">--返回指定列的最大值</span></span><br><span class="line">SUM(X)            <span class="comment">--返回指定列的所有值之和</span></span><br><span class="line">GROUP_CONCAT(X)   <span class="comment">--返回由属于一组的列值连接组合而成的结果，非常有用</span></span><br></pre></td></tr></table></figure><h3 id="字符串函数（20个）"><a href="#字符串函数（20个）" class="headerlink" title="字符串函数（20个）"></a>字符串函数（20个）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ASCII(char)        <span class="comment">--返回字符的ASCII码值</span></span><br><span class="line">BIT_LENGTH(str)    <span class="comment">--返回字符串的比特长度</span></span><br><span class="line">CONCAT(s1,s2...,sn) </span><br><span class="line">                   <span class="comment">--将s1,s2...,sn连接成字符串</span></span><br><span class="line">CONCAT_WS(sep,s1,s2...,sn)</span><br><span class="line">                   <span class="comment">--将s1,s2...,sn连接成字符串，并用sep字符间隔</span></span><br><span class="line"><span class="keyword">INSERT</span>(<span class="keyword">str</span>,x,y,<span class="keyword">instr</span>) </span><br><span class="line">                   <span class="comment">--将字符串str从第x位置开始，y个字符长的子串替换为字符串instr，返回结果</span></span><br><span class="line">FIND_IN_SET(<span class="keyword">str</span>,<span class="keyword">list</span>)</span><br><span class="line">                   <span class="comment">--分析逗号分隔的list列表，如果发现str，返回str在list中的位置</span></span><br><span class="line"><span class="keyword">LCASE</span>(<span class="keyword">str</span>)或<span class="keyword">LOWER</span>(<span class="keyword">str</span>) </span><br><span class="line">                   <span class="comment">--返回将字符串str中所有字符改变为小写后的结果</span></span><br><span class="line"><span class="keyword">LEFT</span>(<span class="keyword">str</span>,x)        <span class="comment">--返回字符串str中最左边的x个字符</span></span><br><span class="line"><span class="keyword">LENGTH</span>(s)          <span class="comment">--返回字符串str中的字符数</span></span><br><span class="line"><span class="keyword">LTRIM</span>(<span class="keyword">str</span>)         <span class="comment">--从字符串str中切掉开头的空格</span></span><br><span class="line"><span class="keyword">POSITION</span>(<span class="keyword">substr</span>,<span class="keyword">str</span>) </span><br><span class="line">                   <span class="comment">--返回子串substr在字符串str中第一次出现的位置</span></span><br><span class="line">QUOTE(<span class="keyword">str</span>)         <span class="comment">--用反斜杠转义str中的单引号</span></span><br><span class="line"><span class="keyword">REPEAT</span>(<span class="keyword">str</span>,srchstr,rplcstr)</span><br><span class="line">                   <span class="comment">--返回字符串str重复x次的结果</span></span><br><span class="line"><span class="keyword">REVERSE</span>(<span class="keyword">str</span>)       <span class="comment">--返回颠倒字符串str的结果</span></span><br><span class="line"><span class="keyword">RIGHT</span>(<span class="keyword">str</span>,x)       <span class="comment">--返回字符串str中最右边的x个字符</span></span><br><span class="line"><span class="keyword">RTRIM</span>(<span class="keyword">str</span>)         <span class="comment">--返回字符串str尾部的空格</span></span><br><span class="line"><span class="keyword">STRCMP</span>(s1,s2)      <span class="comment">--比较字符串s1和s2</span></span><br><span class="line"><span class="keyword">TRIM</span>(<span class="keyword">str</span>)          <span class="comment">--去除字符串首部和尾部的所有空格</span></span><br><span class="line"><span class="keyword">UCASE</span>(<span class="keyword">str</span>)或<span class="keyword">UPPER</span>(<span class="keyword">str</span>) </span><br><span class="line">                   <span class="comment">--返回将字符串str中所有字符转变为大写后的结果</span></span><br></pre></td></tr></table></figure><h3 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">CURDATE()或CURRENT_DATE() </span><br><span class="line">                   <span class="comment">--返回当前的日期</span></span><br><span class="line">CURTIME()或CURRENT_TIME() </span><br><span class="line">                   <span class="comment">--返回当前的时间</span></span><br><span class="line">DATE_ADD(date,INTERVAL int keyword)</span><br><span class="line">                   <span class="comment">--返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化)</span></span><br><span class="line"><span class="comment">-- 例如</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_ADD</span>(<span class="keyword">CURRENT_DATE</span>,<span class="built_in">INTERVAL</span> <span class="number">6</span> <span class="keyword">MONTH</span>);</span><br><span class="line"></span><br><span class="line">DATE_FORMAT(date,fmt)  </span><br><span class="line">                   <span class="comment">--依照指定的fmt格式格式化日期date值</span></span><br><span class="line">DATE_SUB(date,INTERVAL int keyword)</span><br><span class="line">                   <span class="comment">--返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化)</span></span><br><span class="line"><span class="comment">-- 例如</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_SUB</span>(<span class="keyword">CURRENT_DATE</span>,<span class="built_in">INTERVAL</span> <span class="number">6</span> <span class="keyword">MONTH</span>);</span><br><span class="line"></span><br><span class="line">DAYOFWEEK(date)    <span class="comment">--返回date所代表的一星期中的第几天(1~7)</span></span><br><span class="line">DAYOFMONTH(date)   <span class="comment">--返回date是一个月的第几天(1~31)</span></span><br><span class="line">DAYOFYEAR(date)    <span class="comment">--返回date是一年的第几天(1~366)</span></span><br><span class="line">DAYNAME(date)      <span class="comment">--返回date的星期名，如：SELECT DAYNAME(CURRENT_DATE);</span></span><br><span class="line">FROM_UNIXTIME(ts,fmt)  </span><br><span class="line">                   <span class="comment">--根据指定的fmt格式，格式化UNIX时间戳ts</span></span><br><span class="line">HOUR(time)         <span class="comment">--返回time的小时值(0~23)</span></span><br><span class="line">MINUTE(time)       <span class="comment">--返回time的分钟值(0~59)</span></span><br><span class="line">MONTH(date)        <span class="comment">--返回date的月份值(1~12)</span></span><br><span class="line">MONTHNAME(date)    <span class="comment">--返回date的月份名，如：SELECT MONTHNAME(CURRENT_DATE);</span></span><br><span class="line">NOW()              <span class="comment">--返回当前的日期和时间</span></span><br><span class="line">QUARTER(date)      <span class="comment">--返回date在一年中的季度(1~4)</span></span><br><span class="line"><span class="comment">-- 例如</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">QUARTER</span>(<span class="keyword">CURRENT_DATE</span>);</span><br><span class="line"></span><br><span class="line">WEEK(date)         <span class="comment">--返回日期date为一年中第几周(0~53)</span></span><br><span class="line">YEAR(date)         <span class="comment">--返回日期date的年份(1000~9999)</span></span><br><span class="line"><span class="comment">-- 例如，获取当前系统时间</span></span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="keyword">UNIX_TIMESTAMP</span>());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXTRACT</span>(YEAR_MONTH <span class="keyword">FROM</span> <span class="keyword">CURRENT_DATE</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXTRACT</span>(DAY_SECOND <span class="keyword">FROM</span> <span class="keyword">CURRENT_DATE</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXTRACT</span>(HOUR_MINUTE <span class="keyword">FROM</span> <span class="keyword">CURRENT_DATE</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回两个日期值之间的差值(月数)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">PERIOD_DIFF</span>(<span class="number">200302</span>,<span class="number">199802</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在Mysql中计算年龄：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>(<span class="keyword">FROM_DAYS</span>(<span class="keyword">TO_DAYS</span>(<span class="keyword">NOW</span>())-<span class="keyword">TO_DAYS</span>(birthday)),<span class="string">'%Y'</span>)+<span class="number">0</span> <span class="keyword">AS</span> age <span class="keyword">FROM</span> employee;</span><br><span class="line"><span class="comment">-- 这样，如果Brithday是未来的年月日的话，计算结果为0。</span></span><br><span class="line"><span class="comment">-- 下面的SQL语句计算员工的绝对年龄，即当Birthday是未来的日期时，将得到负值。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(), <span class="string">'%Y'</span>) </span><br><span class="line">- <span class="keyword">DATE_FORMAT</span>(birthday, <span class="string">'%Y'</span>) </span><br><span class="line">-(<span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(), <span class="string">'00-%m-%d'</span>) </span><br><span class="line">&lt; <span class="keyword">DATE_FORMAT</span>(birthday, <span class="string">'00-%m-%d'</span>)) <span class="keyword">AS</span> age <span class="keyword">from</span> employee</span><br></pre></td></tr></table></figure><h3 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">AES_ENCRYPT(str,key)  </span><br><span class="line"><span class="comment">--返回用密钥key对字符串str利用高级加密标准算法加密后的结果，调用AES_ENCRYPT的结果是一个二进制字符串，以BLOB类型存储</span></span><br><span class="line">AES_DECRYPT(str,key)  </span><br><span class="line">                   <span class="comment">--返回用密钥key对字符串str利用高级加密标准算法解密后的结果</span></span><br><span class="line">DECODE(str,key)    <span class="comment">--使用key作为密钥解密加密字符串str</span></span><br><span class="line">ENCRYPT(str,salt)  <span class="comment">--使用UNIXcrypt()函数，用关键词salt(一个可以惟一确定口令的字符串，就像钥匙一样)加密字符串str</span></span><br><span class="line">ENCODE(str,key)    <span class="comment">--使用key作为密钥加密字符串str，调用ENCODE()的结果是一个二进制字符串，它以BLOB类型存储</span></span><br><span class="line">MD5()              <span class="comment">--计算字符串str的MD5校验和</span></span><br><span class="line">PASSWORD(str)      <span class="comment">--返回字符串str的加密版本，这个加密过程是不可逆转的，和UNIX密码加密过程使用不同的算法。</span></span><br><span class="line">SHA()              <span class="comment">--计算字符串str的安全散列算法(SHA)校验和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 例如</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ENCRYPT</span>(<span class="string">'root'</span>,<span class="string">'salt'</span>) ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ENCODE</span>(<span class="string">'xufeng'</span>,<span class="string">'key'</span>) ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DECODE</span>(<span class="keyword">ENCODE</span>(<span class="string">'xufeng'</span>,<span class="string">'key'</span>),<span class="string">'key'</span>) ;<span class="comment">--加解密放在一起</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AES_ENCRYPT</span>(<span class="string">'root'</span>,<span class="string">'key'</span>) ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AES_DECRYPT</span>(<span class="keyword">AES_ENCRYPT</span>(<span class="string">'root'</span>,<span class="string">'key'</span>),<span class="string">'key'</span>) ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MD5</span>(<span class="string">'123456'</span>) ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SHA</span>(<span class="string">'123456'</span>) ;</span><br></pre></td></tr></table></figure><h3 id="控制流函数"><a href="#控制流函数" class="headerlink" title="控制流函数"></a>控制流函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">CASE WHEN [test1] THEN [result1]...ELSE [default] <span class="keyword">END</span> </span><br><span class="line">                    <span class="comment">--如果test1是真，则返回result1，否则返回default</span></span><br><span class="line"><span class="keyword">CASE</span> [<span class="keyword">test</span>] <span class="keyword">WHEN</span> [val1] <span class="keyword">THEN</span> [<span class="keyword">result</span>]...ELSE [<span class="keyword">default</span>] <span class="keyword">END</span>  </span><br><span class="line">                    <span class="comment">--如果test和valN相等，则返回result，否则返回default</span></span><br><span class="line"><span class="keyword">IF</span>(<span class="keyword">test</span>,t,f)        <span class="comment">--如果test是真，返回t；否则返回f</span></span><br><span class="line"><span class="keyword">IFNULL</span>(arg1,arg2)   <span class="comment">--如果arg1不是空，返回arg1，否则返回arg2</span></span><br><span class="line"><span class="keyword">NULLIF</span>(arg1,arg2)   <span class="comment">--如果arg1=arg2返回NULL；否则返回arg1</span></span><br><span class="line"><span class="comment">-- 这些函数的第一个是IFNULL()，它有两个参数，并且对第一个参数进行判断。</span></span><br><span class="line"><span class="comment">-- 如果第一个参数不是NULL，函数就会向调用者返回第一个参数；</span></span><br><span class="line"><span class="comment">-- 如果是NULL,将返回第二个参数。</span></span><br><span class="line"><span class="comment">-- 例如</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IFNULL</span>(<span class="number">1</span>,<span class="number">2</span>), </span><br><span class="line"><span class="keyword">IFNULL</span>(<span class="literal">NULL</span>,<span class="number">10</span>),</span><br><span class="line"><span class="keyword">IFNULL</span>(<span class="number">4</span>*<span class="literal">NULL</span>,<span class="string">'false'</span>);</span><br><span class="line"></span><br><span class="line">NULLIF() <span class="comment">-- 函数将会检验提供的两个参数是否相等，如果相等，则返回NULL，</span></span><br><span class="line"><span class="comment">-- 如果不相等，就返回第一个参数。</span></span><br><span class="line"><span class="comment">-- 例如</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">NULLIF</span>(<span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line"> <span class="keyword">NULLIF</span>(<span class="string">'A'</span>,<span class="string">'B'</span>),</span><br><span class="line"> <span class="keyword">NULLIF</span>(<span class="number">2</span>+<span class="number">3</span>,<span class="number">4</span>+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">MySQL的IF()</span><br><span class="line"><span class="comment">-- 函数也可以建立一个简单的条件测试，</span></span><br><span class="line"><span class="comment">-- 这个函数有三个参数，第一个是要被判断的表达式，</span></span><br><span class="line"><span class="comment">-- 如果表达式为真，IF()将会返回第二个参数，</span></span><br><span class="line"><span class="comment">-- 如果为假，IF()将会返回第三个参数。</span></span><br><span class="line"><span class="comment">-- 例如</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IF</span>(<span class="number">1</span>&lt;<span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>),<span class="keyword">IF</span>(<span class="number">56</span>&gt;<span class="number">100</span>,<span class="string">'true'</span>,<span class="string">'false'</span>);</span><br><span class="line"><span class="comment">-- IF()函数在只有两种可能结果时才适合使用。</span></span><br><span class="line"><span class="comment">-- 然而，在现实世界中，我们可能发现在条件测试中会需要多个分支。</span></span><br><span class="line"><span class="comment">-- 在这种情况下，它和PHP及Perl语言的switch-case条件例程一样。</span></span><br><span class="line"></span><br><span class="line">CASE</span><br><span class="line"><span class="comment">-- 函数的格式有些复杂，通常如下所示：</span></span><br><span class="line">CASE [expression to be evaluated]</span><br><span class="line">WHEN [val 1] THEN [result 1]</span><br><span class="line">WHEN [val 2] THEN [result 2]</span><br><span class="line">WHEN [val 3] THEN [result 3]</span><br><span class="line">......</span><br><span class="line">WHEN [val n] THEN [result n]</span><br><span class="line">ELSE [default result]</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="comment">-- 这里，第一个参数是要被判断的值或表达式，接下来的是一系列的WHEN-THEN块，</span></span><br><span class="line"><span class="comment">-- 每一块的第一个参数指定要比较的值，如果为真，就返回结果。</span></span><br><span class="line"><span class="comment">-- 所有的WHEN-THEN块将以ELSE块结束，当END结束了所有外部的CASE块时，</span></span><br><span class="line"><span class="comment">-- 如果前面的每一个块都不匹配就会返回ELSE块指定的默认结果。</span></span><br><span class="line"><span class="comment">-- 如果没有指定ELSE块，而且所有的WHEN-THEN比较都不是真，MySQL将会返回NULL。</span></span><br><span class="line"><span class="keyword">CASE</span>函数还有另外一种句法，有时使用起来非常方便，如下：</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> [conditional <span class="keyword">test</span> <span class="number">1</span>] <span class="keyword">THEN</span> [<span class="keyword">result</span> <span class="number">1</span>]</span><br><span class="line"><span class="keyword">WHEN</span> [conditional <span class="keyword">test</span> <span class="number">2</span>] <span class="keyword">THEN</span> [<span class="keyword">result</span> <span class="number">2</span>]</span><br><span class="line"><span class="keyword">ELSE</span> [<span class="keyword">default</span> <span class="keyword">result</span>]</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="comment">-- 这种条件下，返回的结果取决于相应的条件测试是否为真。</span></span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">SELECT</span>  <span class="keyword">CASE</span> <span class="string">'green'</span></span><br><span class="line">      <span class="keyword">WHEN</span> <span class="string">'red'</span> <span class="keyword">THEN</span> <span class="string">'stop'</span></span><br><span class="line">      <span class="keyword">WHEN</span> <span class="string">'green'</span> <span class="keyword">THEN</span> <span class="string">'go'</span> <span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span>  <span class="number">9</span> </span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">'a'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="string">'b'</span> <span class="keyword">ELSE</span> <span class="string">'N/A'</span> <span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> (<span class="number">2</span>+<span class="number">2</span>)=<span class="number">4</span> <span class="keyword">THEN</span> <span class="string">'OK'</span> </span><br><span class="line"><span class="keyword">WHEN</span> (<span class="number">2</span>+<span class="number">2</span>)&lt;&gt;<span class="number">4</span> <span class="keyword">THEN</span> <span class="string">'not OK'</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="keyword">STATUS</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">Name</span>,<span class="keyword">IF</span>((IsActive = <span class="number">1</span>),<span class="string">'已激活'</span>,<span class="string">'未激活'</span>) <span class="keyword">AS</span> <span class="keyword">RESULT</span> </span><br><span class="line"><span class="keyword">FROM</span> UserLoginInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> fname,lname,(math+sci+lit) <span class="keyword">AS</span> total,</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> (math+sci+lit) &lt; <span class="number">50</span> <span class="keyword">THEN</span> <span class="string">'D'</span></span><br><span class="line">     <span class="keyword">WHEN</span> (math+sci+lit) <span class="keyword">BETWEEN</span> <span class="number">50</span> <span class="keyword">AND</span> <span class="number">150</span> <span class="keyword">THEN</span> <span class="string">'C'</span></span><br><span class="line">     <span class="keyword">WHEN</span> (math+sci+lit) <span class="keyword">BETWEEN</span> <span class="number">151</span> <span class="keyword">AND</span> <span class="number">250</span> <span class="keyword">THEN</span> <span class="string">'B'</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">'A'</span> <span class="keyword">END</span> <span class="keyword">AS</span> grade <span class="keyword">FROM</span> marks ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">IF</span>(<span class="keyword">ENCRYPT</span>(<span class="string">'sue'</span>,<span class="string">'ts'</span>)=upass,<span class="string">'allow'</span>,<span class="string">'deny'</span>) <span class="keyword">AS</span> LoginResult</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">users</span> <span class="keyword">WHERE</span> uname = <span class="string">'sue'</span>;</span><br></pre></td></tr></table></figure><h3 id="格式化函数"><a href="#格式化函数" class="headerlink" title="格式化函数"></a>格式化函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DATE_FORMAT(date,fmt)  </span><br><span class="line">                  <span class="comment">--依照字符串fmt格式化日期date值</span></span><br><span class="line">FORMAT(x,y)       <span class="comment">--把x格式化为以逗号隔开的数字序列，y是结果的小数位数</span></span><br><span class="line">INET_ATON(ip)     <span class="comment">--返回IP地址的数字表示</span></span><br><span class="line">INET_NTOA(num)    <span class="comment">--返回数字所代表的IP地址</span></span><br><span class="line">TIME_FORMAT(time,fmt)   </span><br><span class="line">                  <span class="comment">--依照字符串fmt格式化时间time值</span></span><br><span class="line"><span class="comment">-- 其中最简单的是FORMAT()函数，</span></span><br><span class="line"><span class="comment">-- 它可以把大的数值格式化为以逗号间隔的易读的序列。</span></span><br><span class="line"><span class="comment">-- 例如</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FORMAT</span>(<span class="number">34234.34323432</span>,<span class="number">3</span>) ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(),<span class="string">'%W,%D %M %Y %r'</span>) ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(),<span class="string">'%Y-%m-%d'</span>) ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>(<span class="number">19990330</span>,<span class="string">'%Y-%m-%d'</span>) ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATE_FORMAT</span>(<span class="keyword">NOW</span>(),<span class="string">'%h:%i %p'</span>) ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">INET_ATON</span>(<span class="string">'10.122.89.47'</span>) ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">INET_NTOA</span>(<span class="number">175790383</span>) ;</span><br></pre></td></tr></table></figure><h3 id="类型转化函数"><a href="#类型转化函数" class="headerlink" title="类型转化函数"></a>类型转化函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 为了进行数据类型转化，MySQL提供了CAST()函数，</span></span><br><span class="line"><span class="comment">-- 它可以把一个值转化为指定的数据类型。</span></span><br><span class="line"><span class="comment">-- 类型有：</span></span><br><span class="line">BINARY,CHAR,DATE,TIME,DATETIME,SIGNED,UNSIGNED</span><br><span class="line"><span class="comment">-- 例如</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CAST</span>(<span class="keyword">NOW</span>() <span class="keyword">AS</span> SIGNED <span class="built_in">INTEGER</span>),<span class="keyword">CURDATE</span>()+<span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">'f'</span>=<span class="built_in">BINARY</span> <span class="string">'F'</span>,<span class="string">'f'</span>=<span class="keyword">CAST</span>(<span class="string">'F'</span> <span class="keyword">AS</span> <span class="built_in">BINARY</span>);</span><br></pre></td></tr></table></figure><h3 id="系统信息函数"><a href="#系统信息函数" class="headerlink" title="系统信息函数"></a>系统信息函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DATABASE()         <span class="comment">--返回当前数据库名</span></span><br><span class="line">BENCHMARK(count,expr)   </span><br><span class="line">                   <span class="comment">--将表达式expr重复运行count次</span></span><br><span class="line">CONNECTION_ID()    <span class="comment">--返回当前客户的连接ID</span></span><br><span class="line">FOUND_ROWS()       <span class="comment">--返回最后一个SELECT查询进行检索的总行数</span></span><br><span class="line">USER()或SYSTEM_USER()  </span><br><span class="line">                   <span class="comment">--返回当前登陆用户名</span></span><br><span class="line">VERSION()          <span class="comment">--返回MySQL服务器的版本</span></span><br><span class="line"><span class="comment">-- 例如</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DATABASE</span>(),<span class="keyword">VERSION</span>(),<span class="keyword">USER</span>();</span><br><span class="line">SELECTBENCHMARK(9999999,LOG(RAND()*PI()));</span><br><span class="line"><span class="comment">--该例中,MySQL计算LOG(RAND()*PI())表达式9999999次。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SQL-常见用法&quot;&gt;&lt;a href=&quot;#SQL-常见用法&quot; class=&quot;headerlink&quot; title=&quot;SQL 常见用法&quot;&gt;&lt;/a&gt;SQL 常见用法&lt;/h2&gt;&lt;h3 id=&quot;1-查找数据的查询&quot;&gt;&lt;a href=&quot;#1-查找数据的查询&quot; class=&quot;headerlink&quot; title=&quot;1. 查找数据的查询&quot;&gt;&lt;/a&gt;1. 查找数据的查询&lt;/h3&gt;&lt;h4 id=&quot;SELECT-用于从数据库中选择数据&quot;&gt;&lt;a href=&quot;#SELECT-用于从数据库中选择数据&quot; class=&quot;headerlink&quot; title=&quot;SELECT: 用于从数据库中选择数据&quot;&gt;&lt;/a&gt;&lt;strong&gt;SELECT&lt;/strong&gt;: 用于从数据库中选择数据&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; * &lt;code&gt;FROM&lt;/code&gt; table_name;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;DISTINCT-用于过滤掉重复的值并返回指定列的行&quot;&gt;&lt;a href=&quot;#DISTINCT-用于过滤掉重复的值并返回指定列的行&quot; class=&quot;headerlink&quot; title=&quot;DISTINCT: 用于过滤掉重复的值并返回指定列的行&quot;&gt;&lt;/a&gt;&lt;strong&gt;DISTINCT&lt;/strong&gt;: 用于过滤掉重复的值并返回指定列的行&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT DISTINCT&lt;/code&gt; column_name;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;WHERE-用于过滤记录-行&quot;&gt;&lt;a href=&quot;#WHERE-用于过滤记录-行&quot; class=&quot;headerlink&quot; title=&quot;WHERE: 用于过滤记录/行&quot;&gt;&lt;/a&gt;&lt;strong&gt;WHERE&lt;/strong&gt;: 用于过滤记录/行&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; column1, column2 &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;WHERE&lt;/code&gt; condition;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; * &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;WHERE&lt;/code&gt; condition1 &lt;code&gt;AND&lt;/code&gt; condition2;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; * &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;WHERE&lt;/code&gt; condition1 &lt;code&gt;OR&lt;/code&gt; condition2;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; * &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;WHERE NOT&lt;/code&gt; condition;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; * &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;WHERE&lt;/code&gt; condition1 &lt;code&gt;AND&lt;/code&gt; (condition2 &lt;code&gt;OR&lt;/code&gt; condition3);&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; * &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;WHERE EXISTS&lt;/code&gt; (&lt;code&gt;SELECT&lt;/code&gt; column_name &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;WHERE&lt;/code&gt; condition);&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;ORDER-BY-用于结果集的排序，升序（ASC）或者降序（DESC）&quot;&gt;&lt;a href=&quot;#ORDER-BY-用于结果集的排序，升序（ASC）或者降序（DESC）&quot; class=&quot;headerlink&quot; title=&quot;ORDER BY: 用于结果集的排序，升序（ASC）或者降序（DESC）&quot;&gt;&lt;/a&gt;&lt;strong&gt;ORDER BY&lt;/strong&gt;: 用于结果集的排序，升序（ASC）或者降序（DESC）&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; * &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;ORDER BY&lt;/code&gt; column;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; * &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;ORDER BY&lt;/code&gt; column &lt;code&gt;DESC&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; * &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;ORDER BY&lt;/code&gt; column1 &lt;code&gt;ASC&lt;/code&gt;, column2 &lt;code&gt;DESC&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;SELECT-TOP-用于指定从表顶部返回的记录数&quot;&gt;&lt;a href=&quot;#SELECT-TOP-用于指定从表顶部返回的记录数&quot; class=&quot;headerlink&quot; title=&quot;SELECT TOP: 用于指定从表顶部返回的记录数&quot;&gt;&lt;/a&gt;&lt;strong&gt;SELECT TOP&lt;/strong&gt;: 用于指定从表顶部返回的记录数&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT TOP&lt;/code&gt; number columns_names &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;WHERE&lt;/code&gt; condition;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT TOP&lt;/code&gt; percent columns_names &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;WHERE&lt;/code&gt; condition;&lt;/li&gt;
&lt;li&gt;并非所有数据库系统都支持&lt;code&gt;SELECT TOP&lt;/code&gt;。 MySQL 中是&lt;code&gt;LIMIT&lt;/code&gt;子句&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; column_names &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;LIMIT&lt;/code&gt; offset, count;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;LIKE-用于搜索列中的特定模式，WHERE-子句中使用的运算符&quot;&gt;&lt;a href=&quot;#LIKE-用于搜索列中的特定模式，WHERE-子句中使用的运算符&quot; class=&quot;headerlink&quot; title=&quot;LIKE: 用于搜索列中的特定模式，WHERE 子句中使用的运算符&quot;&gt;&lt;/a&gt;&lt;strong&gt;LIKE&lt;/strong&gt;: 用于搜索列中的特定模式，WHERE 子句中使用的运算符&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;% (percent sign) 是一个表示零个，一个或多个字符的通配符&lt;/li&gt;
&lt;li&gt;_ (underscore) 是一个表示单个字符通配符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; column_names &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;WHERE&lt;/code&gt; column_name &lt;code&gt;LIKE&lt;/code&gt; pattern;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LIKE&lt;/code&gt; ‘a%’    （查找任何以“a”开头的值）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LIKE&lt;/code&gt; ‘%a’    （查找任何以“a”结尾的值）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LIKE&lt;/code&gt; ‘%or%’  （查找任何包含“or”的值）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LIKE&lt;/code&gt; ‘_r%’   （查找任何第二位是“r”的值）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LIKE&lt;/code&gt; ‘a_%_%’ （查找任何以“a”开头且长度至少为3的值）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LIKE&lt;/code&gt; ‘[a-c]%’（查找任何以“a”或“b”或“c”开头的值）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;IN-用于在-WHERE-子句中指定多个值的运算符&quot;&gt;&lt;a href=&quot;#IN-用于在-WHERE-子句中指定多个值的运算符&quot; class=&quot;headerlink&quot; title=&quot;IN: 用于在 WHERE 子句中指定多个值的运算符&quot;&gt;&lt;/a&gt;&lt;strong&gt;IN&lt;/strong&gt;: 用于在 WHERE 子句中指定多个值的运算符&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;本质上，IN运算符是多个OR条件的简写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; column_names &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;WHERE&lt;/code&gt; column_name &lt;code&gt;IN&lt;/code&gt; (value1, value2, …);&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; column_names &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;WHERE&lt;/code&gt; column_name &lt;code&gt;IN&lt;/code&gt; (&lt;code&gt;SELECT STATEMENT&lt;/code&gt;);&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;BETWEEN-用于过滤给定范围的值的运算符&quot;&gt;&lt;a href=&quot;#BETWEEN-用于过滤给定范围的值的运算符&quot; class=&quot;headerlink&quot; title=&quot;BETWEEN: 用于过滤给定范围的值的运算符&quot;&gt;&lt;/a&gt;&lt;strong&gt;BETWEEN&lt;/strong&gt;: 用于过滤给定范围的值的运算符&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; column_names &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;WHERE&lt;/code&gt; column_name &lt;code&gt;BETWEEN&lt;/code&gt; value1 &lt;code&gt;AND&lt;/code&gt; value2;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; * &lt;code&gt;FROM&lt;/code&gt; Products &lt;code&gt;WHERE&lt;/code&gt; (column_name &lt;code&gt;BETWEEN&lt;/code&gt; value1 &lt;code&gt;AND&lt;/code&gt; value2) &lt;code&gt;AND NOT&lt;/code&gt; column_name2 &lt;code&gt;IN&lt;/code&gt; (value3, value4);&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; * &lt;code&gt;FROM&lt;/code&gt; Products &lt;code&gt;WHERE&lt;/code&gt; column_name &lt;code&gt;BETWEEN&lt;/code&gt; #01/07/1999# AND #03/12/1999#;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;NULL-代表一个字段没有值&quot;&gt;&lt;a href=&quot;#NULL-代表一个字段没有值&quot; class=&quot;headerlink&quot; title=&quot;NULL: 代表一个字段没有值&quot;&gt;&lt;/a&gt;&lt;strong&gt;NULL&lt;/strong&gt;: 代表一个字段没有值&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; * &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;WHERE&lt;/code&gt; column_name &lt;code&gt;IS NULL&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; * &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;WHERE&lt;/code&gt; column_name &lt;code&gt;IS NOT NULL&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;AS-用于给表或者列分配别名&quot;&gt;&lt;a href=&quot;#AS-用于给表或者列分配别名&quot; class=&quot;headerlink&quot; title=&quot;AS: 用于给表或者列分配别名&quot;&gt;&lt;/a&gt;&lt;strong&gt;AS&lt;/strong&gt;: 用于给表或者列分配别名&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; column_name &lt;code&gt;AS&lt;/code&gt; alias_name &lt;code&gt;FROM&lt;/code&gt; table_name;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; column_name &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;AS&lt;/code&gt; alias_name;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; column_name &lt;code&gt;AS&lt;/code&gt; alias_name1, column_name2 &lt;code&gt;AS&lt;/code&gt; alias_name2;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; column_name1, column_name2 + ‘, ‘ + column_name3 &lt;code&gt;AS&lt;/code&gt; alias_name;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;UNION-用于组合两个或者多个-SELECT-语句的结果集的运算符&quot;&gt;&lt;a href=&quot;#UNION-用于组合两个或者多个-SELECT-语句的结果集的运算符&quot; class=&quot;headerlink&quot; title=&quot;UNION: 用于组合两个或者多个 SELECT 语句的结果集的运算符&quot;&gt;&lt;/a&gt;&lt;strong&gt;UNION&lt;/strong&gt;: 用于组合两个或者多个 SELECT 语句的结果集的运算符&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;每个 SELECT 语句必须拥有相同的列数&lt;/li&gt;
&lt;li&gt;列必须拥有相似的数据类型&lt;/li&gt;
&lt;li&gt;每个 SELECT 语句中的列也必须具有相同的顺序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; columns_names &lt;code&gt;FROM&lt;/code&gt; table1 &lt;code&gt;UNION SELECT&lt;/code&gt; column_name &lt;code&gt;FROM&lt;/code&gt; table2;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UNION&lt;/code&gt; 仅允许选择不同的值, &lt;code&gt;UNION ALL&lt;/code&gt; 允许重复&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;ANY-ALL-用于检查-WHERE-或-HAVING-子句中使用的子查询条件的运算符&quot;&gt;&lt;a href=&quot;#ANY-ALL-用于检查-WHERE-或-HAVING-子句中使用的子查询条件的运算符&quot; class=&quot;headerlink&quot; title=&quot;ANY|ALL: 用于检查 WHERE 或 HAVING 子句中使用的子查询条件的运算符&quot;&gt;&lt;/a&gt;&lt;strong&gt;ANY|ALL&lt;/strong&gt;: 用于检查 WHERE 或 HAVING 子句中使用的子查询条件的运算符&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ANY&lt;/code&gt; 如果任何子查询值满足条件，则返回 true。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ALL&lt;/code&gt; 如果所有子查询值都满足条件，则返回 true。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; columns_names &lt;code&gt;FROM&lt;/code&gt; table1 &lt;code&gt;WHERE&lt;/code&gt; column_name operator (&lt;code&gt;ANY&lt;/code&gt;|&lt;code&gt;ALL&lt;/code&gt;) (&lt;code&gt;SELECT&lt;/code&gt; column_name &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;WHERE&lt;/code&gt; condition);&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;GROUP-BY-通常与聚合函数（COUNT，MAX，MIN，SUM，AVG）一起使用，用于将结果集分组为一列或多列&quot;&gt;&lt;a href=&quot;#GROUP-BY-通常与聚合函数（COUNT，MAX，MIN，SUM，AVG）一起使用，用于将结果集分组为一列或多列&quot; class=&quot;headerlink&quot; title=&quot;GROUP BY: 通常与聚合函数（COUNT，MAX，MIN，SUM，AVG）一起使用，用于将结果集分组为一列或多列&quot;&gt;&lt;/a&gt;&lt;strong&gt;GROUP BY&lt;/strong&gt;: 通常与聚合函数（COUNT，MAX，MIN，SUM，AVG）一起使用，用于将结果集分组为一列或多列&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; column_name1, COUNT(column_name2) &lt;code&gt;FROM&lt;/code&gt; table_name &lt;code&gt;WHERE&lt;/code&gt; condition &lt;code&gt;GROUP BY&lt;/code&gt; column_name1 &lt;code&gt;ORDER BY&lt;/code&gt; COUNT(column_name2) DESC;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;HAVING-HAVING-子句指定-SELECT-语句应仅返回聚合值满足指定条件的行。它被添加到-SQL-语言中，因为WHERE关键字不能与聚合函数一起使用。&quot;&gt;&lt;a href=&quot;#HAVING-HAVING-子句指定-SELECT-语句应仅返回聚合值满足指定条件的行。它被添加到-SQL-语言中，因为WHERE关键字不能与聚合函数一起使用。&quot; class=&quot;headerlink&quot; title=&quot;HAVING: HAVING 子句指定 SELECT 语句应仅返回聚合值满足指定条件的行。它被添加到 SQL 语言中，因为WHERE关键字不能与聚合函数一起使用。&quot;&gt;&lt;/a&gt;&lt;strong&gt;HAVING&lt;/strong&gt;: HAVING 子句指定 SELECT 语句应仅返回聚合值满足指定条件的行。它被添加到 SQL 语言中，因为WHERE关键字不能与聚合函数一起使用。&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt; &lt;code&gt;COUNT&lt;/code&gt;(column_name1), column_name2 &lt;code&gt;FROM&lt;/code&gt; table &lt;code&gt;GROUP BY&lt;/code&gt; column_name2 &lt;code&gt;HAVING&lt;/code&gt; &lt;code&gt;COUNT(&lt;/code&gt;column_name1&lt;code&gt;)&lt;/code&gt; &amp;gt; 5;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="实践" scheme="https://z201.cn/categories/%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="MySQL" scheme="https://z201.cn/tags/MySQL/"/>
    
  </entry>
  
</feed>
